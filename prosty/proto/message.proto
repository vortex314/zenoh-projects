// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto
syntax = "proto3";
package limero;

enum LogLevel {
  DEBUG = 1;
  INFO =2 ;
  WARN = 3;
  ERROR = 4;
  FATAL = 5;
  ALERT =6 ;
}


message ZenohInfo {
  string zid=2;
  string what_am_i=3;
  repeated string peers=4;
  string prefix=5;
  repeated string routers=6;
  string connect=7;
  string listen=8;
}

message LogInfo {
  LogLevel level=2;
  string message=3;
  int32 error_code=4;
  string file=5;
  int32 line=6;
}

message SysCmd {
  required string src = 2;
  uint64 set_time = 3;
  bool reboot = 4;
  string console = 5;
}

message SysInfo {
   uint64 utc = 1;
   uint64 uptime = 2;
   uint64 free_heap = 3;
   uint64 flash = 4;
   string cpu_board = 5;
   string build_date = 6;
}

message WifiInfo {
   string ssid = 2;
   string bssid = 3;
   int32 rssi = 4;
   string ip = 5;
   string mac = 6;
   int32 channel = 7;
   string gateway = 8;
   string netmask = 9;
}

message MulticastInfo {
   string group = 2;
   int32 port = 3;
   uint32 mtu = 4 ;
}

message HoverboardInfo {
   int32 speed = 1;
   int32 direction = 2;
   int32 currentA=3;
}

message HoverboardCmd {
  string src = 2;
   int32 speed = 3;
   int32 direction = 4;
}

enum MessageType {
  SYS_CMD = 1;
  SYS_INFO = 2;
  WIFI_INFO = 3;
  MOTOR_INFO = 4;
  MOTOR_CMD = 5;
}

enum Toggle {
  OFF = 0;
  ON = 1;
}


message LpsInfo {
     int32 direction=1;
     string msg=3;
}
/*
    RET_ERR(frame_encoder.add_map(HbVar::CTRL_MOD, ctrlModReqRaw));
    RET_ERR(frame_encoder.add_map(HbVar::CTRL_TYP, rtP_Left.z_ctrlTypSel));
    RET_ERR(frame_encoder.add_map(HbVar::CUR_MOT_MAX, rtP_Left.i_max));
    RET_ERR(frame_encoder.add_map(HbVar::RPM_MOT_MAX, rtP_Left.n_max));
    RET_ERR(frame_encoder.add_map(HbVar::FI_WEAK_ENA, rtP_Left.b_fieldWeakEna));
    RET_ERR(frame_encoder.add_map(HbVar::FI_WEAK_HI, rtP_Left.r_fieldWeakHi));
    RET_ERR(frame_encoder.add_map(HbVar::FI_WEAK_LO, rtP_Left.r_fieldWeakLo));
    RET_ERR(frame_encoder.add_map(HbVar::FI_WEAK_MAX, rtP_Left.id_fieldWeakMax));
    RET_ERR(frame_encoder.add_map(HbVar::PHASE_ADV_MAX_DEG, rtP_Left.a_phaAdvMax));
    RET_ERR(frame_encoder.add_map(HbVar::IN1_RAW, input1[0].raw));
    RET_ERR(frame_encoder.add_map(HbVar::IN1_TYP, input1[0].typ));
    RET_ERR(frame_encoder.add_map(HbVar::IN1_MIN, input1[0].min));
    RET_ERR(frame_encoder.add_map(HbVar::IN1_MID, input1[0].mid));
    RET_ERR(frame_encoder.add_map(HbVar::IN1_MAX, input1[0].max));
    RET_ERR(frame_encoder.add_map(HbVar::IN1_CMD, input1[0].cmd));
    RET_ERR(frame_encoder.add_map(HbVar::IN2_RAW, input2[0].raw));
    RET_ERR(frame_encoder.add_map(HbVar::IN2_TYP, input2[0].typ));
    RET_ERR(frame_encoder.add_map(HbVar::IN2_MIN, input2[0].min));
    RET_ERR(frame_encoder.add_map(HbVar::IN2_MID, input2[0].mid));
    RET_ERR(frame_encoder.add_map(HbVar::IN2_MAX, input2[0].max));
    RET_ERR(frame_encoder.add_map(HbVar::IN2_CMD, input2[0].cmd));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN1_RAW, input1[1].raw));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN1_TYP, input1[1].typ));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN1_MIN, input1[1].min));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN1_MID, input1[1].mid));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN1_MAX, input1[1].max));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN1_CMD, input1[1].cmd));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN2_RAW, input2[1].raw));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN2_TYP, input2[1].typ));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN2_MIN, input2[1].min));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN2_MID, input2[1].mid));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN2_MAX, input2[1].max));
    RET_ERR(frame_encoder.add_map(HbVar::AUX_IN2_CMD, input2[1].cmd));
    RET_ERR(frame_encoder.add_map(HbVar::DC_CURR, dc_curr));
    RET_ERR(frame_encoder.add_map(HbVar::RDC_CURR, right_dc_curr));
    RET_ERR(frame_encoder.add_map(HbVar::LDC_CURR, left_dc_curr));
    RET_ERR(frame_encoder.add_map(HbVar::CMDL, cmdL));
    RET_ERR(frame_encoder.add_map(HbVar::CMDR, cmdR));
    RET_ERR(frame_encoder.add_map(HbVar::SPD_AVG, speedAvg));
    RET_ERR(frame_encoder.add_map(HbVar::SPDL, rtY_Left.n_mot));
    RET_ERR(frame_encoder.add_map(HbVar::SPDR, rtY_Right.n_mot));
    RET_ERR(frame_encoder.add_map(HbVar::FILTER_RATE, 0));
    RET_ERR(frame_encoder.add_map(HbVar::SPD_COEF, SPEED_COEFFICIENT));
    RET_ERR(frame_encoder.add_map(HbVar::STR_COEF, STEER_COEFFICIENT));
    RET_ERR(frame_encoder.add_map(HbVar::BATV, batVoltageCalib));
    RET_ERR(frame_encoder.add_map(HbVar::TEMP, board_temp_deg_c));

    struct PropDescriptor {
    HbVar id;
    const char* name;
    const char* description;
    uint8_t ValueType;
    uint8_t ValueMode;
} props[] = {
    {HbVar::CTRL_MOD, "CTRL_MOD", "Ctrl mode 1:Voltage 2:Speed 3:Torque", ValueType::UINT, ValueMode::READ},
    { HbVar::CTRL_TYP, "CTRL_TYP", "Ctrl type 0:Commutation 1:Sinusoidal 2:FOC", ValueType::UINT, ValueMode::READ },
    { HbVar::CUR_MOT_MAX,"I_MOT_MAX","Max phase current A", ValueType::UINT, ValueMode::WRITE },
    { HbVar::RPM_MOT_MAX,"RPM_MOT_MAX","Max motor RPM", ValueType::UINT, ValueMode::WRITE },
    { HbVar::FI_WEAK_ENA,"FI_WEAK_ENA","Enable field weak 0:OFF 1:ON", ValueType::UINT, ValueMode::READ },
    { HbVar::FI_WEAK_HI,"FI_WEAK_HI","Field weak high RPM", ValueType::UINT, ValueMode::WRITE },
    { HbVar::FI_WEAK_LO,"FI_WEAK_LO","Field weak low RPM", ValueType::UINT, ValueMode::WRITE },
    { HbVar::FI_WEAK_MAX,"FI_WEAK_MAX","Field weak max current A(FOC only)", ValueType::UINT, ValueMode::WRITE },
    { HbVar::PHASE_ADV_MAX_DEG,"PHA_ADV_MAX","Max Phase Adv angle Deg(SIN only)", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN1_RAW,"IN1_RAW","Input1 raw value", ValueType::UINT, ValueMode::READ },
    { HbVar::IN1_TYP,"IN1_TYP","Input1 type 0:Disabled, 1:Normal Pot, 2:Middle Resting Pot, 3:Auto-detect", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN1_MIN,"IN1_MIN","Input1 minimum value", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN1_MID,"IN1_MID","Input1 middle value", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN1_MAX,"IN1_MAX","Input1 maximum value", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN1_CMD,"IN1_CMD","Input1 command value", ValueType::UINT, ValueMode::READ },
    { HbVar::IN2_RAW,"IN2_RAW","Input2 raw value", ValueType::UINT, ValueMode::READ },
    { HbVar::IN2_TYP,"IN2_TYP","Input2 type 0:Disabled, 1:Normal Pot, 2:Middle Resting Pot, 3:Auto-detect", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN2_MIN,"IN2_MIN","Input2 minimum value", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN2_MID,"IN2_MID","Input2 middle value", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN2_MAX,"IN2_MAX","Input2 maximum value", ValueType::UINT, ValueMode::WRITE },
    { HbVar::IN2_CMD,"IN2_CMD","Input2 command value", ValueType::UINT, ValueMode::READ },
    { HbVar::DC_CURR,"DC_CURR","Total DC Link current A *100", ValueType::UINT, ValueMode::READ },
    { HbVar::LDC_CURR,"LDC_CURR","Left DC Link current A *100", ValueType::UINT, ValueMode::READ },
    { HbVar::RDC_CURR,"RDC_CURR","Right DC Link current A *100", ValueType::UINT, ValueMode::READ },
    { HbVar::CMDL,"CMDL","Left Motor Command RPM", ValueType::UINT, ValueMode::READ },
    { HbVar::CMDR,"CMDR","Right Motor Command RPM", ValueType::UINT, ValueMode::READ },
    { HbVar::SPD_AVG,"SPD_AVG","Motor Measured Avg RPM", ValueType::UINT, ValueMode::READ },
    { HbVar::SPDL,"SPDL","Left Motor Measured RPM", ValueType::UINT, ValueMode::READ },
    { HbVar::SPDR,"SPDR","Right Motor Measured RPM", ValueType::UINT, ValueMode::READ },
    { HbVar::FILTER_RATE,"RATE","Rate *10", ValueType::UINT, ValueMode::READ },
    { HbVar::SPD_COEF,"SPD_COEF","Speed Coefficient *10", ValueType::UINT, ValueMode::READ },
    { HbVar::STR_COEF,"STR_COEF","Steer Coefficient *10", ValueType::UINT, ValueMode::READ },
    { HbVar::BATV,"BATV","Calibrated Battery Voltage *100", ValueType::UINT, ValueMode::READ },
    { HbVar::TEMP,"TEMP","Calibrated Temperature Â°C *10", ValueType::UINT, ValueMode::READ },
};
*/
message HoverboardInfo {

}

message HoverboardCmd {

}