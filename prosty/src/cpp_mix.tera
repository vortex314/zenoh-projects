#pragma once
#include <string>
#include <vector>
#include <cstdint>
#include <optional>
#include <ArduinoJson.h>
#include <cbor.h>
#include <msg.h>
#include <serdes.h>

    // Helper macros for serialization and deserialization
    {% macro serialize_any( encoder, field_type, target) %}
        {%- if field_type == "std::string" -%}
    cbor_encode_text_stringz(&{{encoder}}, {{ target }}.c_str());
        {%- elif field_type == "Bytes" -%}
    cbor_encode_byte_string(&{{encoder}}, {{ target }}.data(), {{ target }}.size());
        {%- elif field_type  == "uint32_t" -%}
    cbor_encode_int(&{{encoder}}, {{ target }});
        {%- elif field_type == "int32_t" -%}
    cbor_encode_int(&{{encoder}}, {{ target }});
        {%- elif field_type == "uint64_t" -%}
    cbor_encode_int(&{{encoder}}, {{ target }});
        {%- elif field_type == "int64_t" -%}
    cbor_encode_int(&{{encoder}}, {{ target }});
        {%- elif field_type == "float" -%}
    cbor_encode_float(&{{encoder}}, {{ target }});
        {%- elif field_type == "double" -%}
    cbor_encode_double(&{{encoder}}, {{ target }});
        {%- elif field_type == "bool" -%}
    cbor_encode_boolean(&{{encoder}}, {{ target }});
        {%- else -%}
    cbor_encode_int(&{{encoder}}, {{ target }});
        {%- endif -%}
    {% endmacro %}
    
{% macro deserialize_any( decoder, field_type,target) %}
    {%- if field_type == "std::string" -%}
    {
        char valbuf[256];
        size_t vallen = sizeof(valbuf);
        if (cbor_value_is_text_string(&{{decoder}})) {
            cbor_value_copy_text_string(&{{decoder}}, valbuf, &vallen, &{{decoder}});
            {{ target }} = std::string(valbuf, vallen - 1);
        }
    }
    {%- elif field_type == "Bytes" -%}
    {
        uint8_t tmpbuf[512];
        size_t tmplen = sizeof(tmpbuf);
        if (cbor_value_is_byte_string(&{{decoder}})) {
            cbor_value_copy_byte_string(&{{decoder}}, tmpbuf, &tmplen, &{{decoder}});
            {{ target }} = Bytes(tmpbuf, tmpbuf + tmplen);
        }
    }
    {%- elif field_type == "uint32_t" -%}
    {
        uint64_t v;
        cbor_value_get_uint64(&{{decoder}}, &(v));
        {{ target }} = v;
    }
    {%- elif field_type == "int32_t" -%}
    {
        int64_t v;
        cbor_value_get_int64(&{{decoder}}, &(v));
        {{ target }} = v;
    }
    {%- elif field_type == "uint64_t" -%}
        cbor_value_get_uint64(&{{decoder}}, &({{target}}));
    {%- elif field_type == "int64_t" -%}
        cbor_value_get_int64(&{{decoder}}, &({{target}}));
    {%- elif field_type == "float" -%}
        cbor_value_get_float(&{{decoder}}, &({{target}}));
    {%- elif field_type == "double" -%} 
        cbor_value_get_double(&{{decoder}}, &({{target}}));
    {%- elif field_type == "bool" -%} 
        cbor_value_get_boolean(&{{decoder}}, &({{target}}));
    {%- else -%}
    {
        long long v;
        cbor_value_get_int64(&{{decoder}}, &(v));
        {{ target }} = static_cast<{{ field_type }}>(v);
    }
    {%- endif -%}
    {% endmacro %}

typedef std::vector<uint8_t> Bytes;

{% for en in enums %}
typedef enum {
    {%- for value in en.values %}
    {{ value.0 }} = {{ value.1 }},
    {%- endfor %}
} {{ en.name }};
{% endfor %}

{% for msg in messages %}
class {{ msg.name }} : public Msg {
    MSG({{ msg.name }});
    public:
    {% for field in msg.fields %}
        {%- if field.repeated -%}
        std::vector<{{ field.target_type }}>
        {%- elif field.optional -%}
        std::optional<{{ field.target_type }}> 
        {%- else -%}
        {{ field.target_type }} 
        {%- endif %} {{ field.name }};
    {% endfor %}

    Bytes serialize() const {
        JsonDocument doc;
        {% for field in msg.fields %}
            {%- if field.repeated -%}
                {
                    JsonArray arr = doc["{{ field.name }}"].to<JsonArray>();
                    for (const auto& item : {{ field.name }}) {
                        arr.add(item);
                    }
                }
            {%- elif field.optional -%}
                if ({{ field.name }})  
                {%- if field.target_type == "Bytes" %}
                        doc["{{ field.name }}"] = base64_encode(*{{ field.name }});
                    {%- else -%}
                        doc["{{ field.name }}"] = *{{ field.name }};
                    {%- endif-%}
            {%- elif field.target_type == "Bytes" -%}
                doc["{{ field.name }}"] = base64_encode({{ field.name }}); 
            {%- else -%}
                doc["{{ field.name }}"] = {{ field.name }};
            {%- endif %}
        {% endfor -%}
        std::string str;
        ArduinoJson::serializeJson(doc,str);
        return Bytes(str.begin(),str.end());
    }

    {{msg.name}}* deserialize(const Bytes& bytes) {
        JsonDocument doc;
        {{msg.name}}* msg = new {{msg.name}}();
        auto err = deserializeJson(doc,bytes);
        if ( err != DeserializationError::Ok || doc.is<JsonObject>() == false ) {
            delete msg;
            return NULL ;
        };        
        {% for field in msg.fields %}
            {%- if field.repeated -%}
                if (doc["{{ field.name }}"].is<JsonArray>()) {
                    JsonArray arr = doc["{{ field.name }}"].as<JsonArray>();
                    msg->{{ field.name }}.clear();
                    for (JsonVariant v : arr) {
                        msg->{{ field.name }}.push_back(v.as<{{ field.target_type }}>());
                    }
                }
            {%- elif field.optional -%}
                    {%- if field.target_type == "Bytes" -%}
                    if (doc["{{ field.name }}"].is<std::string>() )  
                        msg->{{ field.name }} = base64_decode(doc["{{ field.name }}"].as<std::string>());
                    {%- else -%}
                    if (doc["{{ field.name }}"].is<{{ field.target_type }}>() )  
                        msg->{{ field.name }} = doc["{{ field.name }}"].as<{{ field.target_type }}>();
                    {%- endif-%}
            {%- elif field.target_type == "Bytes" -%}
                if (doc["{{ field.name }}"].is<std::string>()) 
                    msg->{{ field.name }} = base64_decode(doc["{{ field.name }}"].as<std::string>());
            {%- else -%}
                if (doc["{{ field.name }}"].is<{{ field.target_type }}>() )
                    msg->{{ field.name }} = doc["{{ field.name }}"].as<{{ field.target_type }}>();        
            {%- endif %}
        {% endfor -%}
        return msg;
    }

    typedef enum {
        {%- for field in msg.fields %}
            {{ field.name | upper }}_INDEX = {{ field.index }},
        {%- endfor %}
        } Field;


    Bytes cbor_serialize() const {
        // buffer: grow if needed by changing initial size
        std::vector<uint8_t> buffer(512);
        CborEncoder encoder, mapEncoder;
        cbor_encoder_init(&encoder, buffer.data(), buffer.size(), 0);

        // Start top-level map
        cbor_encoder_create_map(&encoder, &mapEncoder, CborIndefiniteLength);

        {% for field in msg.fields %}
            {%- if field.repeated -%}
                {
                CborEncoder arrayEncoder;
                cbor_encode_int(&mapEncoder, Field::{{ field.name | upper }}_INDEX );
                cbor_encoder_create_array(&mapEncoder, &arrayEncoder, {{ field.name }}.size());
                for (const auto & item : {{ field.name }}) {
                    {#- type-specific encode #}
                    {{ self::serialize_any(encoder="arrayEncoder", field_type=field.target_type, target="item") }}
                }
                cbor_encoder_close_container(&mapEncoder, &arrayEncoder);
                }
            {%- elif field.optional -%}
            if ({{ field.name }}) {
                cbor_encode_int(&mapEncoder, Field::{{ field.name | upper }}_INDEX);
                {{ self::serialize_any(encoder="mapEncoder", field_type=field.target_type, target=field.name ~ ".value()") }}
                }
            {%- else -%}
                // field: {{ field.name }}
                cbor_encode_int(&mapEncoder, Field::{{ field.name | upper }}_INDEX);
                {{ self::serialize_any(encoder="mapEncoder", field_type=field.target_type, target=field.name) }}
            {%- endif %}
        {% endfor -%}
        cbor_encoder_close_container(&encoder, &mapEncoder);
        // get used size
        size_t used = cbor_encoder_get_buffer_size(&encoder, buffer.data());
        return Bytes(buffer.begin(), buffer.begin() + used);
    }

    static {{msg.name}}* cbor_deserialize(const Bytes& bytes) {
        CborParser parser;
        CborValue it, mapIt;
        {{msg.name}}* msg = new {{msg.name}}();

        CborError err = cbor_parser_init(bytes.data(), bytes.size(), 0, &parser, &it);
        if (err != CborNoError) {
            delete msg;
            return nullptr;
        }

        if (!cbor_value_is_map(&it)) {
            delete msg;
            INFO("CBOR deserialization error: not a map");
            return nullptr;
        }

        // enter map
        err = cbor_value_enter_container(&it, &mapIt);
        if (err != CborNoError) {
            delete msg;
            INFO("CBOR deserialization error: failed to enter container");
            return nullptr;
        }

        // iterate key/value pairs
        while (!cbor_value_at_end(&mapIt)) {
            uint64_t key = 0;
            if (cbor_value_is_unsigned_integer(&mapIt)) {
                cbor_value_get_uint64(&mapIt, &key);
                cbor_value_advance(&mapIt);
            } else {
                // invalid key type
                INFO("CBOR deserialization error: invalid key type");
                delete msg;
                return nullptr;
            }
            switch (key) {
                {% for field in msg.fields %}
                case Field::{{ field.name | upper }}_INDEX:{
                    {%- if field.repeated -%}
                    CborValue tmp;
                    cbor_value_enter_container(&mapIt,&tmp);
                    while (!cbor_value_at_end(&tmp)) {
                        {{field.target_type}} v;
                        {{ self::deserialize_any( decoder="tmp", field_type=field.target_type, target="v" ) }}
                        msg->{{field.name}}.push_back(v);
                    }
                    cbor_value_leave_container(&mapIt,&tmp);
                    {%- elif field.optional -%}
                    {{ self::deserialize_any( decoder="mapIt", field_type=field.target_type, target="*msg->" ~ field.name) }}
                    {%- else -%}
                    {{ self::deserialize_any( decoder="mapIt", field_type=field.target_type, target="*msg->" ~ field.name) }}
                    {%- endif %}
                    break;
                }
                {% endfor %}
                default:
                    // skip unknown key
                    cbor_value_advance(&mapIt);
                    break;
            }

        }

        // leave container
        cbor_value_leave_container(&it, &mapIt);

        return msg;
    }

};
{% endfor %}
