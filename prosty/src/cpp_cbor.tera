#pragma once
#include <string>
#include <vector>
#include <cstdint>
#include <optional>
#include <cbor.h>
#include <functional>
#include <actor.h>

typedef std::vector<uint8_t> Bytes;


// Helper macros for serialization and deserialization
{% macro serialize_any( encoder, field_type, field_name) %}
    {%- if field_type == "std::string" -%}
cbor_encode_text_stringz(&{{encoder}}, {{ field_name }}.c_str());
    {%- elif field_type == "Bytes" -%}
cbor_encode_byte_string(&{{encoder}}, {{ field_name }}.data(), {{ field_name }}.size());
    {%- elif field_type  == "uint32_t" -%}
cbor_encode_int(&{{encoder}}, {{ field_name }});
    {%- elif field_type == "int32_t" -%}
cbor_encode_int(&{{encoder}}, {{ field_name }});
    {%- elif field_type == "uint64_t" -%}
cbor_encode_int(&{{encoder}}, {{ field_name }});
    {%- elif field_type == "int64_t" -%}
cbor_encode_int(&{{encoder}}, {{ field_name }});
    {%- elif field_type == "float" -%}
cbor_encode_float(&{{encoder}}, {{ field_name }});
    {%- elif field_type == "double" -%}
cbor_encode_double(&{{encoder}}, {{ field_name }});
    {%- elif field_type == "bool" -%}
cbor_encode_boolean(&{{encoder}}, {{ field_name }});
    {%- else -%}
cbor_encode_int(&{{encoder}}, {{ field_name }});
    {%- endif -%}
{% endmacro %}

{% macro deserialize_any( decoder, field_type,field_name) %}
{%- if field_type == "std::string" -%}
{
    char valbuf[256];
    size_t vallen = sizeof(valbuf);
    if (cbor_value_is_text_string(&{{decoder}})) {
        cbor_value_copy_text_string(&{{decoder}}, valbuf, &vallen, &{{decoder}});
        {{ field_name }} = std::string(valbuf, vallen - 1);
    }
}
{%- elif field_type == "Bytes" -%}
{
    uint8_t tmpbuf[512];
    size_t tmplen = sizeof(tmpbuf);
    if (cbor_value_is_byte_string(&{{decoder}})) {
        cbor_value_copy_byte_string(&{{decoder}}, tmpbuf, &tmplen, &{{decoder}});
        {{ field_name }} = Bytes(tmpbuf, tmpbuf + tmplen);
    }
}
{%- elif field_type == "uint32_t" -%}
{
    uint64_t v;
    cbor_value_get_uint64(&{{decoder}}, &v);
    {{ field_name }} = v;
}
{%- elif field_type == "int32_t" -%}
{
    int64_t v;
    cbor_value_get_int64(&{{decoder}}, &v);
    {{ field_name }} = v;
}
{%- elif field_type == "uint64_t" -%}
    cbor_value_get_uint64(&{{decoder}}, &{{field_name}});
{%- elif field_type == "int64_t" -%}
    cbor_value_get_int64(&{{decoder}}, &{{field_name}});
{%- elif field_type == "float" -%}
    cbor_value_get_float(&{{decoder}}, &{{field_name}});
{%- elif field_type == "double" -%} 
    cbor_value_get_double(&{{decoder}}, &{{field_name}});
{%- elif field_type == "bool" -%} 
    cbor_value_get_boolean(&{{decoder}}, &{{field_name}});
{%- else -%}
{
    long long v;
    cbor_value_get_int64(&{{decoder}}, &v);
    {{ field_name }} = static_cast<{{ field_type }}>(v);
}
{%- endif -%}
{% endmacro %}

{% for en in enums %}
typedef enum {
    {%- for value in en.values %}
    {{ value.0 }} = {{ value.1 }},
    {%- endfor %}
} {{ en.name }};
{% endfor %}

{% for msg in messages %}
static constexpr const char {{ msg.name | upper }}_NAME[] = "{{msg.name}}";

class {{ msg.name }} : public Msg<{{ msg.name | upper }}_NAME> {
    public:

    {% for field in msg.fields %}
        {%- if field.repeated -%}
        std::vector<{{ field.target_type }}>
        {%- elif field.optional -%}
        std::optional<{{ field.target_type }}> 
        {%- else -%}
        {{ field.target_type }} 
        {%- endif %} {{ field.name }};
    {% endfor %}

    typedef enum {
    {%- for field in msg.fields %}
        {{ field.name | upper }}_INDEX = {{ field.index }},
    {%- endfor %}
    } Field;

    Bytes serialize() const {
        // buffer: grow if needed by changing initial size
        std::vector<uint8_t> buffer(512);
        CborEncoder encoder, mapEncoder;
        cbor_encoder_init(&encoder, buffer.data(), buffer.size(), 0);

        // Start top-level map
        cbor_encoder_create_map(&encoder, &mapEncoder, CborIndefiniteLength);

        {% for field in msg.fields %}
            {%- if field.repeated -%}
                {
                CborEncoder arrayEncoder;
                cbor_encode_int(&mapEncoder, Field::{{ field.name | upper }}_INDEX );
                cbor_encoder_create_array(&mapEncoder, &arrayEncoder, {{ field.name }}.size());
                for (const auto & item : {{ field.name }}) {
                    {#- type-specific encode #}
                    {{ self::serialize_any(encoder="arrayEncoder", field_type=field.target_type, field_name="item") }}
                }
                cbor_encoder_close_container(&mapEncoder, &arrayEncoder);
                }
            {%- elif field.optional -%}
            if ({{ field.name }}) {
                cbor_encode_int(&mapEncoder, Field::{{ field.name | upper }}_INDEX);
                {{ self::serialize_any(encoder="mapEncoder", field_type=field.target_type, field_name=field.name ~ ".value()") }}
                }
            {%- else -%}
                // field: {{ field.name }}
                cbor_encode_int(&mapEncoder, Field::{{ field.name | upper }}_INDEX);
                {{ self::serialize_any(encoder="mapEncoder", field_type=field.target_type, field_name=field.name) }}
            {%- endif %}
        {% endfor -%}
        cbor_encoder_close_container(&encoder, &mapEncoder);
        // get used size
        size_t used = cbor_encoder_get_buffer_size(&encoder, buffer.data());
        return Bytes(buffer.begin(), buffer.begin() + used);
    }

    {{msg.name}}* deserialize(const Bytes& bytes) {
        CborParser parser;
        CborValue it, mapIt;
        {{msg.name}}* msg = new {{msg.name}}();

        CborError err = cbor_parser_init(bytes.data(), bytes.size(), 0, &parser, &it);
        if (err != CborNoError) {
            delete msg;
            return nullptr;
        }

        if (!cbor_value_is_map(&it)) {
            delete msg;
            return nullptr;
        }

        // enter map
        err = cbor_value_enter_container(&it, &mapIt);
        if (err != CborNoError) {
            delete msg;
            return nullptr;
        }

        // iterate key/value pairs
        while (!cbor_value_at_end(&mapIt)) {
            uint64_t key = 0;
            if (cbor_value_is_unsigned_integer(&mapIt)) {
                cbor_value_get_uint64(&mapIt, &key);
                cbor_value_advance(&mapIt);
            } else {
                // invalid key type
                delete msg;
                return nullptr;
            }
            switch (key) {
                {% for field in msg.fields %}
                case Field::{{ field.name | upper }}_INDEX:{
                    {%- if field.repeated -%}
                    CborValue tmp;
                    cbor_value_enter_container(&mapIt,&tmp);
                    while (!cbor_value_at_end(&tmp)) {
                        {{field.target_type}} v;
                        {{ self::deserialize_any( decoder="tmp", field_type=field.target_type, field_name="v" ) }}
                        {{field.name}}.push_back(v);
                    }
                    cbor_value_leave_container(&mapIt,&tmp);
                    {%- elif field.optional -%}
                    {{ self::deserialize_any( decoder="mapIt", field_type=field.target_type, field_name="*" ~ field.name) }}
                    {%- else -%}
                    {{ self::deserialize_any( decoder="mapIt", field_type=field.target_type, field_name=field.name) }}
                    {%- endif %}
                    break;
                }
                {% endfor %}
                default:
                    // skip unknown key
                    cbor_value_advance(&mapIt);
                    break;
            }

        }

        // leave container
        cbor_value_leave_container(&it, &mapIt);

        return msg;
    }

};
{% endfor %}
