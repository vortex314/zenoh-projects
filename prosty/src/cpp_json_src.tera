#include <string>
#include <vector>
#include <cstdint>
#include <optional>
#include <ArduinoJson.h>
#include <cbor.h>
#include <msg.h>
#include <serdes.h>

#include "{{ package }}.h"

{% for msg in messages %}
Result<Bytes> {{msg.name}}::json_serialize(const {{msg.name}}& msg)  {
        JsonDocument doc;
        {% for field in msg.fields %}
            {%- if field.repeated -%}
                if (msg.{{field.name}}.size()) {
                    JsonArray arr = doc["{{ field.name }}"].to<JsonArray>();
                    for (const auto& item : msg.{{ field.name }}) {
                        arr.add(item);
                    }
                }
            {%- elif field.optional -%}
                if (msg.{{ field.name }})  
                    {%- if field.target_type == "Bytes" %}
                        doc["{{ field.name }}"] = base64_encode(*msg.{{ field.name }});
                    {%- else -%}
                        doc["{{ field.name }}"] = *msg.{{ field.name }};
                    {%- endif-%}
            {%- elif field.target_type == "Bytes" -%}
                doc["{{ field.name }}"] = base64_encode(msg.{{ field.name }}); 
            {%- else -%}
                doc["{{ field.name }}"] = msg.{{ field.name }};
            {%- endif %}
        {% endfor -%}
        std::string str;
        ArduinoJson::serializeJson(doc,str);
        return Result<Bytes>::Ok(Bytes(str.begin(),str.end()));
    }

    Result<{{msg.name}}*> {{msg.name}}::json_deserialize(const Bytes& bytes) {
        JsonDocument doc;
        {{msg.name}}* msg = new {{msg.name}}();
        auto err = deserializeJson(doc,bytes);
        if ( err != DeserializationError::Ok || doc.is<JsonObject>() == false ) {
            delete msg;
            return Result<{{msg.name}}*>::Err(-1,"Cannot deserialize as object") ;
        };        
        {% for field in msg.fields %}
            {%- if field.repeated -%}
                if (doc["{{ field.name }}"].is<JsonArray>()) {
                    JsonArray arr = doc["{{ field.name }}"].as<JsonArray>();
                    msg->{{ field.name }}.clear();
                    for (JsonVariant v : arr) {
                        msg->{{ field.name }}.push_back(v.as<{{ field.target_type }}>());
                    }
                }
            {%- elif field.optional -%}
                    {%- if field.target_type == "Bytes" -%}
                    if (doc["{{ field.name }}"].is<std::string>() )  
                        msg->{{ field.name }} = base64_decode(doc["{{ field.name }}"].as<std::string>());
                    {%- else -%}
                    if (doc["{{ field.name }}"].is<{{ field.target_type }}>() )  
                        msg->{{ field.name }} = doc["{{ field.name }}"].as<{{ field.target_type }}>();
                    {%- endif-%}
            {%- elif field.target_type == "Bytes" -%}
                if (doc["{{ field.name }}"].is<std::string>()) 
                    msg->{{ field.name }} = base64_decode(doc["{{ field.name }}"].as<std::string>());
            {%- else -%}
                if (doc["{{ field.name }}"].is<{{ field.target_type }}>() )
                    msg->{{ field.name }} = doc["{{ field.name }}"].as<{{ field.target_type }}>();        
            {%- endif %}
        {% endfor -%}
        return Result<{{msg.name}}*>::Ok(msg);
    }

{% endfor %}

// Helper macros for serialization and deserialization
{% macro serialize_any( encoder, field_type, target) %}
    {%- if field_type == "std::string" -%}
cbor_encode_text_stringz(&{{encoder}}, {{ target }}.c_str());
    {%- elif field_type == "Bytes" -%}
cbor_encode_byte_string(&{{encoder}}, {{ target }}.data(), {{ target }}.size());
    {%- elif field_type  == "uint32_t" -%}
cbor_encode_int(&{{encoder}}, {{ target }});
    {%- elif field_type == "int32_t" -%}
cbor_encode_int(&{{encoder}}, {{ target }});
    {%- elif field_type == "uint64_t" -%}
cbor_encode_int(&{{encoder}}, {{ target }});
    {%- elif field_type == "int64_t" -%}
cbor_encode_int(&{{encoder}}, {{ target }});
    {%- elif field_type == "float" -%}
cbor_encode_float(&{{encoder}}, {{ target }});
    {%- elif field_type == "double" -%}
cbor_encode_double(&{{encoder}}, {{ target }});
    {%- elif field_type == "bool" -%}
cbor_encode_boolean(&{{encoder}}, {{ target }});
    {%- else -%}
cbor_encode_int(&{{encoder}}, {{ target }});
    {%- endif -%}
{% endmacro %}

{% macro deserialize_any( decoder, field_type,target) %}
{%- if field_type == "std::string" -%}
{
    char valbuf[256];
    size_t vallen = sizeof(valbuf);
    if (cbor_value_is_text_string(&{{decoder}})) {
        cbor_value_copy_text_string(&{{decoder}}, valbuf, &vallen, NULL);
        {{ target }} = std::string(valbuf, vallen - 1);
    }
};
{%- elif field_type == "Bytes" -%}
{
    uint8_t tmpbuf[512];
    size_t tmplen = sizeof(tmpbuf);
    if (cbor_value_is_byte_string(&{{decoder}})) {
        cbor_value_copy_byte_string(&{{decoder}}, tmpbuf, &tmplen, NULL);
        {{ target }} = Bytes(tmpbuf, tmpbuf + tmplen);
    }
};
{%- elif field_type == "uint32_t" -%}
{
    uint64_t v;
    cbor_value_get_uint64(&{{decoder}}, &(v));
    {{ target }} = v;
};
{%- elif field_type == "int32_t" -%}
    int64_t v;
    cbor_value_get_int64(&{{decoder}}, &v);
    {{ target }} = v;

{%- elif field_type == "uint64_t" -%}
    uint64_t v;
    cbor_value_get_uint64(&{{decoder}}, &v);
    {{ target }} = v;  // Assigning the value to target
{%- elif field_type == "int64_t" -%}
    int64_t v;
    cbor_value_get_int64(&{{decoder}}, &v);
    {{ target }} = v;
{%- elif field_type == "float" -%}
    float f;
    cbor_value_get_float(&{{decoder}}, &f);
    {{target}} = f;
{%- elif field_type == "double" -%} 
    double d;
    cbor_value_get_double(&{{decoder}}, &d);
    {{target}} = d;
{%- elif field_type == "bool" -%} 
    bool b;
    cbor_value_get_boolean(&{{decoder}}, &b);
    {{target}} = b;
{%- else -%}
{
    long long v;
    cbor_value_get_int64(&{{decoder}}, &(v));
    {{ target }} = static_cast<{{ field_type }}>(v);
};
{%- endif %}
    cbor_value_advance(&{{decoder}});
{% endmacro %}

// CBOR Serialization/Deserialization

{% for msg in messages %}
Result<Bytes> {{msg.name}}::cbor_serialize(const {{msg.name}}& msg)  {
    // buffer: grow if needed by changing initial size
    std::vector<uint8_t> buffer(512);
    CborEncoder encoder, mapEncoder;
    cbor_encoder_init(&encoder, buffer.data(), buffer.size(), 0);

    // Start top-level map
    cbor_encoder_create_map(&encoder, &mapEncoder, CborIndefiniteLength);

    {% for field in msg.fields %}
        {%- if field.repeated -%}
            {
            CborEncoder arrayEncoder;
            cbor_encode_int(&mapEncoder, {{msg.name}}::Field::{{ field.name | upper }}_INDEX );
            cbor_encoder_create_array(&mapEncoder, &arrayEncoder, msg.{{ field.name }}.size());
            for (const auto & item : msg.{{ field.name }}) {
                {#- type-specific encode #}
                {{ self::serialize_any(encoder="arrayEncoder", field_type=field.target_type, target="item") }}
            }
            cbor_encoder_close_container(&mapEncoder, &arrayEncoder);
            }
        {%- elif field.optional -%}
        if (msg.{{ field.name }}) {
            cbor_encode_int(&mapEncoder, {{msg.name}}::Field::{{ field.name | upper }}_INDEX);
            {{ self::serialize_any(encoder="mapEncoder", field_type=field.target_type, target="msg." ~ field.name ~ ".value()") }}
            }
        {%- else -%}
            // field: {{ field.name }}
            cbor_encode_int(&mapEncoder, {{msg.name}}::Field::{{ field.name | upper }}_INDEX);
            {{ self::serialize_any(encoder="mapEncoder", field_type=field.target_type, target="msg." ~ field.name) }}
        {%- endif %}
    {% endfor -%}
    cbor_encoder_close_container(&encoder, &mapEncoder);
    // get used size
    size_t used = cbor_encoder_get_buffer_size(&encoder, buffer.data());
    return Bytes(buffer.begin(), buffer.begin() + used);
}

 Result<{{msg.name}}*> {{msg.name}}::cbor_deserialize(const Bytes& bytes) {
    CborParser parser;
    CborValue it, mapIt;
    {{msg.name}}* msg = new {{msg.name}}();

    CborError err = cbor_parser_init(bytes.data(), bytes.size(), 0, &parser, &it);
    if (err != CborNoError) {
        delete msg;
        return Result<{{msg.name}}*>::Err(-1,"CBOR parse error");
    }

    if (!cbor_value_is_map(&it)) {
        delete msg;
        INFO("CBOR deserialization error: not a map");
        return Result<{{msg.name}}*>::Err(-2,"CBOR deserialization error: not a map");
    }

    // enter map
    err = cbor_value_enter_container(&it, &mapIt);
    if (err != CborNoError) {
        delete msg;
        INFO("CBOR deserialization error: failed to enter container");
        return Result<{{msg.name}}*>::Err(-3,"CBOR deserialization error: failed to enter container");
    }

    // iterate key/value pairs
    while (!cbor_value_at_end(&mapIt)) {
        uint64_t key = 0;
        if (cbor_value_is_unsigned_integer(&mapIt)) {
            cbor_value_get_uint64(&mapIt, &key);
            cbor_value_advance(&mapIt);
        } else {
            // invalid key type
            INFO("CBOR deserialization error: invalid key type");
            delete msg;
            return Result<{{msg.name}}*>::Err(-4,"CBOR deserialization error: invalid key type");
        }
        switch (key) {
            {% for field in msg.fields %}
            case {{msg.name}}::Field::{{ field.name | upper }}_INDEX:{
                {%- if field.repeated -%}
                CborValue tmp;
                cbor_value_enter_container(&mapIt,&tmp);
                while (!cbor_value_at_end(&tmp)) {
                    {{field.target_type}} v;
                    {{ self::deserialize_any( decoder="tmp", field_type=field.target_type, target="v" ) }}
                    msg->{{field.name}}.push_back(v);
                };
                cbor_value_leave_container(&mapIt,&tmp);
                {%- elif field.optional -%}
                {{ self::deserialize_any( decoder="mapIt", field_type=field.target_type, target="msg->" ~ field.name) }}
                {%- else -%}
                {{ self::deserialize_any( decoder="mapIt", field_type=field.target_type, target="msg->" ~ field.name) }}
                {%- endif %}
                break;
            }
            {% endfor %}
            default:
                // skip unknown key
                cbor_value_advance(&mapIt);
                break;
        }

    }

    // leave container
    cbor_value_leave_container(&it, &mapIt);

    return Result<{{msg.name}}*>::Ok(msg);
}
{% endfor %}
