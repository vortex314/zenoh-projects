use serde::{Serialize, Deserialize};
use serde::de::DeserializeOwned;
use anyhow::Result;
use minicbor::{Encode, Decode};

pub trait TypedMessage : DeserializeOwned + Send + Sync +'static{
    const ID: u32;
    const MSG_TYPE: &'static str;
}
pub trait Msg  : Send + Sync {
    fn type_name(&self) -> &'static str ;
    fn type_id(&self) -> u32 ;
    fn cbor_serialize(&self) -> Result<Vec<u8>>;
    fn cbor_deserialize(v:&Vec<u8>) -> Result<Self> where Self : Sized;
    fn json_serialize(&self) -> Result<Vec<u8>>;
    fn json_deserialize(v:&Vec<u8>) -> Result<Self> where Self : Sized;
}

{% for en in enums %}
#[derive(Debug, Clone, Serialize, Deserialize,Encode, Decode)]
pub enum {{ en.name }} {
    {%- for value in en.values %}
    #[n({{ value.1 }})]
    {{ value.0 }},
    {%- endfor %}
}
{% endfor %}

{% for msg in messages %}
#[derive(Debug, Clone, Serialize, Deserialize, Default,Encode, Decode)]
#[cbor(map)]
pub struct {{ msg.name }} {
{%- for field in msg.fields -%}
    {% if field.source_type=="Bytes" %}
    #[cbor(n({{ field.index }}), with = "minicbor::bytes")]
    {% else %}
    #[n({{ field.index }})]
    {% endif -%}
    {%- if field.repeated -%}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub {{ field.name }}: Option<Vec<{{ field.target_type }}>>,
    {%- elif field.optional -%}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub {{ field.name }}: Option<{{ field.target_type }}>,
    {%- else %}
    pub {{ field.name }}: {{ field.target_type }},
    {%- endif %}
{%- endfor %}
}

impl TypedMessage for {{ msg.name }} {
    const ID: u32 = {{ msg.msg_id }};
    const MSG_TYPE: &'static str = "{{ msg.name }}";
}

impl Msg for {{ msg.name }} {
    fn type_name(&self) -> &'static str {<Self as TypedMessage>::MSG_TYPE}
    fn type_id(&self) -> u32 {<Self as TypedMessage>::ID}
    fn cbor_serialize(&self) -> Result<Vec<u8>> {Ok(minicbor::to_vec(self)?)}
    fn cbor_deserialize(v:&Vec<u8>) -> Result<Self> where Self : Sized {Ok(minicbor::decode::<Self>(v.as_slice())?)}
    fn json_serialize(&self) -> Result<Vec<u8>> {Ok(serde_json::to_vec(self) ?)}
    fn json_deserialize(v:& Vec<u8>) -> Result<Self> where Self : Sized {Ok(serde_json::from_slice(v.as_slice()) ?)}
}
    
{% endfor %}
