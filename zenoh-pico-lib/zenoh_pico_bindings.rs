/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const ZENOH_PICO: &[u8; 6] = b"1.5.0\0";
pub const ZENOH_PICO_MAJOR: u32 = 1;
pub const ZENOH_PICO_MINOR: u32 = 5;
pub const ZENOH_PICO_PATCH: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const __have_longlong64: u32 = 1;
pub const __have_long64: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 2] = b"l\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 2] = b"l\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 2] = b"l\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NANO_MALLOC: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_BACKWARD_BINARY_COMPAT: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const Z_FRAG_MAX_SIZE: u32 = 4096;
pub const Z_BATCH_UNICAST_SIZE: u32 = 2048;
pub const Z_BATCH_MULTICAST_SIZE: u32 = 2048;
pub const Z_CONFIG_SOCKET_TIMEOUT: u32 = 100;
pub const Z_TRANSPORT_LEASE: u32 = 10000;
pub const ZP_PERIODIC_SCHEDULER_MAX_TASKS: u32 = 64;
pub const Z_FEATURE_MULTI_THREAD: u32 = 1;
pub const Z_FEATURE_PUBLICATION: u32 = 1;
pub const Z_FEATURE_ADVANCED_PUBLICATION: u32 = 0;
pub const Z_FEATURE_SUBSCRIPTION: u32 = 1;
pub const Z_FEATURE_ADVANCED_SUBSCRIPTION: u32 = 0;
pub const Z_FEATURE_QUERY: u32 = 1;
pub const Z_FEATURE_QUERYABLE: u32 = 1;
pub const Z_FEATURE_LIVELINESS: u32 = 1;
pub const Z_FEATURE_RAWETH_TRANSPORT: u32 = 0;
pub const Z_FEATURE_INTEREST: u32 = 1;
pub const Z_FEATURE_LINK_TCP: u32 = 1;
pub const Z_FEATURE_LINK_BLUETOOTH: u32 = 0;
pub const Z_FEATURE_LINK_WS: u32 = 0;
pub const Z_FEATURE_LINK_SERIAL: u32 = 0;
pub const Z_FEATURE_LINK_SERIAL_USB: u32 = 0;
pub const Z_FEATURE_LINK_TLS: u32 = 0;
pub const Z_FEATURE_SCOUTING: u32 = 1;
pub const Z_FEATURE_LINK_UDP_MULTICAST: u32 = 1;
pub const Z_FEATURE_LINK_UDP_UNICAST: u32 = 1;
pub const Z_FEATURE_MULTICAST_TRANSPORT: u32 = 1;
pub const Z_FEATURE_UNICAST_TRANSPORT: u32 = 1;
pub const Z_FEATURE_FRAGMENTATION: u32 = 1;
pub const Z_FEATURE_ENCODING_VALUES: u32 = 1;
pub const Z_FEATURE_TCP_NODELAY: u32 = 1;
pub const Z_FEATURE_LOCAL_SUBSCRIBER: u32 = 0;
pub const Z_FEATURE_SESSION_CHECK: u32 = 1;
pub const Z_FEATURE_BATCHING: u32 = 1;
pub const Z_FEATURE_BATCH_TX_MUTEX: u32 = 0;
pub const Z_FEATURE_BATCH_PEER_MUTEX: u32 = 0;
pub const Z_FEATURE_MATCHING: u32 = 1;
pub const Z_FEATURE_RX_CACHE: u32 = 0;
pub const Z_FEATURE_UNICAST_PEER: u32 = 1;
pub const Z_FEATURE_AUTO_RECONNECT: u32 = 1;
pub const Z_FEATURE_MULTICAST_DECLARATIONS: u32 = 0;
pub const Z_FEATURE_PERIODIC_TASKS: u32 = 0;
pub const Z_CONFIG_MODE_KEY: u32 = 64;
pub const Z_CONFIG_MODE_CLIENT: &[u8; 7] = b"client\0";
pub const Z_CONFIG_MODE_PEER: &[u8; 5] = b"peer\0";
pub const Z_CONFIG_MODE_DEFAULT: &[u8; 7] = b"client\0";
pub const Z_CONFIG_CONNECT_KEY: u32 = 65;
pub const Z_CONFIG_LISTEN_KEY: u32 = 66;
pub const Z_CONFIG_USER_KEY: u32 = 67;
pub const Z_CONFIG_PASSWORD_KEY: u32 = 68;
pub const Z_CONFIG_MULTICAST_SCOUTING_KEY: u32 = 69;
pub const Z_CONFIG_MULTICAST_SCOUTING_DEFAULT: &[u8; 5] = b"true\0";
pub const Z_CONFIG_MULTICAST_LOCATOR_KEY: u32 = 70;
pub const Z_CONFIG_MULTICAST_LOCATOR_DEFAULT: &[u8; 21] = b"udp/224.0.0.224:7446\0";
pub const Z_CONFIG_SCOUTING_TIMEOUT_KEY: u32 = 71;
pub const Z_CONFIG_SCOUTING_TIMEOUT_DEFAULT: &[u8; 5] = b"1000\0";
pub const Z_CONFIG_SCOUTING_WHAT_KEY: u32 = 72;
pub const Z_CONFIG_SCOUTING_WHAT_DEFAULT: &[u8; 2] = b"3\0";
pub const Z_CONFIG_SESSION_ZID_KEY: u32 = 73;
pub const Z_CONFIG_ADD_TIMESTAMP_KEY: u32 = 74;
pub const Z_CONFIG_ADD_TIMESTAMP_DEFAULT: &[u8; 6] = b"false\0";
pub const Z_CONFIG_TLS_ROOT_CA_CERTIFICATE_KEY: u32 = 75;
pub const Z_CONFIG_TLS_ROOT_CA_CERTIFICATE_BASE64_KEY: u32 = 76;
pub const Z_CONFIG_TLS_LISTEN_PRIVATE_KEY_KEY: u32 = 77;
pub const Z_CONFIG_TLS_LISTEN_PRIVATE_KEY_BASE64_KEY: u32 = 78;
pub const Z_CONFIG_TLS_LISTEN_CERTIFICATE_KEY: u32 = 79;
pub const Z_CONFIG_TLS_LISTEN_CERTIFICATE_BASE64_KEY: u32 = 80;
pub const Z_CONFIG_TLS_ENABLE_MTLS_KEY: u32 = 81;
pub const Z_CONFIG_TLS_CONNECT_PRIVATE_KEY_KEY: u32 = 82;
pub const Z_CONFIG_TLS_CONNECT_PRIVATE_KEY_BASE64_KEY: u32 = 83;
pub const Z_CONFIG_TLS_CONNECT_CERTIFICATE_KEY: u32 = 84;
pub const Z_CONFIG_TLS_CONNECT_CERTIFICATE_BASE64_KEY: u32 = 85;
pub const Z_CONFIG_TLS_VERIFY_NAME_ON_CONNECT_KEY: u32 = 86;
pub const Z_ZID_LENGTH: u32 = 16;
pub const Z_PROTO_VERSION: u32 = 9;
pub const Z_TRANSPORT_LEASE_EXPIRE_FACTOR: u32 = 3;
pub const Z_JOIN_INTERVAL: u32 = 2500;
pub const Z_SN_RESOLUTION: u32 = 2;
pub const Z_REQ_RESOLUTION: u32 = 2;
pub const Z_RX_CACHE_SIZE: u32 = 10;
pub const Z_GET_TIMEOUT_DEFAULT: u32 = 10000;
pub const Z_LISTEN_MAX_CONNECTION_NB: u32 = 10;
pub const _Z_ERR_MESSAGE_MASK: u32 = 136;
pub const _Z_ERR_ENTITY_MASK: u32 = 144;
pub const _Z_ERR_TRANSPORT_MASK: u32 = 152;
pub const _Z_ERR_CONFIG_MASK: u32 = 160;
pub const _Z_ERR_SCOUT_MASK: u32 = 168;
pub const _Z_ERR_SYSTEM_MASK: u32 = 176;
pub const _Z_ERR_GENERIC_MASK: u32 = 184;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const CONFIG_SOC_BROWNOUT_RESET_SUPPORTED: &[u8; 15] = b"Not determined\0";
pub const CONFIG_SOC_TWAI_BRP_DIV_SUPPORTED: &[u8; 15] = b"Not determined\0";
pub const CONFIG_SOC_DPORT_WORKAROUND: &[u8; 15] = b"Not determined\0";
pub const CONFIG_SOC_CAPS_ECO_VER_MAX: u32 = 301;
pub const CONFIG_SOC_ADC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MCPWM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDMMC_HOST_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PCNT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PHY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDIO_SLAVE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_EFUSE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_EMAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CCOMP_TIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPSPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TOUCH_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BOD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_FSM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPU_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RNG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LIGHT_SLEEP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEEP_SLEEP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LP_PERIPH_SHARE_INTERRUPT: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DPORT_WORKAROUND_DIS_INTERRUPT_LVL: u32 = 5;
pub const CONFIG_SOC_XTAL_SUPPORT_26M: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_AUTO_DETECT: u32 = 1;
pub const CONFIG_SOC_ADC_RTC_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const CONFIG_SOC_ADC_ATTEN_NUM: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_PATT_LEN_MAX: u32 = 16;
pub const CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 9;
pub const CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_RESULT_BYTES: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_MONITOR_NUM: u32 = 0;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 2;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 20;
pub const CONFIG_SOC_ADC_RTC_MIN_BITWIDTH: u32 = 9;
pub const CONFIG_SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_SHARED_POWER: u32 = 1;
pub const CONFIG_SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_IDCACHE_PER_CORE: u32 = 1;
pub const CONFIG_SOC_CPU_CORES_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_INTR_NUM: u32 = 32;
pub const CONFIG_SOC_CPU_HAS_FPU: u32 = 1;
pub const CONFIG_SOC_HP_CPU_HAS_MULTIPLE_CORES: u32 = 1;
pub const CONFIG_SOC_CPU_BREAKPOINTS_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_WATCHPOINTS_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 64;
pub const CONFIG_SOC_DAC_CHAN_NUM: u32 = 2;
pub const CONFIG_SOC_DAC_RESOLUTION: u32 = 8;
pub const CONFIG_SOC_DAC_DMA_16BIT_ALIGN: u32 = 1;
pub const CONFIG_SOC_GPIO_PORT: u32 = 1;
pub const CONFIG_SOC_GPIO_PIN_COUNT: u32 = 40;
pub const CONFIG_SOC_GPIO_VALID_GPIO_MASK: u64 = 1099511627775;
pub const CONFIG_SOC_GPIO_IN_RANGE_MAX: u32 = 39;
pub const CONFIG_SOC_GPIO_OUT_RANGE_MAX: u32 = 33;
pub const CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 15667178;
pub const CONFIG_SOC_GPIO_CLOCKOUT_BY_IO_MUX: u32 = 1;
pub const CONFIG_SOC_GPIO_CLOCKOUT_CHANNEL_NUM: u32 = 3;
pub const CONFIG_SOC_I2C_NUM: u32 = 2;
pub const CONFIG_SOC_HP_I2C_NUM: u32 = 2;
pub const CONFIG_SOC_I2C_FIFO_LEN: u32 = 32;
pub const CONFIG_SOC_I2C_CMD_REG_NUM: u32 = 16;
pub const CONFIG_SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_I2C_STOP_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_I2S_NUM: u32 = 2;
pub const CONFIG_SOC_I2S_HW_VERSION_1: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_APLL: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const CONFIG_SOC_I2S_PDM_MAX_TX_LINES: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_RX: u32 = 1;
pub const CONFIG_SOC_I2S_PDM_MAX_RX_LINES: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_ADC_DAC: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_ADC: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_DAC: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_LCD_CAMERA: u32 = 1;
pub const CONFIG_SOC_I2S_TRANS_SIZE_ALIGN_WORD: u32 = 1;
pub const CONFIG_SOC_I2S_LCD_I80_VARIANT: u32 = 1;
pub const CONFIG_SOC_LCD_I80_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LCD_I80_BUSES: u32 = 2;
pub const CONFIG_SOC_LCD_I80_BUS_WIDTH: u32 = 24;
pub const CONFIG_SOC_LEDC_HAS_TIMER_SPECIFIC_MUX: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_HS_MODE: u32 = 1;
pub const CONFIG_SOC_LEDC_CHANNEL_NUM: u32 = 8;
pub const CONFIG_SOC_LEDC_TIMER_BIT_WIDTH: u32 = 20;
pub const CONFIG_SOC_MCPWM_GROUPS: u32 = 2;
pub const CONFIG_SOC_MCPWM_TIMERS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER: u32 = 3;
pub const CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MMU_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 3;
pub const CONFIG_SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const CONFIG_SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const CONFIG_SOC_PCNT_GROUPS: u32 = 1;
pub const CONFIG_SOC_PCNT_UNITS_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_RMT_GROUPS: u32 = 1;
pub const CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_RMT_CHANNELS_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 64;
pub const CONFIG_SOC_RMT_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_RMT_CHANNEL_CLK_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_RTCIO_PIN_COUNT: u32 = 18;
pub const CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_GROUPS: u32 = 1;
pub const CONFIG_SOC_SDM_CHANNELS_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_SDM_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_SPI_HD_BOTH_INOUT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_AS_CS_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_NUM: u32 = 3;
pub const CONFIG_SOC_SPI_DMA_CHAN_NUM: u32 = 2;
pub const CONFIG_SOC_SPI_MAX_CS_NUM: u32 = 3;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_APB: u32 = 1;
pub const CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const CONFIG_SOC_SPI_MAX_PRE_DIVIDER: u32 = 8192;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUPS: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 64;
pub const CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 4;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TOUCH_SENSOR_VERSION: u32 = 1;
pub const CONFIG_SOC_TOUCH_SENSOR_NUM: u32 = 10;
pub const CONFIG_SOC_TOUCH_SAMPLER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_BRP_MIN: u32 = 2;
pub const CONFIG_SOC_TWAI_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORT_MULTI_ADDRESS_LAYOUT: u32 = 1;
pub const CONFIG_SOC_UART_NUM: u32 = 3;
pub const CONFIG_SOC_UART_HP_NUM: u32 = 3;
pub const CONFIG_SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_REF_TICK: u32 = 1;
pub const CONFIG_SOC_UART_FIFO_LEN: u32 = 128;
pub const CONFIG_SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const CONFIG_SOC_SPIRAM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_PARALLEL_ENG: u32 = 1;
pub const CONFIG_SOC_SHA_ENDIANNESS_BE: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA384: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512: u32 = 1;
pub const CONFIG_SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const CONFIG_SOC_MPI_OPERATIONS_NUM: u32 = 1;
pub const CONFIG_SOC_RSA_MAX_BIT_LEN: u32 = 4096;
pub const CONFIG_SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_192: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V1: u32 = 1;
pub const CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 32;
pub const CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 21;
pub const CONFIG_SOC_PM_SUPPORT_EXT0_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_FAST_MEM_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_SLOW_MEM_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_MODEM_PD: u32 = 1;
pub const CONFIG_SOC_CONFIGURABLE_VDDSDIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_APLL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_D256_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const CONFIG_SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDMMC_USE_IOMUX: u32 = 1;
pub const CONFIG_SOC_SDMMC_NUM_SLOTS: u32 = 2;
pub const CONFIG_SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW: u32 = 1;
pub const CONFIG_SOC_WIFI_NAN_SUPPORT: u32 = 1;
pub const CONFIG_SOC_BLE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_CLASSIC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLUFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_H2C_ENC_KEY_CTRL_ENH_VSC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_HAS_ADC: u32 = 1;
pub const CONFIG_SOC_PHY_COMBO_MODULE: u32 = 1;
pub const CONFIG_SOC_EMAC_RMII_CLK_OUT_INTERNAL_LOOPBACK: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TOOLCHAIN: &[u8; 4] = b"gcc\0";
pub const CONFIG_IDF_TARGET_ARCH_XTENSA: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH: &[u8; 7] = b"xtensa\0";
pub const CONFIG_IDF_TARGET: &[u8; 6] = b"esp32\0";
pub const CONFIG_IDF_INIT_VERSION: &[u8; 6] = b"5.3.0\0";
pub const CONFIG_IDF_TARGET_ESP32: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 0;
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_BOOTLOADER_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_BOOTLOADER_PROJECT_VER: u32 = 1;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 4096;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_SECURE_BOOT_V1_SUPPORTED: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 9;
pub const CONFIG_ESP_ROM_HAS_CRC_LE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CRC_BE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_MZ_CRC32: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_JPEG_DECODE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_UART_BUF_SWITCH: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_32BIT_TIME: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SW_FLOAT: u32 = 1;
pub const CONFIG_ESP_ROM_USB_OTG_NUM: i32 = -1;
pub const CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM: i32 = -1;
pub const CONFIG_ESP_ROM_SUPPORT_DEEP_SLEEP_WAKEUP_STUB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &[u8; 4] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &[u8; 4] = b"40m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &[u8; 4] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &[u8; 14] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &[u8; 11] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &[u8; 15] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &[u8; 25] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_DEBUG: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_COMPILER_HIDE_PATHS_MACROS: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_NAME: &[u8; 4] = b"gcc\0";
pub const CONFIG_COMPILER_ORPHAN_SECTIONS_PLACE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_APPTRACE_DEST_UART_NONE: u32 = 1;
pub const CONFIG_APPTRACE_UART_TASK_PRIO: u32 = 1;
pub const CONFIG_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_BT_ALARM_MAX_NUM: u32 = 50;
pub const CONFIG_TWAI_ERRATA_FIX_BUS_OFF_REC: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_TX_INTR_LOST: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_RX_FRAME_INVALID: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_RX_FIFO_CORRUPT: u32 = 1;
pub const CONFIG_TWAI_ERRATA_FIX_LISTEN_ONLY_DOM: u32 = 1;
pub const CONFIG_ADC_DISABLE_DAC: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_LUT_ENABLE: u32 = 1;
pub const CONFIG_EFUSE_CODE_SCHEME_COMPAT_3_4: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 192;
pub const CONFIG_ESP_TLS_USING_MBEDTLS: u32 = 1;
pub const CONFIG_ADC_CALI_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_ADC_CALI_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_ADC_CALI_LUT_ENABLE: u32 = 1;
pub const CONFIG_ADC_DISABLE_DAC_OUTPUT: u32 = 1;
pub const CONFIG_ESP_COEX_ENABLED: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_DAC_DMA_AUTO_16BIT_ALIGN: u32 = 1;
pub const CONFIG_GPTIMER_ISR_HANDLER_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_ETH_ENABLED: u32 = 1;
pub const CONFIG_ETH_USE_ESP32_EMAC: u32 = 1;
pub const CONFIG_ETH_PHY_INTERFACE_RMII: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_INPUT: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_IN_GPIO: u32 = 0;
pub const CONFIG_ETH_DMA_BUFFER_SIZE: u32 = 512;
pub const CONFIG_ETH_DMA_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_DMA_TX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_ENABLED: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_SUPPORT_TASKS: u32 = 1;
pub const CONFIG_ESP_GDBSTUB_MAX_TASKS: u32 = 32;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_ESP32_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32_REV_MIN: u32 = 0;
pub const CONFIG_ESP32_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP32_REV_MAX_FULL: u32 = 399;
pub const CONFIG_ESP_REV_MAX_FULL: u32 = 399;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_BT: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_RTC_BUS_ISO_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY: u32 = 2000;
pub const CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS: u32 = 1;
pub const CONFIG_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP_SPI_BUS_LOCK_ISR_FUNCS_IN_IRAM: u32 = 1;
pub const CONFIG_LCD_PANEL_IO_FORMAT_BUF_SIZE: u32 = 32;
pub const CONFIG_ESP_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_ESP_NETIF_TCPIP_LWIP: u32 = 1;
pub const CONFIG_ESP_NETIF_USES_TCPIP_WITH_BSD_API: u32 = 1;
pub const CONFIG_ESP_PHY_ENABLED: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP_PHY_RF_CAL_PARTIAL: u32 = 1;
pub const CONFIG_ESP_PHY_CALIBRATION_MODE: u32 = 0;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS: u32 = 0;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_ROM_SERIAL_PORT_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_EN: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_INIT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_ESP_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_ESP_SYSTEM_BROWNOUT_INTR: u32 = 1;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_IPC_USES_CALLERS_PRIORITY: u32 = 1;
pub const CONFIG_ESP_IPC_ISR_ENABLE: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_RTC_TIMER: u32 = 1;
pub const CONFIG_ESP_TIME_FUNCS_USE_ESP_TIMER: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_TIMER_INTERRUPT_LEVEL: u32 = 1;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_TIMER_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_ISR_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_TIMER_IMPL_TG0_LAC: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_STATIC_RX_MGMT_BUFFER: u32 = 1;
pub const CONFIG_ESP_WIFI_DYNAMIC_RX_MGMT_BUF: u32 = 0;
pub const CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM_DEF: u32 = 5;
pub const CONFIG_ESP_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLE_WPA3_SAE: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLE_SAE_PK: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_SAE_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_ENABLE_WPA3_OWE_STA: u32 = 1;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_MIN_ACTIVE_TIME: u32 = 50;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_MAX_ACTIVE_TIME: u32 = 10;
pub const CONFIG_ESP_WIFI_SLP_DEFAULT_WAIT_BROADCAST_DATA_TIME: u32 = 15;
pub const CONFIG_ESP_WIFI_STA_DISCONNECTED_PM_ENABLE: u32 = 1;
pub const CONFIG_ESP_WIFI_GMAC_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_SOFTAP_SUPPORT: u32 = 1;
pub const CONFIG_ESP_WIFI_ESPNOW_MAX_ENCRYPT_NUM: u32 = 7;
pub const CONFIG_ESP_WIFI_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_ESP_WIFI_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_ESP_WIFI_ENTERPRISE_SUPPORT: u32 = 1;
pub const CONFIG_ESP_COREDUMP_ENABLE_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_VOLUME_COUNT: u32 = 2;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_SECTOR_4096: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FATFS_VFS_FSTAT_BLKSIZE: u32 = 0;
pub const CONFIG_FATFS_LINK_LOCK: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME: &[u8; 8] = b"Tmr Svc\0";
pub const CONFIG_FREERTOS_TIMER_TASK_NO_AFFINITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_CORE_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER: u32 = 1;
pub const CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_TICK_SUPPORT_CORETIMER: u32 = 1;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_FREERTOS_SYSTICK_USES_CCOUNT: u32 = 1;
pub const CONFIG_FREERTOS_PORT: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT: u32 = 1;
pub const CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH: u32 = 1;
pub const CONFIG_FREERTOS_NUMBER_OF_CORES: u32 = 2;
pub const CONFIG_HAL_ASSERTION_EQUALS_SYSTEM: u32 = 1;
pub const CONFIG_HAL_DEFAULT_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_HAL_SPI_MASTER_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_HAL_SPI_SLAVE_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT: u32 = 1;
pub const CONFIG_LOG_MAXIMUM_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_LWIP_ENABLE: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &[u8; 10] = b"espressif\0";
pub const CONFIG_LWIP_TCPIP_TASK_PRIO: u32 = 18;
pub const CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 1;
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_ND6: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_IP_DEFAULT_TTL: u32 = 64;
pub const CONFIG_LWIP_IP4_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP6_FRAG: u32 = 1;
pub const CONFIG_LWIP_IP_REASS_MAX_PBUFS: u32 = 10;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_ESP_MLDV6_REPORT: u32 = 1;
pub const CONFIG_LWIP_MLDV6_TMR_INTERVAL: u32 = 40;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCP_DISABLE_VENDOR_CLASS_ID: u32 = 1;
pub const CONFIG_LWIP_DHCP_OPTIONS_LEN: u32 = 68;
pub const CONFIG_LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const CONFIG_LWIP_DHCP_COARSE_TIMER_SECS: u32 = 1;
pub const CONFIG_LWIP_DHCPS: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_DHCPS_STATIC_ENTRIES: u32 = 1;
pub const CONFIG_LWIP_IPV4: u32 = 1;
pub const CONFIG_LWIP_IPV6: u32 = 1;
pub const CONFIG_LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_HIGH_SPEED_RETRANSMISSION: u32 = 1;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1440;
pub const CONFIG_LWIP_TCP_TMR_INTERVAL: u32 = 250;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_FIN_WAIT_TIMEOUT: u32 = 20000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_ACCEPTMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OOSEQ_TIMEOUT: u32 = 6;
pub const CONFIG_LWIP_TCP_OOSEQ_MAX_PBUFS: u32 = 4;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_TCP_RTO_TIME: u32 = 1500;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_IPV6_MEMP_NUM_ND6_QUEUE: u32 = 3;
pub const CONFIG_LWIP_IPV6_ND6_NUM_NEIGHBORS: u32 = 5;
pub const CONFIG_LWIP_ICMP: u32 = 1;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_SNTP_MAX_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_LWIP_SNTP_STARTUP_DELAY: u32 = 1;
pub const CONFIG_LWIP_SNTP_MAXIMUM_STARTUP_DELAY: u32 = 5000;
pub const CONFIG_LWIP_DNS_MAX_SERVERS: u32 = 3;
pub const CONFIG_LWIP_BRIDGEIF_MAX_PORTS: u32 = 7;
pub const CONFIG_LWIP_ESP_LWIP_ASSERT: u32 = 1;
pub const CONFIG_LWIP_HOOK_TCP_ISN_DEFAULT: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_ROUTE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_ND6_GET_GW_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_SELECT_SRC_ADDR_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_NETCONN_EXT_RESOLVE_NONE: u32 = 1;
pub const CONFIG_LWIP_HOOK_IP6_INPUT_NONE: u32 = 1;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_ASYMMETRIC_CONTENT_LEN: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 4096;
pub const CONFIG_MBEDTLS_SSL_KEEP_PEER_CERTIFICATE: u32 = 1;
pub const CONFIG_MBEDTLS_PKCS7_C: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_DEFAULT_FULL: u32 = 1;
pub const CONFIG_MBEDTLS_CERTIFICATE_BUNDLE_MAX_CERTS: u32 = 200;
pub const CONFIG_MBEDTLS_CMAC_C: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_SUPPORT_NON_AES_CIPHER: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_MPI: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_SHA: u32 = 1;
pub const CONFIG_MBEDTLS_ROM_MD5: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_DETERMINISTIC: u32 = 1;
pub const CONFIG_MBEDTLS_SHA512_C: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const CONFIG_MBEDTLS_ERROR_STRINGS: u32 = 1;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_OPENTHREAD_NETWORK_NAME: &[u8; 15] = b"OpenThread-ESP\0";
pub const CONFIG_OPENTHREAD_MESH_LOCAL_PREFIX: &[u8; 19] = b"fd00:db8:a0:0::/64\0";
pub const CONFIG_OPENTHREAD_NETWORK_CHANNEL: u32 = 15;
pub const CONFIG_OPENTHREAD_NETWORK_PANID: u32 = 4660;
pub const CONFIG_OPENTHREAD_NETWORK_EXTPANID: &[u8; 17] = b"dead00beef00cafe\0";
pub const CONFIG_OPENTHREAD_NETWORK_MASTERKEY: &[u8; 33] = b"00112233445566778899aabbccddeeff\0";
pub const CONFIG_OPENTHREAD_NETWORK_PSKC: &[u8; 33] = b"104810e2315100afd6bc9215a6bfac53\0";
pub const CONFIG_OPENTHREAD_XTAL_ACCURACY: u32 = 130;
pub const CONFIG_OPENTHREAD_RX_ON_WHEN_IDLE: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_0: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_1: u32 = 1;
pub const CONFIG_ESP_PROTOCOMM_SUPPORT_SECURITY_VERSION_2: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_DEFAULT_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8] = b"pthread\0";
pub const CONFIG_MMU_PAGE_SIZE_64KB: u32 = 1;
pub const CONFIG_MMU_PAGE_MODE: &[u8; 5] = b"64KB\0";
pub const CONFIG_MMU_PAGE_SIZE: u32 = 65536;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC: u32 = 1;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET: u32 = 1;
pub const CONFIG_SPI_FLASH_SUSPEND_TSUS_VAL_US: u32 = 50;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_GD_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_ISSI_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_MXIC_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_WINBOND_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_WS_TRANSPORT: u32 = 1;
pub const CONFIG_WS_BUFFER_SIZE: u32 = 1024;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPORT_IO: u32 = 1;
pub const CONFIG_VFS_SUPPORT_DIR: u32 = 1;
pub const CONFIG_VFS_SUPPORT_SELECT: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_VFS_MAX_COUNT: u32 = 8;
pub const CONFIG_VFS_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WIFI_PROV_AUTOSTOP_TIMEOUT: u32 = 30;
pub const CONFIG_WIFI_PROV_STA_ALL_CHANNEL_SCAN: u32 = 1;
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_DEFAULT: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_CONSOLE_UART: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP32_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_ESP32_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &[u8; 8] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32_RTC_CLOCK_SOURCE_INTERNAL_RC: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_ENABLE_WPA3_OWE_STA: u32 = 1;
pub const CONFIG_ESP32_WIFI_ENABLE_WPA3_SAE: u32 = 1;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_RX_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP32_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_ESP_SLEEP_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_FOUR_UNIVERSAL_MAC_ADDRESS: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_GDBSTUB_MAX_TASKS: u32 = 32;
pub const CONFIG_GDBSTUB_SUPPORT_TASKS: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_NUMBER_OF_UNIVERSAL_MAC_ADDRESS: u32 = 4;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1440;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5760;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 12;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5760;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_WPA_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_WPA_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_NOT_FINISHED: u32 = 268;
pub const ESP_ERR_NOT_ALLOWED: u32 = 269;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const ESP_ERR_HW_CRYPTO_BASE: u32 = 49152;
pub const ESP_ERR_MEMPROT_BASE: u32 = 53248;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_UNUSED_INTR_SOURCE: i32 = -99;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const SOC_CAPS_ECO_VER: u32 = 0;
pub const SOC_CAPS_ECO_VER_MAX: u32 = 301;
pub const SOC_ADC_SUPPORTED: u32 = 1;
pub const SOC_DAC_SUPPORTED: u32 = 1;
pub const SOC_UART_SUPPORTED: u32 = 1;
pub const SOC_MCPWM_SUPPORTED: u32 = 1;
pub const SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const SOC_SDMMC_HOST_SUPPORTED: u32 = 1;
pub const SOC_BT_SUPPORTED: u32 = 1;
pub const SOC_PCNT_SUPPORTED: u32 = 1;
pub const SOC_PHY_SUPPORTED: u32 = 1;
pub const SOC_WIFI_SUPPORTED: u32 = 1;
pub const SOC_SDIO_SLAVE_SUPPORTED: u32 = 1;
pub const SOC_TWAI_SUPPORTED: u32 = 1;
pub const SOC_EFUSE_SUPPORTED: u32 = 1;
pub const SOC_EMAC_SUPPORTED: u32 = 1;
pub const SOC_ULP_SUPPORTED: u32 = 1;
pub const SOC_CCOMP_TIMER_SUPPORTED: u32 = 1;
pub const SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const SOC_RTC_SLOW_MEM_SUPPORTED: u32 = 1;
pub const SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const SOC_I2S_SUPPORTED: u32 = 1;
pub const SOC_RMT_SUPPORTED: u32 = 1;
pub const SOC_SDM_SUPPORTED: u32 = 1;
pub const SOC_GPSPI_SUPPORTED: u32 = 1;
pub const SOC_LEDC_SUPPORTED: u32 = 1;
pub const SOC_I2C_SUPPORTED: u32 = 1;
pub const SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const SOC_AES_SUPPORTED: u32 = 1;
pub const SOC_MPI_SUPPORTED: u32 = 1;
pub const SOC_SHA_SUPPORTED: u32 = 1;
pub const SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const SOC_TOUCH_SENSOR_SUPPORTED: u32 = 1;
pub const SOC_BOD_SUPPORTED: u32 = 1;
pub const SOC_ULP_FSM_SUPPORTED: u32 = 1;
pub const SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const SOC_MPU_SUPPORTED: u32 = 1;
pub const SOC_WDT_SUPPORTED: u32 = 1;
pub const SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const SOC_RNG_SUPPORTED: u32 = 1;
pub const SOC_LIGHT_SLEEP_SUPPORTED: u32 = 1;
pub const SOC_DEEP_SLEEP_SUPPORTED: u32 = 1;
pub const SOC_LP_PERIPH_SHARE_INTERRUPT: u32 = 1;
pub const SOC_PM_SUPPORTED: u32 = 1;
pub const SOC_DPORT_WORKAROUND: u32 = 1;
pub const SOC_DPORT_WORKAROUND_DIS_INTERRUPT_LVL: u32 = 5;
pub const SOC_XTAL_SUPPORT_26M: u32 = 1;
pub const SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const SOC_XTAL_SUPPORT_AUTO_DETECT: u32 = 1;
pub const SOC_ADC_RTC_CTRL_SUPPORTED: u32 = 1;
pub const SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const SOC_ADC_PERIPH_NUM: u32 = 2;
pub const SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const SOC_ADC_ATTEN_NUM: u32 = 4;
pub const SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 2;
pub const SOC_ADC_PATT_LEN_MAX: u32 = 16;
pub const SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 9;
pub const SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_DIGI_RESULT_BYTES: u32 = 2;
pub const SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const SOC_ADC_DIGI_MONITOR_NUM: u32 = 0;
pub const SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 2000000;
pub const SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 20000;
pub const SOC_ADC_RTC_MIN_BITWIDTH: u32 = 9;
pub const SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const SOC_ADC_SHARED_POWER: u32 = 1;
pub const SOC_SHARED_IDCACHE_SUPPORTED: u32 = 1;
pub const SOC_IDCACHE_PER_CORE: u32 = 1;
pub const SOC_CPU_CORES_NUM: u32 = 2;
pub const SOC_CPU_INTR_NUM: u32 = 32;
pub const SOC_CPU_HAS_FPU: u32 = 1;
pub const SOC_HP_CPU_HAS_MULTIPLE_CORES: u32 = 1;
pub const SOC_CPU_BREAKPOINTS_NUM: u32 = 2;
pub const SOC_CPU_WATCHPOINTS_NUM: u32 = 2;
pub const SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 64;
pub const SOC_DAC_CHAN_NUM: u32 = 2;
pub const SOC_DAC_RESOLUTION: u32 = 8;
pub const SOC_DAC_DMA_16BIT_ALIGN: u32 = 1;
pub const SOC_GPIO_PORT: u32 = 1;
pub const SOC_GPIO_PIN_COUNT: u32 = 40;
pub const SOC_GPIO_IN_RANGE_MAX: u32 = 39;
pub const SOC_GPIO_OUT_RANGE_MAX: u32 = 33;
pub const SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u32 = 15667178;
pub const SOC_GPIO_CLOCKOUT_BY_IO_MUX: u32 = 1;
pub const SOC_GPIO_CLOCKOUT_CHANNEL_NUM: u32 = 3;
pub const SOC_GPIO_SUPPORT_HOLD_IO_IN_DSLP: u32 = 1;
pub const SOC_I2C_NUM: u32 = 2;
pub const SOC_HP_I2C_NUM: u32 = 2;
pub const SOC_I2C_FIFO_LEN: u32 = 32;
pub const SOC_I2C_CMD_REG_NUM: u32 = 16;
pub const SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const SOC_I2C_SUPPORT_APB: u32 = 1;
pub const SOC_I2C_SUPPORT_10BIT_ADDR: u32 = 1;
pub const SOC_I2C_STOP_INDEPENDENT: u32 = 1;
pub const SOC_I2S_NUM: u32 = 2;
pub const SOC_I2S_HW_VERSION_1: u32 = 1;
pub const SOC_I2S_SUPPORTS_APLL: u32 = 1;
pub const SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const SOC_I2S_SUPPORTS_PCM2PDM: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM_RX: u32 = 1;
pub const SOC_I2S_SUPPORTS_PDM2PCM: u32 = 1;
pub const SOC_I2S_PDM_MAX_TX_LINES: u32 = 1;
pub const SOC_I2S_PDM_MAX_RX_LINES: u32 = 1;
pub const SOC_I2S_SUPPORTS_ADC_DAC: u32 = 1;
pub const SOC_I2S_SUPPORTS_ADC: u32 = 1;
pub const SOC_I2S_SUPPORTS_DAC: u32 = 1;
pub const SOC_I2S_SUPPORTS_LCD_CAMERA: u32 = 1;
pub const SOC_I2S_MAX_DATA_WIDTH: u32 = 24;
pub const SOC_I2S_TRANS_SIZE_ALIGN_WORD: u32 = 1;
pub const SOC_I2S_LCD_I80_VARIANT: u32 = 1;
pub const SOC_LCD_I80_SUPPORTED: u32 = 1;
pub const SOC_LCD_I80_BUSES: u32 = 2;
pub const SOC_LCD_I80_BUS_WIDTH: u32 = 24;
pub const SOC_LEDC_HAS_TIMER_SPECIFIC_MUX: u32 = 1;
pub const SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const SOC_LEDC_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_LEDC_SUPPORT_HS_MODE: u32 = 1;
pub const SOC_LEDC_TIMER_NUM: u32 = 4;
pub const SOC_LEDC_CHANNEL_NUM: u32 = 8;
pub const SOC_LEDC_TIMER_BIT_WIDTH: u32 = 20;
pub const SOC_MCPWM_GROUPS: u32 = 2;
pub const SOC_MCPWM_TIMERS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_OPERATORS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_COMPARATORS_PER_OPERATOR: u32 = 2;
pub const SOC_MCPWM_GENERATORS_PER_OPERATOR: u32 = 2;
pub const SOC_MCPWM_TRIGGERS_PER_OPERATOR: u32 = 2;
pub const SOC_MCPWM_GPIO_FAULTS_PER_GROUP: u32 = 3;
pub const SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP: u32 = 1;
pub const SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER: u32 = 3;
pub const SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP: u32 = 3;
pub const SOC_MMU_PERIPH_NUM: u32 = 2;
pub const SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 3;
pub const SOC_MPU_CONFIGURABLE_REGIONS_SUPPORTED: u32 = 0;
pub const SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const SOC_MPU_REGION_RO_SUPPORTED: u32 = 0;
pub const SOC_MPU_REGION_WO_SUPPORTED: u32 = 0;
pub const SOC_PCNT_GROUPS: u32 = 1;
pub const SOC_PCNT_UNITS_PER_GROUP: u32 = 8;
pub const SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const SOC_RMT_GROUPS: u32 = 1;
pub const SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 8;
pub const SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 8;
pub const SOC_RMT_CHANNELS_PER_GROUP: u32 = 8;
pub const SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 64;
pub const SOC_RMT_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_RMT_SUPPORT_APB: u32 = 1;
pub const SOC_RMT_CHANNEL_CLK_INDEPENDENT: u32 = 1;
pub const SOC_RTCIO_PIN_COUNT: u32 = 18;
pub const SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const SOC_SDM_GROUPS: u32 = 1;
pub const SOC_SDM_CHANNELS_PER_GROUP: u32 = 8;
pub const SOC_SDM_CLK_SUPPORT_APB: u32 = 1;
pub const SOC_SPI_HD_BOTH_INOUT_SUPPORTED: u32 = 1;
pub const SOC_SPI_AS_CS_SUPPORTED: u32 = 1;
pub const SOC_SPI_PERIPH_NUM: u32 = 3;
pub const SOC_SPI_DMA_CHAN_NUM: u32 = 2;
pub const SOC_SPI_MAX_CS_NUM: u32 = 3;
pub const SOC_SPI_SUPPORT_CLK_APB: u32 = 1;
pub const SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const SOC_SPI_MAX_PRE_DIVIDER: u32 = 8192;
pub const SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_26M_SUPPORTED: u32 = 1;
pub const SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const SOC_TIMER_GROUPS: u32 = 2;
pub const SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 2;
pub const SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 64;
pub const SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 4;
pub const SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const SOC_LP_TIMER_BIT_WIDTH_LO: u32 = 32;
pub const SOC_LP_TIMER_BIT_WIDTH_HI: u32 = 16;
pub const SOC_TOUCH_SENSOR_VERSION: u32 = 1;
pub const SOC_TOUCH_SENSOR_NUM: u32 = 10;
pub const SOC_TOUCH_MIN_CHAN_ID: u32 = 0;
pub const SOC_TOUCH_MAX_CHAN_ID: u32 = 9;
pub const SOC_TOUCH_SUPPORT_SLEEP_WAKEUP: u32 = 1;
pub const SOC_TOUCH_SAMPLE_CFG_NUM: u32 = 1;
pub const SOC_TWAI_CONTROLLER_NUM: u32 = 1;
pub const SOC_TWAI_MASK_FILTER_NUM: u32 = 1;
pub const SOC_TWAI_BRP_MIN: u32 = 2;
pub const SOC_TWAI_BRP_MAX: u32 = 128;
pub const SOC_TWAI_CLK_SUPPORT_APB: u32 = 1;
pub const SOC_TWAI_SUPPORT_MULTI_ADDRESS_LAYOUT: u32 = 1;
pub const SOC_UART_NUM: u32 = 3;
pub const SOC_UART_HP_NUM: u32 = 3;
pub const SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const SOC_UART_SUPPORT_REF_TICK: u32 = 1;
pub const SOC_UART_FIFO_LEN: u32 = 128;
pub const SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const SOC_UART_WAKEUP_SUPPORT_ACTIVE_THRESH_MODE: u32 = 1;
pub const SOC_SPIRAM_SUPPORTED: u32 = 1;
pub const SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const SOC_SHA_SUPPORT_PARALLEL_ENG: u32 = 1;
pub const SOC_SHA_ENDIANNESS_BE: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA384: u32 = 1;
pub const SOC_SHA_SUPPORT_SHA512: u32 = 1;
pub const SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const SOC_MPI_OPERATIONS_NUM: u32 = 1;
pub const SOC_RSA_MAX_BIT_LEN: u32 = 4096;
pub const SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const SOC_AES_SUPPORT_AES_192: u32 = 1;
pub const SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const SOC_SECURE_BOOT_V1: u32 = 1;
pub const SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 1;
pub const SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 32;
pub const SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 84;
pub const SOC_PM_SUPPORT_EXT0_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_EXT_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_FAST_MEM_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RTC_SLOW_MEM_PD: u32 = 1;
pub const SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const SOC_PM_SUPPORT_MODEM_PD: u32 = 1;
pub const SOC_CONFIGURABLE_VDDSDIO_SUPPORTED: u32 = 1;
pub const SOC_PM_MODEM_PD_BY_SW: u32 = 1;
pub const SOC_CLK_APLL_SUPPORTED: u32 = 1;
pub const SOC_CLK_RC_FAST_D256_SUPPORTED: u32 = 1;
pub const SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256: u32 = 1;
pub const SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const SOC_CLK_LP_FAST_SUPPORT_XTAL_D4: u32 = 1;
pub const SOC_SDMMC_USE_IOMUX: u32 = 1;
pub const SOC_SDMMC_NUM_SLOTS: u32 = 2;
pub const SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW: u32 = 1;
pub const SOC_WIFI_NAN_SUPPORT: u32 = 1;
pub const SOC_BLE_SUPPORTED: u32 = 1;
pub const SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const SOC_BT_CLASSIC_SUPPORTED: u32 = 1;
pub const SOC_BLE_DEVICE_PRIVACY_SUPPORTED: u32 = 0;
pub const SOC_BLUFI_SUPPORTED: u32 = 1;
pub const SOC_BT_H2C_ENC_KEY_CTRL_ENH_VSC_SUPPORTED: u32 = 1;
pub const SOC_BLE_MULTI_CONN_OPTIMIZATION: u32 = 1;
pub const SOC_ULP_HAS_ADC: u32 = 1;
pub const SOC_PHY_COMBO_MODULE: u32 = 1;
pub const SOC_EMAC_RMII_CLK_OUT_INTERNAL_LOOPBACK: u32 = 1;
pub const STACK_OVERHEAD_CHECKER: u32 = 0;
pub const STACK_OVERHEAD_OPTIMIZATION: u32 = 0;
pub const STACK_OVERHEAD_APPTRACE: u32 = 0;
pub const STACK_OVERHEAD_WATCHPOINT: u32 = 0;
pub const configSTACK_OVERHEAD_TOTAL: u32 = 0;
pub const XTHAL_RELEASE_MAJOR: u32 = 12000;
pub const XTHAL_RELEASE_MINOR: u32 = 9;
pub const XTHAL_RELEASE_NAME: &[u8; 7] = b"12.0.9\0";
pub const XTHAL_REL_12: u32 = 1;
pub const XTHAL_REL_12_0: u32 = 1;
pub const XTHAL_REL_12_0_9: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 12000;
pub const XTHAL_MINOR_REV: u32 = 9;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 4294901760;
pub const XTHAL_DCACHE_PREFETCH_L1_OFF: u32 = 2415919104;
pub const XTHAL_DCACHE_PREFETCH_L1: u32 = 2415923200;
pub const XTHAL_ICACHE_PREFETCH_L1_OFF: u32 = 2684354560;
pub const XTHAL_ICACHE_PREFETCH_L1: u32 = 2684362752;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_INTTYPE_PROFILING: u32 = 7;
pub const XTHAL_INTTYPE_IDMA_DONE: u32 = 8;
pub const XTHAL_INTTYPE_IDMA_ERR: u32 = 9;
pub const XTHAL_INTTYPE_GS_ERR: u32 = 10;
pub const XTHAL_INTTYPE_SG_ERR: u32 = 10;
pub const XTHAL_MAX_INTTYPES: u32 = 11;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_PAM_BYPASS: u32 = 0;
pub const XTHAL_PAM_BYPASS_BUF: u32 = 16;
pub const XTHAL_PAM_CACHED_NOALLOC: u32 = 48;
pub const XTHAL_PAM_WRITETHRU: u32 = 176;
pub const XTHAL_PAM_WRITEBACK_NOALLOC: u32 = 240;
pub const XTHAL_PAM_WRITEBACK: u32 = 496;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XTHAL_SUCCESS: u32 = 0;
pub const XTHAL_NO_REGIONS_COVERED: i32 = -1;
pub const XTHAL_INEXACT: i32 = -2;
pub const XTHAL_INVALID_ADDRESS: i32 = -3;
pub const XTHAL_UNSUPPORTED: i32 = -4;
pub const XTHAL_ADDRESS_MISALIGNED: i32 = -5;
pub const XTHAL_NO_MAPPING: i32 = -6;
pub const XTHAL_BAD_ACCESS_RIGHTS: i32 = -7;
pub const XTHAL_BAD_MEMORY_TYPE: i32 = -8;
pub const XTHAL_MAP_NOT_ALIGNED: i32 = -9;
pub const XTHAL_OUT_OF_ENTRIES: i32 = -10;
pub const XTHAL_OUT_OF_ORDER_MAP: i32 = -11;
pub const XTHAL_INVALID: i32 = -12;
pub const XTHAL_ZERO_SIZED_REGION: i32 = -13;
pub const XTHAL_INVALID_ADDRESS_RANGE: i32 = -14;
pub const XCHAL_SUCCESS: u32 = 0;
pub const XCHAL_ADDRESS_MISALIGNED: i32 = -5;
pub const XCHAL_INEXACT: i32 = -2;
pub const XCHAL_INVALID_ADDRESS: i32 = -3;
pub const XCHAL_UNSUPPORTED_ON_THIS_ARCH: i32 = -4;
pub const XCHAL_NO_PAGES_MAPPED: i32 = -1;
pub const XTHAL_AR_NONE: u32 = 0;
pub const XTHAL_AR_R: u32 = 4;
pub const XTHAL_AR_RX: u32 = 5;
pub const XTHAL_AR_RW: u32 = 6;
pub const XTHAL_AR_RWX: u32 = 7;
pub const XTHAL_AR_Ww: u32 = 8;
pub const XTHAL_AR_RWrwx: u32 = 9;
pub const XTHAL_AR_RWr: u32 = 10;
pub const XTHAL_AR_RWXrx: u32 = 11;
pub const XTHAL_AR_Rr: u32 = 12;
pub const XTHAL_AR_RXrx: u32 = 13;
pub const XTHAL_AR_RWrw: u32 = 14;
pub const XTHAL_AR_RWXrwx: u32 = 15;
pub const XTHAL_AR_WIDTH: u32 = 4;
pub const XTHAL_MPU_USE_EXISTING_ACCESS_RIGHTS: u32 = 8192;
pub const XTHAL_MPU_USE_EXISTING_MEMORY_TYPE: u32 = 16384;
pub const XTHAL_MEM_DEVICE: u32 = 32768;
pub const XTHAL_MEM_NON_CACHEABLE: u32 = 589824;
pub const XTHAL_MEM_WRITETHRU_NOALLOC: u32 = 524288;
pub const XTHAL_MEM_WRITETHRU: u32 = 262144;
pub const XTHAL_MEM_WRITETHRU_WRITEALLOC: u32 = 393216;
pub const XTHAL_MEM_WRITEBACK_NOALLOC: u32 = 327680;
pub const XTHAL_MEM_WRITEBACK: u32 = 458752;
pub const XTHAL_MEM_INTERRUPTIBLE: u32 = 134217728;
pub const XTHAL_MEM_BUFFERABLE: u32 = 16777216;
pub const XTHAL_MEM_NON_SHAREABLE: u32 = 0;
pub const XTHAL_MEM_INNER_SHAREABLE: u32 = 33554432;
pub const XTHAL_MEM_OUTER_SHAREABLE: u32 = 67108864;
pub const XTHAL_MEM_SYSTEM_SHAREABLE: u32 = 100663296;
pub const _XTHAL_SYSTEM_CACHE_BITS: u32 = 983040;
pub const _XTHAL_LOCAL_CACHE_BITS: u32 = 15728640;
pub const _XTHAL_MEM_SYSTEM_RWC_MASK: u32 = 458752;
pub const _XTHAL_MEM_LOCAL_RWC_MASK: u32 = 7340032;
pub const _XTHAL_SHIFT_RWC: u32 = 16;
pub const XTHAL_MEM_NON_CACHED: u32 = 589824;
pub const XTHAL_MEM_NON_SHARED: u32 = 0;
pub const XTHAL_MEM_INNER_SHARED: u32 = 33554432;
pub const XTHAL_MEM_OUTER_SHARED: u32 = 67108864;
pub const XTHAL_MEM_SYSTEM_SHARED: u32 = 100663296;
pub const XTHAL_MEM_SW_SHAREABLE: u32 = 0;
pub const XTENSA_HWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_HWCIDSCHEME_T1020_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_0: u32 = 2;
pub const XTENSA_HWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_HWCIDSCHEME_T1020_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_1: u32 = 3;
pub const XTENSA_HWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2: u32 = 4;
pub const XTENSA_HWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2B: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2B: u32 = 5;
pub const XTENSA_HWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_HWCIDSCHEME_T1020_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_3: u32 = 6;
pub const XTENSA_HWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_HWCIDSCHEME_T1020_4: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_4: u32 = 7;
pub const XTENSA_HWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_HWCIDSCHEME_T1030_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_0: u32 = 9;
pub const XTENSA_HWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_HWCIDSCHEME_T1030_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_1: u32 = 10;
pub const XTENSA_HWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_HWCIDSCHEME_T1030_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_2: u32 = 11;
pub const XTENSA_HWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_HWCIDSCHEME_T1030_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_3: u32 = 12;
pub const XTENSA_HWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_HWCIDSCHEME_T1040_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_0: u32 = 15;
pub const XTENSA_HWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_1: u32 = 32;
pub const XTENSA_HWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1P: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_1P: u32 = 16;
pub const XTENSA_HWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_HWCIDSCHEME_T1040_2: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_2: u32 = 33;
pub const XTENSA_HWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_HWCIDSCHEME_T1040_3: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_3: u32 = 34;
pub const XTENSA_HWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_HWCIDSCHEME_T1050_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_0: u32 = 1;
pub const XTENSA_HWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_HWCIDSCHEME_T1050_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_1: u32 = 2;
pub const XTENSA_HWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_HWCIDSCHEME_T1050_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_2: u32 = 4;
pub const XTENSA_HWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_HWCIDSCHEME_T1050_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_3: u32 = 6;
pub const XTENSA_HWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_HWCIDSCHEME_T1050_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_4: u32 = 7;
pub const XTENSA_HWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_HWCIDSCHEME_T1050_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_5: u32 = 8;
pub const XTENSA_HWVERSION_RA_2004_1: u32 = 210000;
pub const XTENSA_HWCIDSCHEME_RA_2004_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2004_1: u32 = 3;
pub const XTENSA_HWVERSION_RA_2005_1: u32 = 210001;
pub const XTENSA_HWCIDSCHEME_RA_2005_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_1: u32 = 20;
pub const XTENSA_HWVERSION_RA_2005_2: u32 = 210002;
pub const XTENSA_HWCIDSCHEME_RA_2005_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_2: u32 = 21;
pub const XTENSA_HWVERSION_RA_2005_3: u32 = 210003;
pub const XTENSA_HWCIDSCHEME_RA_2005_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_3: u32 = 22;
pub const XTENSA_HWVERSION_RA_2006_4: u32 = 210004;
pub const XTENSA_HWCIDSCHEME_RA_2006_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_4: u32 = 23;
pub const XTENSA_HWVERSION_RA_2006_5: u32 = 210005;
pub const XTENSA_HWCIDSCHEME_RA_2006_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_5: u32 = 24;
pub const XTENSA_HWVERSION_RA_2006_6: u32 = 210006;
pub const XTENSA_HWCIDSCHEME_RA_2006_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_6: u32 = 25;
pub const XTENSA_HWVERSION_RA_2007_7: u32 = 210007;
pub const XTENSA_HWCIDSCHEME_RA_2007_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2007_7: u32 = 26;
pub const XTENSA_HWVERSION_RA_2008_8: u32 = 210008;
pub const XTENSA_HWCIDSCHEME_RA_2008_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2008_8: u32 = 27;
pub const XTENSA_HWVERSION_RB_2006_0: u32 = 220000;
pub const XTENSA_HWCIDSCHEME_RB_2006_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2006_0: u32 = 48;
pub const XTENSA_HWVERSION_RB_2007_1: u32 = 220001;
pub const XTENSA_HWCIDSCHEME_RB_2007_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_1: u32 = 49;
pub const XTENSA_HWVERSION_RB_2007_2: u32 = 221000;
pub const XTENSA_HWCIDSCHEME_RB_2007_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2: u32 = 52;
pub const XTENSA_HWVERSION_RB_2008_3: u32 = 221001;
pub const XTENSA_HWCIDSCHEME_RB_2008_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_3: u32 = 53;
pub const XTENSA_HWVERSION_RB_2008_4: u32 = 221002;
pub const XTENSA_HWCIDSCHEME_RB_2008_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_4: u32 = 54;
pub const XTENSA_HWVERSION_RB_2009_5: u32 = 221003;
pub const XTENSA_HWCIDSCHEME_RB_2009_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2009_5: u32 = 55;
pub const XTENSA_HWVERSION_RB_2007_2_MP: u32 = 221100;
pub const XTENSA_HWCIDSCHEME_RB_2007_2_MP: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2_MP: u32 = 64;
pub const XTENSA_HWVERSION_RC_2009_0: u32 = 230000;
pub const XTENSA_HWCIDSCHEME_RC_2009_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2009_0: u32 = 65;
pub const XTENSA_HWVERSION_RC_2010_1: u32 = 230001;
pub const XTENSA_HWCIDSCHEME_RC_2010_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_1: u32 = 66;
pub const XTENSA_HWVERSION_RC_2010_2: u32 = 230002;
pub const XTENSA_HWCIDSCHEME_RC_2010_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_2: u32 = 67;
pub const XTENSA_HWVERSION_RC_2011_3: u32 = 230003;
pub const XTENSA_HWCIDSCHEME_RC_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2011_3: u32 = 68;
pub const XTENSA_HWVERSION_RD_2010_0: u32 = 240000;
pub const XTENSA_HWCIDSCHEME_RD_2010_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2010_0: u32 = 80;
pub const XTENSA_HWVERSION_RD_2011_1: u32 = 240001;
pub const XTENSA_HWCIDSCHEME_RD_2011_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_1: u32 = 81;
pub const XTENSA_HWVERSION_RD_2011_2: u32 = 240002;
pub const XTENSA_HWCIDSCHEME_RD_2011_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_2: u32 = 82;
pub const XTENSA_HWVERSION_RD_2011_3: u32 = 240003;
pub const XTENSA_HWCIDSCHEME_RD_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_3: u32 = 83;
pub const XTENSA_HWVERSION_RD_2012_4: u32 = 240004;
pub const XTENSA_HWCIDSCHEME_RD_2012_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_4: u32 = 84;
pub const XTENSA_HWVERSION_RD_2012_5: u32 = 240005;
pub const XTENSA_HWCIDSCHEME_RD_2012_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_5: u32 = 85;
pub const XTENSA_HWVERSION_RE_2012_0: u32 = 250000;
pub const XTENSA_HWCIDSCHEME_RE_2012_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_0: u32 = 96;
pub const XTENSA_HWVERSION_RE_2012_1: u32 = 250001;
pub const XTENSA_HWCIDSCHEME_RE_2012_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_1: u32 = 97;
pub const XTENSA_HWVERSION_RE_2013_2: u32 = 250002;
pub const XTENSA_HWCIDSCHEME_RE_2013_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_2: u32 = 98;
pub const XTENSA_HWVERSION_RE_2013_3: u32 = 250003;
pub const XTENSA_HWCIDSCHEME_RE_2013_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_3: u32 = 99;
pub const XTENSA_HWVERSION_RE_2013_4: u32 = 250004;
pub const XTENSA_HWCIDSCHEME_RE_2013_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_4: u32 = 100;
pub const XTENSA_HWVERSION_RE_2014_5: u32 = 250005;
pub const XTENSA_HWCIDSCHEME_RE_2014_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2014_5: u32 = 101;
pub const XTENSA_HWVERSION_RE_2015_6: u32 = 250006;
pub const XTENSA_HWCIDSCHEME_RE_2015_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2015_6: u32 = 102;
pub const XTENSA_HWVERSION_RF_2014_0: u32 = 260000;
pub const XTENSA_HWCIDSCHEME_RF_2014_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_0: u32 = 112;
pub const XTENSA_HWVERSION_RF_2014_1: u32 = 260001;
pub const XTENSA_HWCIDSCHEME_RF_2014_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_1: u32 = 113;
pub const XTENSA_HWVERSION_RF_2015_2: u32 = 260002;
pub const XTENSA_HWCIDSCHEME_RF_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_2: u32 = 114;
pub const XTENSA_HWVERSION_RF_2015_3: u32 = 260003;
pub const XTENSA_HWCIDSCHEME_RF_2015_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_3: u32 = 115;
pub const XTENSA_HWVERSION_RF_2016_4: u32 = 260004;
pub const XTENSA_HWCIDSCHEME_RF_2016_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2016_4: u32 = 116;
pub const XTENSA_HWVERSION_RG_2015_0: u32 = 270000;
pub const XTENSA_HWCIDSCHEME_RG_2015_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_0: u32 = 128;
pub const XTENSA_HWVERSION_RG_2015_1: u32 = 270001;
pub const XTENSA_HWCIDSCHEME_RG_2015_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_1: u32 = 129;
pub const XTENSA_HWVERSION_RG_2015_2: u32 = 270002;
pub const XTENSA_HWCIDSCHEME_RG_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_2: u32 = 130;
pub const XTENSA_HWVERSION_RG_2016_3: u32 = 270003;
pub const XTENSA_HWCIDSCHEME_RG_2016_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2016_3: u32 = 131;
pub const XTENSA_HWVERSION_RG_2016_4: u32 = 270004;
pub const XTENSA_HWCIDSCHEME_RG_2016_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2016_4: u32 = 132;
pub const XTENSA_HWVERSION_RG_2017_5: u32 = 270005;
pub const XTENSA_HWCIDSCHEME_RG_2017_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_5: u32 = 133;
pub const XTENSA_HWVERSION_RG_2017_6: u32 = 270006;
pub const XTENSA_HWCIDSCHEME_RG_2017_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_6: u32 = 134;
pub const XTENSA_HWVERSION_RG_2017_7: u32 = 270007;
pub const XTENSA_HWCIDSCHEME_RG_2017_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_7: u32 = 135;
pub const XTENSA_HWVERSION_RG_2017_8: u32 = 270008;
pub const XTENSA_HWCIDSCHEME_RG_2017_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2017_8: u32 = 136;
pub const XTENSA_HWVERSION_RG_2018_9: u32 = 270009;
pub const XTENSA_HWCIDSCHEME_RG_2018_9: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2018_9: u32 = 137;
pub const XTENSA_HWVERSION_RH_2016_0: u32 = 280000;
pub const XTENSA_HWCIDSCHEME_RH_2016_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RH_2016_0: u32 = 144;
pub const XTENSA_SWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_SWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_SWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_SWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_SWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_SWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_SWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_SWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_SWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_SWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_SWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_SWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_SWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_SWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_SWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_SWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_SWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_SWVERSION_RA_2004_1: u32 = 600000;
pub const XTENSA_SWVERSION_RA_2005_1: u32 = 600001;
pub const XTENSA_SWVERSION_RA_2005_2: u32 = 600002;
pub const XTENSA_SWVERSION_RA_2005_3: u32 = 600003;
pub const XTENSA_SWVERSION_RA_2006_4: u32 = 600004;
pub const XTENSA_SWVERSION_RA_2006_5: u32 = 600005;
pub const XTENSA_SWVERSION_RA_2006_6: u32 = 600006;
pub const XTENSA_SWVERSION_RA_2007_7: u32 = 600007;
pub const XTENSA_SWVERSION_RA_2008_8: u32 = 600008;
pub const XTENSA_SWVERSION_RB_2006_0: u32 = 700000;
pub const XTENSA_SWVERSION_RB_2007_1: u32 = 700001;
pub const XTENSA_SWVERSION_RB_2007_2: u32 = 701000;
pub const XTENSA_SWVERSION_RB_2008_3: u32 = 701001;
pub const XTENSA_SWVERSION_RB_2008_4: u32 = 701002;
pub const XTENSA_SWVERSION_RB_2009_5: u32 = 701003;
pub const XTENSA_SWVERSION_RB_2007_2_MP: u32 = 701100;
pub const XTENSA_SWVERSION_RC_2009_0: u32 = 800000;
pub const XTENSA_SWVERSION_RC_2010_1: u32 = 800001;
pub const XTENSA_SWVERSION_RC_2010_2: u32 = 800002;
pub const XTENSA_SWVERSION_RC_2011_3: u32 = 800003;
pub const XTENSA_SWVERSION_RD_2010_0: u32 = 900000;
pub const XTENSA_SWVERSION_RD_2011_1: u32 = 900001;
pub const XTENSA_SWVERSION_RD_2011_2: u32 = 900002;
pub const XTENSA_SWVERSION_RD_2011_3: u32 = 900003;
pub const XTENSA_SWVERSION_RD_2012_4: u32 = 900004;
pub const XTENSA_SWVERSION_RD_2012_5: u32 = 900005;
pub const XTENSA_SWVERSION_RE_2012_0: u32 = 1000000;
pub const XTENSA_SWVERSION_RE_2012_1: u32 = 1000001;
pub const XTENSA_SWVERSION_RE_2013_2: u32 = 1000002;
pub const XTENSA_SWVERSION_RE_2013_3: u32 = 1000003;
pub const XTENSA_SWVERSION_RE_2013_4: u32 = 1000004;
pub const XTENSA_SWVERSION_RE_2014_5: u32 = 1000005;
pub const XTENSA_SWVERSION_RE_2015_6: u32 = 1000006;
pub const XTENSA_SWVERSION_RF_2014_0: u32 = 1100000;
pub const XTENSA_SWVERSION_RF_2014_1: u32 = 1100001;
pub const XTENSA_SWVERSION_RF_2015_2: u32 = 1100002;
pub const XTENSA_SWVERSION_RF_2015_3: u32 = 1100003;
pub const XTENSA_SWVERSION_RF_2016_4: u32 = 1100004;
pub const XTENSA_SWVERSION_RG_2015_0: u32 = 1200000;
pub const XTENSA_SWVERSION_RG_2015_1: u32 = 1200001;
pub const XTENSA_SWVERSION_RG_2015_2: u32 = 1200002;
pub const XTENSA_SWVERSION_RG_2016_3: u32 = 1200003;
pub const XTENSA_SWVERSION_RG_2016_4: u32 = 1200004;
pub const XTENSA_SWVERSION_RG_2017_5: u32 = 1200005;
pub const XTENSA_SWVERSION_RG_2017_6: u32 = 1200006;
pub const XTENSA_SWVERSION_RG_2017_7: u32 = 1200007;
pub const XTENSA_SWVERSION_RG_2017_8: u32 = 1200008;
pub const XTENSA_SWVERSION_RG_2018_9: u32 = 1200009;
pub const XTENSA_SWVERSION_RH_2016_0: u32 = 1300000;
pub const XTENSA_SWVERSION_T1040_1_PREHOTFIX: u32 = 104001;
pub const XTENSA_SWVERSION_6_0_0: u32 = 600000;
pub const XTENSA_SWVERSION_6_0_1: u32 = 600001;
pub const XTENSA_SWVERSION_6_0_2: u32 = 600002;
pub const XTENSA_SWVERSION_6_0_3: u32 = 600003;
pub const XTENSA_SWVERSION_6_0_4: u32 = 600004;
pub const XTENSA_SWVERSION_6_0_5: u32 = 600005;
pub const XTENSA_SWVERSION_6_0_6: u32 = 600006;
pub const XTENSA_SWVERSION_6_0_7: u32 = 600007;
pub const XTENSA_SWVERSION_6_0_8: u32 = 600008;
pub const XTENSA_SWVERSION_7_0_0: u32 = 700000;
pub const XTENSA_SWVERSION_7_0_1: u32 = 700001;
pub const XTENSA_SWVERSION_7_1_0: u32 = 701000;
pub const XTENSA_SWVERSION_7_1_1: u32 = 701001;
pub const XTENSA_SWVERSION_7_1_2: u32 = 701002;
pub const XTENSA_SWVERSION_7_1_3: u32 = 701003;
pub const XTENSA_SWVERSION_7_1_8_MP: u32 = 701100;
pub const XTENSA_SWVERSION_8_0_0: u32 = 800000;
pub const XTENSA_SWVERSION_8_0_1: u32 = 800001;
pub const XTENSA_SWVERSION_8_0_2: u32 = 800002;
pub const XTENSA_SWVERSION_8_0_3: u32 = 800003;
pub const XTENSA_SWVERSION_9_0_0: u32 = 900000;
pub const XTENSA_SWVERSION_9_0_1: u32 = 900001;
pub const XTENSA_SWVERSION_9_0_2: u32 = 900002;
pub const XTENSA_SWVERSION_9_0_3: u32 = 900003;
pub const XTENSA_SWVERSION_9_0_4: u32 = 900004;
pub const XTENSA_SWVERSION_9_0_5: u32 = 900005;
pub const XTENSA_SWVERSION_10_0_0: u32 = 1000000;
pub const XTENSA_SWVERSION_10_0_1: u32 = 1000001;
pub const XTENSA_SWVERSION_10_0_2: u32 = 1000002;
pub const XTENSA_SWVERSION_10_0_3: u32 = 1000003;
pub const XTENSA_SWVERSION_10_0_4: u32 = 1000004;
pub const XTENSA_SWVERSION_10_0_5: u32 = 1000005;
pub const XTENSA_SWVERSION_10_0_6: u32 = 1000006;
pub const XTENSA_SWVERSION_11_0_0: u32 = 1100000;
pub const XTENSA_SWVERSION_11_0_1: u32 = 1100001;
pub const XTENSA_SWVERSION_11_0_2: u32 = 1100002;
pub const XTENSA_SWVERSION_11_0_3: u32 = 1100003;
pub const XTENSA_SWVERSION_11_0_4: u32 = 1100004;
pub const XTENSA_SWVERSION_12_0_0: u32 = 1200000;
pub const XTENSA_SWVERSION_12_0_1: u32 = 1200001;
pub const XTENSA_SWVERSION_12_0_2: u32 = 1200002;
pub const XTENSA_SWVERSION_12_0_3: u32 = 1200003;
pub const XTENSA_SWVERSION_12_0_4: u32 = 1200004;
pub const XTENSA_SWVERSION_12_0_5: u32 = 1200005;
pub const XTENSA_SWVERSION_12_0_6: u32 = 1200006;
pub const XTENSA_SWVERSION_12_0_7: u32 = 1200007;
pub const XTENSA_SWVERSION_12_0_8: u32 = 1200008;
pub const XTENSA_SWVERSION_12_0_9: u32 = 1200009;
pub const XTENSA_SWVERSION_13_0_0: u32 = 1300000;
pub const XTENSA_RELEASE_NAME: &[u8; 10] = b"RG-2018.9\0";
pub const XTENSA_RELEASE_CANONICAL_NAME: &[u8; 10] = b"RG-2018.9\0";
pub const XTENSA_SWVERSION: u32 = 1200009;
pub const XTENSA_SWVERSION_NAME: &[u8; 7] = b"12.0.9\0";
pub const XTENSA_SWVERSION_CANONICAL_NAME: &[u8; 7] = b"12.0.9\0";
pub const XTENSA_SWVERSION_MAJORMID_NAME: &[u8; 5] = b"12.0\0";
pub const XTENSA_SWVERSION_MAJOR_NAME: &[u8; 3] = b"12\0";
pub const XTENSA_SWVERSION_LICENSE_NAME: &[u8; 5] = b"12.0\0";
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 1;
pub const XCHAL_NUM_AREGS: u32 = 64;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 6;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 1;
pub const XCHAL_LOOP_BUFFER_SIZE: u32 = 256;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 1;
pub const XCHAL_HAVE_SEXT: u32 = 1;
pub const XCHAL_HAVE_DEPBITS: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 1;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 1;
pub const XCHAL_HAVE_DIV32: u32 = 1;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 0;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 1;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 1;
pub const XCHAL_HAVE_S32C1I: u32 = 1;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 4;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MX: u32 = 0;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_PSO: u32 = 0;
pub const XCHAL_HAVE_PSO_CDM: u32 = 0;
pub const XCHAL_HAVE_PSO_FULL_RETENTION: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 1;
pub const XCHAL_HAVE_BOOLEANS: u32 = 1;
pub const XCHAL_HAVE_CP: u32 = 1;
pub const XCHAL_CP_MAXCFG: u32 = 8;
pub const XCHAL_HAVE_MAC16: u32 = 1;
pub const XCHAL_HAVE_FUSION: u32 = 0;
pub const XCHAL_HAVE_FUSION_FP: u32 = 0;
pub const XCHAL_HAVE_FUSION_LOW_POWER: u32 = 0;
pub const XCHAL_HAVE_FUSION_AES: u32 = 0;
pub const XCHAL_HAVE_FUSION_CONVENC: u32 = 0;
pub const XCHAL_HAVE_FUSION_LFSR_CRC: u32 = 0;
pub const XCHAL_HAVE_FUSION_BITOPS: u32 = 0;
pub const XCHAL_HAVE_FUSION_AVS: u32 = 0;
pub const XCHAL_HAVE_FUSION_16BIT_BASEBAND: u32 = 0;
pub const XCHAL_HAVE_FUSION_VITERBI: u32 = 0;
pub const XCHAL_HAVE_FUSION_SOFTDEMAP: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI4: u32 = 0;
pub const XCHAL_HAVE_HIFI4_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI3: u32 = 0;
pub const XCHAL_HAVE_HIFI3_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_HIFI2EP: u32 = 0;
pub const XCHAL_HAVE_HIFI_MINI: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_USER_DPFPU: u32 = 0;
pub const XCHAL_HAVE_USER_SPFPU: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 1;
pub const XCHAL_HAVE_FP_DIV: u32 = 1;
pub const XCHAL_HAVE_FP_RECIP: u32 = 1;
pub const XCHAL_HAVE_FP_SQRT: u32 = 1;
pub const XCHAL_HAVE_FP_RSQRT: u32 = 1;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_DIV: u32 = 0;
pub const XCHAL_HAVE_DFP_RECIP: u32 = 0;
pub const XCHAL_HAVE_DFP_SQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_RSQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_ACCEL: u32 = 1;
pub const XCHAL_HAVE_DFP_accel: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_ONLY: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_DOUBLE: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_PDX4: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2_DUALLSFLIX: u32 = 0;
pub const XCHAL_HAVE_BBE16: u32 = 0;
pub const XCHAL_HAVE_BBE16_RSQRT: u32 = 0;
pub const XCHAL_HAVE_BBE16_VECDIV: u32 = 0;
pub const XCHAL_HAVE_BBE16_DESPREAD: u32 = 0;
pub const XCHAL_HAVE_BBENEP: u32 = 0;
pub const XCHAL_HAVE_BSP3: u32 = 0;
pub const XCHAL_HAVE_BSP3_TRANSPOSE: u32 = 0;
pub const XCHAL_HAVE_SSP16: u32 = 0;
pub const XCHAL_HAVE_SSP16_VITERBI: u32 = 0;
pub const XCHAL_HAVE_TURBO16: u32 = 0;
pub const XCHAL_HAVE_BBP16: u32 = 0;
pub const XCHAL_HAVE_FLIX3: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP_HISTOGRAM: u32 = 0;
pub const XCHAL_NUM_LOADSTORE_UNITS: u32 = 1;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 4;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_DATA_PIPE_DELAY: u32 = 2;
pub const XCHAL_CLOCK_GATING_GLOBAL: u32 = 1;
pub const XCHAL_CLOCK_GATING_FUNCUNIT: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 1;
pub const XCHAL_SW_VERSION: u32 = 1100003;
pub const XCHAL_CORE_ID: &[u8; 17] = b"esp32_v3_49_prod\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 392854;
pub const XCHAL_HW_CONFIGID0: u32 = 3267166206;
pub const XCHAL_HW_CONFIGID1: u32 = 482737814;
pub const XCHAL_HW_VERSION_NAME: &[u8; 8] = b"LX6.0.3\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_VERSION: u32 = 260003;
pub const XCHAL_HW_REL_LX6: u32 = 1;
pub const XCHAL_HW_REL_LX6_0: u32 = 1;
pub const XCHAL_HW_REL_LX6_0_3: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MIN_VERSION: u32 = 260003;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MAX_VERSION: u32 = 260003;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PREFETCH_L1: u32 = 0;
pub const XCHAL_PREFETCH_CASTOUT_LINES: u32 = 0;
pub const XCHAL_PREFETCH_ENTRIES: u32 = 0;
pub const XCHAL_PREFETCH_BLOCK_ENTRIES: u32 = 0;
pub const XCHAL_HAVE_CACHE_BLOCKOPS: u32 = 0;
pub const XCHAL_HAVE_ICACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_DCACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_ICACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_DCACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_HAVE_AXI: u32 = 0;
pub const XCHAL_HAVE_PIF_WR_RESP: u32 = 0;
pub const XCHAL_HAVE_PIF_REQ_ATTR: u32 = 0;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_BANKS: u32 = 0;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_PADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_SIZE: u32 = 4194304;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_SIZE: u32 = 524288;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_SIZE: u32 = 4194304;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_BANKS: u32 = 1;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 524288;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_IMEM_LOADSTORE: u32 = 1;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 3;
pub const XCHAL_NUM_INTERRUPTS: u32 = 32;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 5;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 26;
pub const XCHAL_NUM_INTLEVELS: u32 = 6;
pub const XCHAL_EXCM_LEVEL: u32 = 3;
pub const XCHAL_INTLEVEL1_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_MASK: u32 = 3670016;
pub const XCHAL_INTLEVEL3_MASK: u32 = 683706368;
pub const XCHAL_INTLEVEL4_MASK: u32 = 1392508928;
pub const XCHAL_INTLEVEL5_MASK: u32 = 2214658048;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 4077567;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 687783935;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 2080292863;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 3;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 7;
pub const XCHAL_INT15_LEVEL: u32 = 3;
pub const XCHAL_INT16_LEVEL: u32 = 5;
pub const XCHAL_INT17_LEVEL: u32 = 1;
pub const XCHAL_INT18_LEVEL: u32 = 1;
pub const XCHAL_INT19_LEVEL: u32 = 2;
pub const XCHAL_INT20_LEVEL: u32 = 2;
pub const XCHAL_INT21_LEVEL: u32 = 2;
pub const XCHAL_INT22_LEVEL: u32 = 3;
pub const XCHAL_INT23_LEVEL: u32 = 3;
pub const XCHAL_INT24_LEVEL: u32 = 4;
pub const XCHAL_INT25_LEVEL: u32 = 4;
pub const XCHAL_INT26_LEVEL: u32 = 5;
pub const XCHAL_INT27_LEVEL: u32 = 3;
pub const XCHAL_INT28_LEVEL: u32 = 4;
pub const XCHAL_INT29_LEVEL: u32 = 3;
pub const XCHAL_INT30_LEVEL: u32 = 4;
pub const XCHAL_INT31_LEVEL: u32 = 5;
pub const XCHAL_DEBUGLEVEL: u32 = 6;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 7;
pub const XCHAL_INT0_TYPE: u32 = 3;
pub const XCHAL_INT1_TYPE: u32 = 3;
pub const XCHAL_INT2_TYPE: u32 = 3;
pub const XCHAL_INT3_TYPE: u32 = 3;
pub const XCHAL_INT4_TYPE: u32 = 3;
pub const XCHAL_INT5_TYPE: u32 = 3;
pub const XCHAL_INT6_TYPE: u32 = 4;
pub const XCHAL_INT7_TYPE: u32 = 1;
pub const XCHAL_INT8_TYPE: u32 = 3;
pub const XCHAL_INT9_TYPE: u32 = 3;
pub const XCHAL_INT10_TYPE: u32 = 2;
pub const XCHAL_INT11_TYPE: u32 = 7;
pub const XCHAL_INT12_TYPE: u32 = 3;
pub const XCHAL_INT13_TYPE: u32 = 3;
pub const XCHAL_INT14_TYPE: u32 = 5;
pub const XCHAL_INT15_TYPE: u32 = 4;
pub const XCHAL_INT16_TYPE: u32 = 4;
pub const XCHAL_INT17_TYPE: u32 = 3;
pub const XCHAL_INT18_TYPE: u32 = 3;
pub const XCHAL_INT19_TYPE: u32 = 3;
pub const XCHAL_INT20_TYPE: u32 = 3;
pub const XCHAL_INT21_TYPE: u32 = 3;
pub const XCHAL_INT22_TYPE: u32 = 2;
pub const XCHAL_INT23_TYPE: u32 = 3;
pub const XCHAL_INT24_TYPE: u32 = 3;
pub const XCHAL_INT25_TYPE: u32 = 3;
pub const XCHAL_INT26_TYPE: u32 = 3;
pub const XCHAL_INT27_TYPE: u32 = 3;
pub const XCHAL_INT28_TYPE: u32 = 2;
pub const XCHAL_INT29_TYPE: u32 = 1;
pub const XCHAL_INT30_TYPE: u32 = 2;
pub const XCHAL_INT31_TYPE: u32 = 3;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 0;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 536871040;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 1346372608;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 2411606847;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 98368;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_INTTYPE_MASK_PROFILING: u32 = 2048;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_TIMER1_INTERRUPT: u32 = 15;
pub const XCHAL_TIMER2_INTERRUPT: u32 = 16;
pub const XCHAL_TIMER3_INTERRUPT: i32 = -1;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_PROFILING_INTERRUPT: u32 = 11;
pub const XCHAL_INTLEVEL7_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 12;
pub const XCHAL_EXTINT10_NUM: u32 = 13;
pub const XCHAL_EXTINT11_NUM: u32 = 14;
pub const XCHAL_EXTINT12_NUM: u32 = 17;
pub const XCHAL_EXTINT13_NUM: u32 = 18;
pub const XCHAL_EXTINT14_NUM: u32 = 19;
pub const XCHAL_EXTINT15_NUM: u32 = 20;
pub const XCHAL_EXTINT16_NUM: u32 = 21;
pub const XCHAL_EXTINT17_NUM: u32 = 22;
pub const XCHAL_EXTINT18_NUM: u32 = 23;
pub const XCHAL_EXTINT19_NUM: u32 = 24;
pub const XCHAL_EXTINT20_NUM: u32 = 25;
pub const XCHAL_EXTINT21_NUM: u32 = 26;
pub const XCHAL_EXTINT22_NUM: u32 = 27;
pub const XCHAL_EXTINT23_NUM: u32 = 28;
pub const XCHAL_EXTINT24_NUM: u32 = 30;
pub const XCHAL_EXTINT25_NUM: u32 = 31;
pub const XCHAL_INT0_EXTNUM: u32 = 0;
pub const XCHAL_INT1_EXTNUM: u32 = 1;
pub const XCHAL_INT2_EXTNUM: u32 = 2;
pub const XCHAL_INT3_EXTNUM: u32 = 3;
pub const XCHAL_INT4_EXTNUM: u32 = 4;
pub const XCHAL_INT5_EXTNUM: u32 = 5;
pub const XCHAL_INT8_EXTNUM: u32 = 6;
pub const XCHAL_INT9_EXTNUM: u32 = 7;
pub const XCHAL_INT10_EXTNUM: u32 = 8;
pub const XCHAL_INT12_EXTNUM: u32 = 9;
pub const XCHAL_INT13_EXTNUM: u32 = 10;
pub const XCHAL_INT14_EXTNUM: u32 = 11;
pub const XCHAL_INT17_EXTNUM: u32 = 12;
pub const XCHAL_INT18_EXTNUM: u32 = 13;
pub const XCHAL_INT19_EXTNUM: u32 = 14;
pub const XCHAL_INT20_EXTNUM: u32 = 15;
pub const XCHAL_INT21_EXTNUM: u32 = 16;
pub const XCHAL_INT22_EXTNUM: u32 = 17;
pub const XCHAL_INT23_EXTNUM: u32 = 18;
pub const XCHAL_INT24_EXTNUM: u32 = 19;
pub const XCHAL_INT25_EXTNUM: u32 = 20;
pub const XCHAL_INT26_EXTNUM: u32 = 21;
pub const XCHAL_INT27_EXTNUM: u32 = 22;
pub const XCHAL_INT28_EXTNUM: u32 = 23;
pub const XCHAL_INT30_EXTNUM: u32 = 24;
pub const XCHAL_INT31_EXTNUM: u32 = 25;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_HALT: u32 = 0;
pub const XCHAL_HAVE_BOOTLOADER: u32 = 0;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XCHAL_USER_VECOFS: u32 = 832;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_KERNEL_VECOFS: u32 = 768;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 960;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073742784;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073742784;
pub const XCHAL_WINDOW_OF4_VECOFS: u32 = 0;
pub const XCHAL_WINDOW_UF4_VECOFS: u32 = 64;
pub const XCHAL_WINDOW_OF8_VECOFS: u32 = 128;
pub const XCHAL_WINDOW_UF8_VECOFS: u32 = 192;
pub const XCHAL_WINDOW_OF12_VECOFS: u32 = 256;
pub const XCHAL_WINDOW_UF12_VECOFS: u32 = 320;
pub const XCHAL_WINDOW_VECTORS_VADDR: u32 = 1073741824;
pub const XCHAL_WINDOW_VECTORS_PADDR: u32 = 1073741824;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 384;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 448;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL4_VECOFS: u32 = 512;
pub const XCHAL_INTLEVEL4_VECTOR_VADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL4_VECTOR_PADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL5_VECOFS: u32 = 576;
pub const XCHAL_INTLEVEL5_VECTOR_VADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL5_VECTOR_PADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL6_VECOFS: u32 = 640;
pub const XCHAL_INTLEVEL6_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_INTLEVEL6_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECOFS: u32 = 640;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_NMI_VECOFS: u32 = 704;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECOFS: u32 = 704;
pub const XCHAL_INTLEVEL7_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_HAVE_DEBUG_ERI: u32 = 1;
pub const XCHAL_HAVE_DEBUG_APB: u32 = 1;
pub const XCHAL_HAVE_DEBUG_JTAG: u32 = 1;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 2;
pub const XCHAL_NUM_DBREAK: u32 = 2;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_OCD_LS32DDR: u32 = 1;
pub const XCHAL_HAVE_TRAX: u32 = 1;
pub const XCHAL_TRAX_MEM_SIZE: u32 = 16384;
pub const XCHAL_TRAX_MEM_SHAREABLE: u32 = 1;
pub const XCHAL_TRAX_ATB_WIDTH: u32 = 32;
pub const XCHAL_TRAX_TIME_WIDTH: u32 = 0;
pub const XCHAL_NUM_PERF_COUNTERS: u32 = 2;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_BYPASSBUF: u32 = 6;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_HAVE_CA_WRITEBACK_NOALLOC: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_CP_NUM: u32 = 1;
pub const XCHAL_CP_MAX: u32 = 1;
pub const XCHAL_CP_MASK: u32 = 1;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_CP0_NAME: &[u8; 4] = b"FPU\0";
pub const XCHAL_CP0_SA_SIZE: u32 = 72;
pub const XCHAL_CP0_SA_ALIGN: u32 = 4;
pub const XCHAL_CP_ID_FPU: u32 = 0;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_SIZE: u32 = 48;
pub const XCHAL_NCP_SA_ALIGN: u32 = 4;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 128;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 4;
pub const XCHAL_NCP_SA_NUM: u32 = 12;
pub const XCHAL_CP0_SA_NUM: u32 = 18;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_LOWPRI_MASK: u32 = 407551;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 1883243648;
pub const XCHAL_INTSETTABLE_MASK: u32 = 536871040;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 4096;
pub const XCHAL_EXTINT10_MASK: u32 = 8192;
pub const XCHAL_EXTINT11_MASK: u32 = 16384;
pub const XCHAL_EXTINT12_MASK: u32 = 131072;
pub const XCHAL_EXTINT13_MASK: u32 = 262144;
pub const XCHAL_EXTINT14_MASK: u32 = 524288;
pub const XCHAL_EXTINT15_MASK: u32 = 1048576;
pub const XCHAL_EXTINT16_MASK: u32 = 2097152;
pub const XCHAL_EXTINT17_MASK: u32 = 4194304;
pub const XCHAL_EXTINT18_MASK: u32 = 8388608;
pub const XCHAL_EXTINT19_MASK: u32 = 16777216;
pub const XCHAL_EXTINT20_MASK: u32 = 33554432;
pub const XCHAL_EXTINT21_MASK: u32 = 67108864;
pub const XCHAL_EXTINT22_MASK: u32 = 134217728;
pub const XCHAL_EXTINT23_MASK: u32 = 268435456;
pub const XCHAL_EXTINT24_MASK: u32 = 1073741824;
pub const XCHAL_EXTINT25_MASK: u32 = 2147483648;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1082130432;
pub const XCHAL_IROM0_PADDR: u32 = 1082130432;
pub const XCHAL_IROM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_SIZE: u32 = 4194304;
pub const XCHAL_DROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DROM0_SIZE: u32 = 4194304;
pub const XCHAL_DRAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_SIZE: u32 = 524288;
pub const XCHAL_DRAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_SIZE: u32 = 4194304;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 4164;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_CACHE_MEMCTL_DEFAULT: u32 = 0;
pub const _MEMCTL_SNOOP_EN: u32 = 0;
pub const _MEMCTL_L0IBUF_EN: u32 = 1;
pub const XCHAL_SNOOP_LB_MEMCTL_DEFAULT: u32 = 1;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2600;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 3;
pub const XCHAL_HW_RELEASE_NAME: &[u8; 8] = b"LX6.0.3\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 48;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 128;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 128;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const XCHAL_ERRATUM_453: u32 = 0;
pub const XCHAL_ERRATUM_497: u32 = 0;
pub const XCHAL_ERRATUM_572: u32 = 1;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XSHAL_HAVE_TEXT_SECTION_LITERALS: u32 = 1;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XTHAL_CLIB_XCLIB: u32 = 2;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_FLOATING_POINT_ABI: u32 = 0;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16777216;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_PSIZE: u32 = 536870912;
pub const XSHAL_RAM_SIZE: u32 = 536870912;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 536870912;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_MAGIC_EXIT: u32 = 0;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 1;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 0;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 64;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_WINDOW_VECTORS_SIZE: u32 = 376;
pub const XSHAL_WINDOW_VECTORS_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL3_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL4_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL4_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL5_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL5_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL6_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL6_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 56;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL7_VECTOR_SIZE: u32 = 56;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PC_ERROR: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_EXTREG_PRIVILEGE: u32 = 10;
pub const EXCCAUSE_EXCLUSIVE_ERROR: u32 = 11;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_WOE_ABI: u32 = 262144;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const MEMCTL_SNOOP_EN_SHIFT: u32 = 1;
pub const MEMCTL_SNOOP_EN: u32 = 2;
pub const MEMCTL_L0IBUF_EN_SHIFT: u32 = 0;
pub const MEMCTL_L0IBUF_EN: u32 = 1;
pub const MEMCTL_INV_EN_SHIFT: u32 = 23;
pub const MEMCTL_INV_EN: u32 = 8388608;
pub const MEMCTL_DCWU_SHIFT: u32 = 8;
pub const MEMCTL_DCWU_BITS: u32 = 5;
pub const MEMCTL_DCWA_SHIFT: u32 = 13;
pub const MEMCTL_DCWA_BITS: u32 = 5;
pub const MEMCTL_ICWU_SHIFT: u32 = 18;
pub const MEMCTL_ICWU_BITS: u32 = 5;
pub const MEMCTL_DCWU_MASK: u32 = 7936;
pub const MEMCTL_DCWA_MASK: u32 = 253952;
pub const MEMCTL_ICWU_MASK: u32 = 8126464;
pub const MEMCTL_DCWU_CLR_MASK: i32 = -7937;
pub const MEMCTL_DCWA_CLR_MASK: i32 = -253953;
pub const MEMCTL_ICWU_CLR_MASK: i32 = -8126465;
pub const MEMCTL_DCW_CLR_MASK: i32 = -1;
pub const MEMCTL_IDCW_CLR_MASK: i32 = -1;
pub const CALL0_ABI: u32 = 0;
pub const ALIGNPAD: u32 = 2;
pub const KERNELSTACKSIZE: u32 = 1024;
pub const XT_CP0_SA: u32 = 0;
pub const XT_CPENABLE: u32 = 0;
pub const XT_CPSTORED: u32 = 2;
pub const XT_CP_CS_ST: u32 = 4;
pub const XT_CP_ASA: u32 = 8;
pub const CORE_ID_REGVAL_PRO: u32 = 52685;
pub const CORE_ID_REGVAL_APP: u32 = 43947;
pub const CORE_ID_PRO: u32 = 52685;
pub const CORE_ID_APP: u32 = 43947;
pub const STK_INTEXC_EXTRA: u32 = 0;
pub const XT_USE_THREAD_SAFE_CLIB: u32 = 1;
pub const XT_HAVE_THREAD_SAFE_CLIB: u32 = 1;
pub const XT_USER_SIZE: u32 = 1024;
pub const configXT_SIMULATOR: u32 = 0;
pub const configXT_BOARD: u32 = 1;
pub const configXT_TIMER_INDEX: u32 = 0;
pub const configXT_INTEXC_HOOKS: u32 = 0;
pub const configBENCHMARK: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configMINIMAL_STACK_SIZE: u32 = 1536;
pub const configMAX_API_CALL_INTERRUPT_PRIORITY: u32 = 3;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 1;
pub const INCLUDE_xTaskDelayUntil: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 1;
pub const configSTACK_ALIGNMENT: u32 = 16;
pub const configISR_STACK_SIZE: u32 = 1536;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configCPU_CLOCK_HZ: u32 = 160000000;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configMAX_PRIORITIES: u32 = 25;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 1;
pub const configNUMBER_OF_CORES: u32 = 2;
pub const configNUM_CORES: u32 = 2;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 2;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 0;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u32 = 0;
pub const configUSE_IDLE_HOOK: u32 = 0;
pub const configUSE_TICK_HOOK: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 1;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const configUSE_TIMERS: u32 = 0;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_xTaskAbortDelay: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const INCLUDE_xTaskGetHandle: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 0;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 1;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const configCHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const portNUM_PROCESSORS: u32 = 2;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const LBEG: u32 = 0;
pub const LEND: u32 = 1;
pub const LCOUNT: u32 = 2;
pub const SAR: u32 = 3;
pub const BR: u32 = 4;
pub const SCOMPARE1: u32 = 12;
pub const ACCLO: u32 = 16;
pub const ACCHI: u32 = 17;
pub const MR_0: u32 = 32;
pub const MR_1: u32 = 33;
pub const MR_2: u32 = 34;
pub const MR_3: u32 = 35;
pub const WINDOWBASE: u32 = 72;
pub const WINDOWSTART: u32 = 73;
pub const IBREAKENABLE: u32 = 96;
pub const MEMCTL: u32 = 97;
pub const ATOMCTL: u32 = 99;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const IBREAKA_1: u32 = 129;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKA_1: u32 = 145;
pub const DBREAKC_0: u32 = 160;
pub const DBREAKC_1: u32 = 161;
pub const CONFIGID0: u32 = 176;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const EPC_4: u32 = 180;
pub const EPC_5: u32 = 181;
pub const EPC_6: u32 = 182;
pub const EPC_7: u32 = 183;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EPS_4: u32 = 196;
pub const EPS_5: u32 = 197;
pub const EPS_6: u32 = 198;
pub const EPS_7: u32 = 199;
pub const CONFIGID1: u32 = 208;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const EXCSAVE_4: u32 = 212;
pub const EXCSAVE_5: u32 = 213;
pub const EXCSAVE_6: u32 = 214;
pub const EXCSAVE_7: u32 = 215;
pub const CPENABLE: u32 = 224;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const CCOMPARE_1: u32 = 241;
pub const CCOMPARE_2: u32 = 242;
pub const MISC_REG_0: u32 = 244;
pub const MISC_REG_1: u32 = 245;
pub const MISC_REG_2: u32 = 246;
pub const MISC_REG_3: u32 = 247;
pub const MR: u32 = 32;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const CORE_STATE_SIGNATURE: u32 = 2982522861;
pub const XTOS_KEEPON_MEM: u32 = 256;
pub const XTOS_KEEPON_MEM_SHIFT: u32 = 8;
pub const XTOS_KEEPON_DEBUG: u32 = 4096;
pub const XTOS_KEEPON_DEBUG_SHIFT: u32 = 12;
pub const XTOS_IDMA_NO_WAIT: u32 = 65536;
pub const XTOS_IDMA_WAIT_STANDBY: u32 = 131072;
pub const XTOS_COREF_PSO: u32 = 1;
pub const XTOS_COREF_PSO_SHIFT: u32 = 0;
pub const EXTRA_SAVE_AREA_SIZE: u32 = 32;
pub const BASE_SAVE_AREA_SIZE: u32 = 16;
pub const SAVE_AREA_OFFSET: u32 = 48;
pub const BASE_AREA_SP_OFFSET: u32 = 12;
pub const DSRSET: u32 = 1056780;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const BIT63: i64 = -9223372036854775808;
pub const BIT62: u64 = 4611686018427387904;
pub const BIT61: u64 = 2305843009213693952;
pub const BIT60: u64 = 1152921504606846976;
pub const BIT59: u64 = 576460752303423488;
pub const BIT58: u64 = 288230376151711744;
pub const BIT57: u64 = 144115188075855872;
pub const BIT56: u64 = 72057594037927936;
pub const BIT55: u64 = 36028797018963968;
pub const BIT54: u64 = 18014398509481984;
pub const BIT53: u64 = 9007199254740992;
pub const BIT52: u64 = 4503599627370496;
pub const BIT51: u64 = 2251799813685248;
pub const BIT50: u64 = 1125899906842624;
pub const BIT49: u64 = 562949953421312;
pub const BIT48: u64 = 281474976710656;
pub const BIT47: u64 = 140737488355328;
pub const BIT46: u64 = 70368744177664;
pub const BIT45: u64 = 35184372088832;
pub const BIT44: u64 = 17592186044416;
pub const BIT43: u64 = 8796093022208;
pub const BIT42: u64 = 4398046511104;
pub const BIT41: u64 = 2199023255552;
pub const BIT40: u64 = 1099511627776;
pub const BIT39: u64 = 549755813888;
pub const BIT38: u64 = 274877906944;
pub const BIT37: u64 = 137438953472;
pub const BIT36: u64 = 68719476736;
pub const BIT35: u64 = 34359738368;
pub const BIT34: u64 = 17179869184;
pub const BIT33: u64 = 8589934592;
pub const BIT32: u64 = 4294967296;
pub const ESP_CPU_INTR_DESC_FLAG_SPECIAL: u32 = 1;
pub const ESP_CPU_INTR_DESC_FLAG_RESVD: u32 = 2;
pub const SPINLOCK_FREE: u32 = 3007315967;
pub const SPINLOCK_WAIT_FOREVER: i32 = -1;
pub const SPINLOCK_NO_WAIT: u32 = 0;
pub const SPINLOCK_OWNER_ID_0: u32 = 52685;
pub const SPINLOCK_OWNER_ID_1: u32 = 43947;
pub const CORE_ID_REGVAL_XOR_SWAP: u32 = 26214;
pub const SPINLOCK_OWNER_ID_XOR_SWAP: u32 = 26214;
pub const DR_REG_DPORT_BASE: u32 = 1072693248;
pub const DR_REG_AES_BASE: u32 = 1072697344;
pub const DR_REG_RSA_BASE: u32 = 1072701440;
pub const DR_REG_SHA_BASE: u32 = 1072705536;
pub const DR_REG_FLASH_MMU_TABLE_PRO: u32 = 1072758784;
pub const DR_REG_FLASH_MMU_TABLE_APP: u32 = 1072766976;
pub const DR_REG_DPORT_END: u32 = 1072775164;
pub const DR_REG_UART_BASE: u32 = 1072955392;
pub const DR_REG_SPI1_BASE: u32 = 1072963584;
pub const DR_REG_SPI0_BASE: u32 = 1072967680;
pub const DR_REG_GPIO_BASE: u32 = 1072971776;
pub const DR_REG_GPIO_SD_BASE: u32 = 1072975616;
pub const DR_REG_FE2_BASE: u32 = 1072975872;
pub const DR_REG_FE_BASE: u32 = 1072979968;
pub const DR_REG_FRC_TIMER_BASE: u32 = 1072984064;
pub const DR_REG_RTCCNTL_BASE: u32 = 1072988160;
pub const DR_REG_RTCIO_BASE: u32 = 1072989184;
pub const DR_REG_SENS_BASE: u32 = 1072990208;
pub const DR_REG_RTC_I2C_BASE: u32 = 1072991232;
pub const DR_REG_IO_MUX_BASE: u32 = 1072992256;
pub const DR_REG_HINF_BASE: u32 = 1073000448;
pub const DR_REG_UHCI1_BASE: u32 = 1073004544;
pub const DR_REG_I2S_BASE: u32 = 1073016832;
pub const DR_REG_UART1_BASE: u32 = 1073020928;
pub const DR_REG_BT_BASE: u32 = 1073025024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1073033216;
pub const DR_REG_UHCI0_BASE: u32 = 1073037312;
pub const DR_REG_SLCHOST_BASE: u32 = 1073041408;
pub const DR_REG_RMT_BASE: u32 = 1073045504;
pub const DR_REG_PCNT_BASE: u32 = 1073049600;
pub const DR_REG_SLC_BASE: u32 = 1073053696;
pub const DR_REG_LEDC_BASE: u32 = 1073057792;
pub const DR_REG_EFUSE_BASE: u32 = 1073061888;
pub const DR_REG_SPI_ENCRYPT_BASE: u32 = 1073065984;
pub const DR_REG_NRX_BASE: u32 = 1073073152;
pub const DR_REG_BB_BASE: u32 = 1073074176;
pub const DR_REG_PWM0_BASE: u32 = 1073078272;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1073082368;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1073086464;
pub const DR_REG_RTCMEM0_BASE: u32 = 1073090560;
pub const DR_REG_RTCMEM1_BASE: u32 = 1073094656;
pub const DR_REG_RTCMEM2_BASE: u32 = 1073098752;
pub const DR_REG_SPI2_BASE: u32 = 1073102848;
pub const DR_REG_SPI3_BASE: u32 = 1073106944;
pub const DR_REG_SYSCON_BASE: u32 = 1073111040;
pub const DR_REG_APB_CTRL_BASE: u32 = 1073111040;
pub const DR_REG_I2C1_EXT_BASE: u32 = 1073115136;
pub const DR_REG_SDMMC_BASE: u32 = 1073119232;
pub const DR_REG_EMAC_BASE: u32 = 1073123328;
pub const DR_REG_CAN_BASE: u32 = 1073131520;
pub const DR_REG_PWM1_BASE: u32 = 1073135616;
pub const DR_REG_I2S1_BASE: u32 = 1073139712;
pub const DR_REG_UART2_BASE: u32 = 1073143808;
pub const PERIPHS_SPI_ENCRYPT_BASEADDR: u32 = 1073065984;
pub const PRO_CPU_NUM: u32 = 0;
pub const APP_CPU_NUM: u32 = 1;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 4194304;
pub const APB_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_MHZ_BTLD: u32 = 80;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const MODEM_REQUIRED_MIN_APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 26;
pub const SOC_DROM_LOW: u32 = 1061158912;
pub const SOC_DROM_HIGH: u32 = 1065353216;
pub const SOC_DRAM_LOW: u32 = 1073405952;
pub const SOC_DRAM_HIGH: u32 = 1073741824;
pub const SOC_IROM_LOW: u32 = 1074593792;
pub const SOC_IROM_HIGH: u32 = 1077936128;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074200576;
pub const SOC_CACHE_PRO_LOW: u32 = 1074200576;
pub const SOC_CACHE_PRO_HIGH: u32 = 1074233344;
pub const SOC_CACHE_APP_LOW: u32 = 1074233344;
pub const SOC_CACHE_APP_HIGH: u32 = 1074266112;
pub const SOC_IRAM_LOW: u32 = 1074266112;
pub const SOC_IRAM_HIGH: u32 = 1074438144;
pub const SOC_RTC_IRAM_LOW: u32 = 1074528256;
pub const SOC_RTC_IRAM_HIGH: u32 = 1074536448;
pub const SOC_RTC_DRAM_LOW: u32 = 1073217536;
pub const SOC_RTC_DRAM_HIGH: u32 = 1073225728;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_EXTRAM_DATA_LOW: u32 = 1065353216;
pub const SOC_EXTRAM_DATA_HIGH: u32 = 1069547520;
pub const SOC_EXTRAM_DATA_SIZE: u32 = 4194304;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1074397184;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1074528256;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1073610752;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1073741824;
pub const SOC_DIRAM_INVERTED: u32 = 1;
pub const SOC_DMA_LOW: u32 = 1073405952;
pub const SOC_DMA_HIGH: u32 = 1073741824;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1073283072;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1073741824;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1073283072;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1074536448;
pub const SOC_ROM_STACK_START: u32 = 1073626912;
pub const ETS_WMAC_INUM: u32 = 0;
pub const ETS_BT_HOST_INUM: u32 = 1;
pub const ETS_WBB_INUM: u32 = 4;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_MEMACCESS_ERR_INUM: u32 = 25;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_IPC_ISR_INUM: u32 = 28;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_INVALID_INUM: u32 = 6;
pub const ETS_INT_WDT_INUM: u32 = 24;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_PID2: u32 = 16;
pub const MALLOC_CAP_PID3: u32 = 32;
pub const MALLOC_CAP_PID4: u32 = 64;
pub const MALLOC_CAP_PID5: u32 = 128;
pub const MALLOC_CAP_PID6: u32 = 256;
pub const MALLOC_CAP_PID7: u32 = 512;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_DEFAULT: u32 = 4096;
pub const MALLOC_CAP_IRAM_8BIT: u32 = 8192;
pub const MALLOC_CAP_RETENTION: u32 = 16384;
pub const MALLOC_CAP_RTCRAM: u32 = 32768;
pub const MALLOC_CAP_TCM: u32 = 65536;
pub const MALLOC_CAP_DMA_DESC_AHB: u32 = 131072;
pub const MALLOC_CAP_DMA_DESC_AXI: u32 = 262144;
pub const MALLOC_CAP_CACHE_ALIGNED: u32 = 524288;
pub const MALLOC_CAP_SIMD: u32 = 1048576;
pub const MALLOC_CAP_INVALID: u32 = 2147483648;
pub const ESP_IDF_VERSION_MAJOR: u32 = 5;
pub const ESP_IDF_VERSION_MINOR: u32 = 5;
pub const ESP_IDF_VERSION_PATCH: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const ARG_MAX: u32 = 65536;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 16;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portMUX_FREE_VAL: u32 = 3007315967;
pub const portMUX_NO_TIMEOUT: i32 = -1;
pub const portMUX_TRY_LOCK: u32 = 0;
pub const portBYTE_ALIGNMENT_MASK: u32 = 15;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 0;
pub const configUSE_C_RUNTIME_TLS_SUPPORT: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const configPRECONDITION_DEFINED: u32 = 0;
pub const configUSE_MINI_LIST_ITEM: u32 = 1;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const configUSE_SB_COMPLETED_CALLBACK: u32 = 0;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const configENABLE_MPU: u32 = 0;
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_MVE: u32 = 0;
pub const configENABLE_TRUSTZONE: u32 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 0;
pub const configRUN_ADDITIONAL_TESTS: u32 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 8] = b"V10.5.1\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 10;
pub const tskKERNEL_VERSION_MINOR: u32 = 5;
pub const tskKERNEL_VERSION_BUILD: u32 = 1;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u32 = 0;
pub const SOC_CLK_RC_FAST_FREQ_APPROX: u32 = 8500000;
pub const SOC_CLK_RC_SLOW_FREQ_APPROX: u32 = 150000;
pub const SOC_CLK_RC_FAST_D256_FREQ_APPROX: u32 = 33203;
pub const SOC_CLK_XTAL32K_FREQ_APPROX: u32 = 32768;
pub const UART_PIN_NO_CHANGE: i32 = -1;
pub const UART_BITRATE_MAX: u32 = 5000000;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const F_OK: u32 = 0;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _SC_ARG_MAX: u32 = 0;
pub const _SC_CHILD_MAX: u32 = 1;
pub const _SC_CLK_TCK: u32 = 2;
pub const _SC_NGROUPS_MAX: u32 = 3;
pub const _SC_OPEN_MAX: u32 = 4;
pub const _SC_JOB_CONTROL: u32 = 5;
pub const _SC_SAVED_IDS: u32 = 6;
pub const _SC_VERSION: u32 = 7;
pub const _SC_PAGESIZE: u32 = 8;
pub const _SC_PAGE_SIZE: u32 = 8;
pub const _SC_NPROCESSORS_CONF: u32 = 9;
pub const _SC_NPROCESSORS_ONLN: u32 = 10;
pub const _SC_PHYS_PAGES: u32 = 11;
pub const _SC_AVPHYS_PAGES: u32 = 12;
pub const _SC_MQ_OPEN_MAX: u32 = 13;
pub const _SC_MQ_PRIO_MAX: u32 = 14;
pub const _SC_RTSIG_MAX: u32 = 15;
pub const _SC_SEM_NSEMS_MAX: u32 = 16;
pub const _SC_SEM_VALUE_MAX: u32 = 17;
pub const _SC_SIGQUEUE_MAX: u32 = 18;
pub const _SC_TIMER_MAX: u32 = 19;
pub const _SC_TZNAME_MAX: u32 = 20;
pub const _SC_ASYNCHRONOUS_IO: u32 = 21;
pub const _SC_FSYNC: u32 = 22;
pub const _SC_MAPPED_FILES: u32 = 23;
pub const _SC_MEMLOCK: u32 = 24;
pub const _SC_MEMLOCK_RANGE: u32 = 25;
pub const _SC_MEMORY_PROTECTION: u32 = 26;
pub const _SC_MESSAGE_PASSING: u32 = 27;
pub const _SC_PRIORITIZED_IO: u32 = 28;
pub const _SC_REALTIME_SIGNALS: u32 = 29;
pub const _SC_SEMAPHORES: u32 = 30;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 31;
pub const _SC_SYNCHRONIZED_IO: u32 = 32;
pub const _SC_TIMERS: u32 = 33;
pub const _SC_AIO_LISTIO_MAX: u32 = 34;
pub const _SC_AIO_MAX: u32 = 35;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 36;
pub const _SC_DELAYTIMER_MAX: u32 = 37;
pub const _SC_THREAD_KEYS_MAX: u32 = 38;
pub const _SC_THREAD_STACK_MIN: u32 = 39;
pub const _SC_THREAD_THREADS_MAX: u32 = 40;
pub const _SC_TTY_NAME_MAX: u32 = 41;
pub const _SC_THREADS: u32 = 42;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 43;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 44;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 45;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 46;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 47;
pub const _SC_THREAD_PRIO_CEILING: u32 = 47;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 48;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 49;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 50;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 51;
pub const _SC_LOGIN_NAME_MAX: u32 = 52;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 53;
pub const _SC_ADVISORY_INFO: u32 = 54;
pub const _SC_ATEXIT_MAX: u32 = 55;
pub const _SC_BARRIERS: u32 = 56;
pub const _SC_BC_BASE_MAX: u32 = 57;
pub const _SC_BC_DIM_MAX: u32 = 58;
pub const _SC_BC_SCALE_MAX: u32 = 59;
pub const _SC_BC_STRING_MAX: u32 = 60;
pub const _SC_CLOCK_SELECTION: u32 = 61;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 62;
pub const _SC_CPUTIME: u32 = 63;
pub const _SC_EXPR_NEST_MAX: u32 = 64;
pub const _SC_HOST_NAME_MAX: u32 = 65;
pub const _SC_IOV_MAX: u32 = 66;
pub const _SC_IPV6: u32 = 67;
pub const _SC_LINE_MAX: u32 = 68;
pub const _SC_MONOTONIC_CLOCK: u32 = 69;
pub const _SC_RAW_SOCKETS: u32 = 70;
pub const _SC_READER_WRITER_LOCKS: u32 = 71;
pub const _SC_REGEXP: u32 = 72;
pub const _SC_RE_DUP_MAX: u32 = 73;
pub const _SC_SHELL: u32 = 74;
pub const _SC_SPAWN: u32 = 75;
pub const _SC_SPIN_LOCKS: u32 = 76;
pub const _SC_SPORADIC_SERVER: u32 = 77;
pub const _SC_SS_REPL_MAX: u32 = 78;
pub const _SC_SYMLOOP_MAX: u32 = 79;
pub const _SC_THREAD_CPUTIME: u32 = 80;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 81;
pub const _SC_TIMEOUTS: u32 = 82;
pub const _SC_TRACE: u32 = 83;
pub const _SC_TRACE_EVENT_FILTER: u32 = 84;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 85;
pub const _SC_TRACE_INHERIT: u32 = 86;
pub const _SC_TRACE_LOG: u32 = 87;
pub const _SC_TRACE_NAME_MAX: u32 = 88;
pub const _SC_TRACE_SYS_MAX: u32 = 89;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 90;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 91;
pub const _SC_V7_ILP32_OFF32: u32 = 92;
pub const _SC_V6_ILP32_OFF32: u32 = 92;
pub const _SC_XBS5_ILP32_OFF32: u32 = 92;
pub const _SC_V7_ILP32_OFFBIG: u32 = 93;
pub const _SC_V6_ILP32_OFFBIG: u32 = 93;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 93;
pub const _SC_V7_LP64_OFF64: u32 = 94;
pub const _SC_V6_LP64_OFF64: u32 = 94;
pub const _SC_XBS5_LP64_OFF64: u32 = 94;
pub const _SC_V7_LPBIG_OFFBIG: u32 = 95;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 95;
pub const _SC_XOPEN_CRYPT: u32 = 96;
pub const _SC_XOPEN_ENH_I18N: u32 = 97;
pub const _SC_XOPEN_LEGACY: u32 = 98;
pub const _SC_XOPEN_REALTIME: u32 = 99;
pub const _SC_STREAM_MAX: u32 = 100;
pub const _SC_PRIORITY_SCHEDULING: u32 = 101;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 102;
pub const _SC_XOPEN_SHM: u32 = 103;
pub const _SC_XOPEN_STREAMS: u32 = 104;
pub const _SC_XOPEN_UNIX: u32 = 105;
pub const _SC_XOPEN_VERSION: u32 = 106;
pub const _SC_2_CHAR_TERM: u32 = 107;
pub const _SC_2_C_BIND: u32 = 108;
pub const _SC_2_C_DEV: u32 = 109;
pub const _SC_2_FORT_DEV: u32 = 110;
pub const _SC_2_FORT_RUN: u32 = 111;
pub const _SC_2_LOCALEDEF: u32 = 112;
pub const _SC_2_PBS: u32 = 113;
pub const _SC_2_PBS_ACCOUNTING: u32 = 114;
pub const _SC_2_PBS_CHECKPOINT: u32 = 115;
pub const _SC_2_PBS_LOCATE: u32 = 116;
pub const _SC_2_PBS_MESSAGE: u32 = 117;
pub const _SC_2_PBS_TRACK: u32 = 118;
pub const _SC_2_SW_DEV: u32 = 119;
pub const _SC_2_UPE: u32 = 120;
pub const _SC_2_VERSION: u32 = 121;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: u32 = 122;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: u32 = 123;
pub const _SC_XOPEN_UUCP: u32 = 124;
pub const _SC_LEVEL1_ICACHE_SIZE: u32 = 125;
pub const _SC_LEVEL1_ICACHE_ASSOC: u32 = 126;
pub const _SC_LEVEL1_ICACHE_LINESIZE: u32 = 127;
pub const _SC_LEVEL1_DCACHE_SIZE: u32 = 128;
pub const _SC_LEVEL1_DCACHE_ASSOC: u32 = 129;
pub const _SC_LEVEL1_DCACHE_LINESIZE: u32 = 130;
pub const _SC_LEVEL2_CACHE_SIZE: u32 = 131;
pub const _SC_LEVEL2_CACHE_ASSOC: u32 = 132;
pub const _SC_LEVEL2_CACHE_LINESIZE: u32 = 133;
pub const _SC_LEVEL3_CACHE_SIZE: u32 = 134;
pub const _SC_LEVEL3_CACHE_ASSOC: u32 = 135;
pub const _SC_LEVEL3_CACHE_LINESIZE: u32 = 136;
pub const _SC_LEVEL4_CACHE_SIZE: u32 = 137;
pub const _SC_LEVEL4_CACHE_ASSOC: u32 = 138;
pub const _SC_LEVEL4_CACHE_LINESIZE: u32 = 139;
pub const _SC_POSIX_26_VERSION: u32 = 140;
pub const _PC_LINK_MAX: u32 = 0;
pub const _PC_MAX_CANON: u32 = 1;
pub const _PC_MAX_INPUT: u32 = 2;
pub const _PC_NAME_MAX: u32 = 3;
pub const _PC_PATH_MAX: u32 = 4;
pub const _PC_PIPE_BUF: u32 = 5;
pub const _PC_CHOWN_RESTRICTED: u32 = 6;
pub const _PC_NO_TRUNC: u32 = 7;
pub const _PC_VDISABLE: u32 = 8;
pub const _PC_ASYNC_IO: u32 = 9;
pub const _PC_PRIO_IO: u32 = 10;
pub const _PC_SYNC_IO: u32 = 11;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_2_SYMLINKS: u32 = 13;
pub const _PC_SYMLINK_MAX: u32 = 14;
pub const _PC_ALLOC_SIZE_MIN: u32 = 15;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 16;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 17;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 18;
pub const _PC_REC_XFER_ALIGN: u32 = 19;
pub const _PC_TIMESTAMP_RESOLUTION: u32 = 20;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const PTHREAD_CANCEL_ENABLE: u32 = 0;
pub const PTHREAD_CANCEL_DISABLE: u32 = 1;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 1;
pub const _Z_DEFAULT_HASHMAP_CAPACITY: u32 = 16;
pub const _Z_DEFAULT_INT_MAP_CAPACITY: u32 = 16;
pub const INT_STR_MAP_KEYVALUE_SEPARATOR: u8 = 61u8;
pub const INT_STR_MAP_LIST_SEPARATOR: u8 = 59u8;
pub const Z_SELECTOR_TIME: &[u8; 7] = b"_time=\0";
pub const Z_SELECTOR_QUERY_MATCH: &[u8; 7] = b"_anyke\0";
pub const _Z_KEYEXPR_ADV_PREFIX: &[u8; 5] = b"@adv\0";
pub const _Z_KEYEXPR_PUB: &[u8; 4] = b"pub\0";
pub const _Z_KEYEXPR_SUB: &[u8; 4] = b"sub\0";
pub const _Z_KEYEXPR_UHLC: &[u8; 5] = b"uhlc\0";
pub const _Z_KEYEXPR_EMPTY: &[u8; 2] = b"_\0";
pub const _Z_KEYEXPR_STAR: &[u8; 2] = b"*\0";
pub const _Z_KEYEXPR_STARSTAR: &[u8; 3] = b"**\0";
pub const _Z_ENCODING_ID_DEFAULT: u32 = 0;
pub const Z_RESOURCE_ID_NONE: u32 = 0;
pub const Z_PRIORITIES_NUM: u32 = 8;
pub const ZENOH_ID_SIZE: u32 = 16;
pub const _Z_INTEREST_FLAG_KEYEXPRS: u32 = 1;
pub const _Z_INTEREST_FLAG_SUBSCRIBERS: u32 = 2;
pub const _Z_INTEREST_FLAG_QUERYABLES: u32 = 4;
pub const _Z_INTEREST_FLAG_TOKENS: u32 = 8;
pub const _Z_INTEREST_FLAG_RESTRICTED: u32 = 16;
pub const _Z_INTEREST_FLAG_CURRENT: u32 = 32;
pub const _Z_INTEREST_FLAG_FUTURE: u32 = 64;
pub const _Z_INTEREST_FLAG_AGGREGATE: u32 = 128;
pub const _Z_INTEREST_NOT_FINAL_MASK: u32 = 96;
pub const _Z_DEFAULT_UNICAST_BATCH_SIZE: u32 = 65535;
pub const _Z_DEFAULT_MULTICAST_BATCH_SIZE: u32 = 8192;
pub const _Z_DEFAULT_RESOLUTION_SIZE: u32 = 2;
pub const _Z_MSG_LEN_ENC_SIZE: u32 = 2;
pub const _Z_MID_MASK: u32 = 31;
pub const _Z_FLAGS_MASK: u32 = 224;
pub const _Z_MID_Z_OAM: u32 = 0;
pub const _Z_MID_Z_PUT: u32 = 1;
pub const _Z_MID_Z_DEL: u32 = 2;
pub const _Z_MID_Z_QUERY: u32 = 3;
pub const _Z_MID_Z_REPLY: u32 = 4;
pub const _Z_MID_Z_ERR: u32 = 5;
pub const _Z_FLAG_Z_Z: u32 = 128;
pub const _Z_FLAG_Z_D: u32 = 32;
pub const _Z_FLAG_Z_K: u32 = 128;
pub const _Z_FLAG_Z_R: u32 = 32;
pub const _Z_FLAG_Z_X: u32 = 0;
pub const _Z_FRAG_BUFF_BASE_SIZE: u32 = 128;
pub const _Z_FLAG_Z_E_E: u32 = 64;
pub const _Z_M_DEL_ID: u32 = 2;
pub const _Z_FLAG_Z_D_T: u32 = 32;
pub const _Z_M_PUT_ID: u32 = 1;
pub const _Z_FLAG_Z_P_E: u32 = 64;
pub const _Z_FLAG_Z_P_T: u32 = 32;
pub const _Z_FLAG_Z_Q_C: u32 = 32;
pub const _Z_FLAG_Z_Q_P: u32 = 64;
pub const _Z_FLAG_Z_R_C: u32 = 32;
pub const _Z_EXT_FULL_ID_MASK: u32 = 127;
pub const _Z_EXT_ID_MASK: u32 = 15;
pub const _Z_EXT_ENC_MASK: u32 = 96;
pub const _Z_MSG_EXT_ENC_UNIT: u32 = 0;
pub const _Z_MSG_EXT_ENC_ZINT: u32 = 32;
pub const _Z_MSG_EXT_ENC_ZBUF: u32 = 64;
pub const _Z_MSG_EXT_FLAG_M: u32 = 16;
pub const _Z_MSG_EXT_FLAG_Z: u32 = 128;
pub const _Z_MID_N_OAM: u32 = 31;
pub const _Z_MID_N_DECLARE: u32 = 30;
pub const _Z_MID_N_PUSH: u32 = 29;
pub const _Z_MID_N_REQUEST: u32 = 28;
pub const _Z_MID_N_RESPONSE: u32 = 27;
pub const _Z_MID_N_RESPONSE_FINAL: u32 = 26;
pub const _Z_MID_N_INTEREST: u32 = 25;
pub const _Z_FLAG_N_Z: u32 = 128;
pub const _Z_FLAG_N_DECLARE_I: u32 = 32;
pub const _Z_FLAG_N_INTEREST_CURRENT: u32 = 32;
pub const _Z_FLAG_N_INTEREST_FUTURE: u32 = 64;
pub const _Z_FLAG_N_PUSH_N: u32 = 32;
pub const _Z_FLAG_N_PUSH_M: u32 = 64;
pub const _Z_FLAG_N_REQUEST_N: u32 = 32;
pub const _Z_FLAG_N_REQUEST_M: u32 = 64;
pub const _Z_FLAG_N_RESPONSE_N: u32 = 32;
pub const _Z_FLAG_N_RESPONSE_M: u32 = 64;
pub const _Z_N_QOS_IS_EXPRESS_FLAG: u32 = 16;
pub const TCP_SCHEMA: &[u8; 4] = b"tcp\0";
pub const UDP_SCHEMA: &[u8; 4] = b"udp\0";
pub const LOCATOR_PROTOCOL_SEPARATOR: u8 = 47u8;
pub const LOCATOR_METADATA_SEPARATOR: u8 = 63u8;
pub const ENDPOINT_CONFIG_SEPARATOR: u8 = 35u8;
pub const Z_INFO_PID_KEY: u32 = 0;
pub const Z_INFO_PEER_PID_KEY: u32 = 1;
pub const Z_INFO_ROUTER_PID_KEY: u32 = 2;
pub const _Z_MID_SCOUT: u32 = 1;
pub const _Z_MID_HELLO: u32 = 2;
pub const _Z_MID_T_OAM: u32 = 0;
pub const _Z_MID_T_INIT: u32 = 1;
pub const _Z_MID_T_OPEN: u32 = 2;
pub const _Z_MID_T_CLOSE: u32 = 3;
pub const _Z_MID_T_KEEP_ALIVE: u32 = 4;
pub const _Z_MID_T_FRAME: u32 = 5;
pub const _Z_MID_T_FRAGMENT: u32 = 6;
pub const _Z_MID_T_JOIN: u32 = 7;
pub const _Z_FLAG_T_Z: u32 = 128;
pub const _Z_FLAG_T_SCOUT_I: u32 = 8;
pub const _Z_FLAG_T_HELLO_L: u32 = 32;
pub const _Z_FLAG_T_JOIN_T: u32 = 32;
pub const _Z_FLAG_T_JOIN_S: u32 = 64;
pub const _Z_FLAG_T_INIT_A: u32 = 32;
pub const _Z_FLAG_T_INIT_S: u32 = 64;
pub const _Z_FLAG_T_OPEN_A: u32 = 32;
pub const _Z_FLAG_T_OPEN_T: u32 = 64;
pub const _Z_FLAG_T_FRAME_R: u32 = 32;
pub const _Z_FLAG_T_FRAGMENT_R: u32 = 32;
pub const _Z_FLAG_T_FRAGMENT_M: u32 = 64;
pub const _Z_FLAG_T_CLOSE_S: u32 = 32;
pub const _Z_NO_PATCH: u32 = 0;
pub const _Z_CURRENT_PATCH: u32 = 1;
pub const _Z_CLOSE_GENERIC: u32 = 0;
pub const _Z_CLOSE_UNSUPPORTED: u32 = 1;
pub const _Z_CLOSE_INVALID: u32 = 2;
pub const _Z_CLOSE_MAX_TRANSPORTS: u32 = 3;
pub const _Z_CLOSE_MAX_LINKS: u32 = 4;
pub const _Z_CLOSE_EXPIRED: u32 = 5;
pub const _Z_RES_POOL_INIT_SIZE: u32 = 8;
pub const _Z_MATCHING_LISTENER_CTX_NULL_ID: u32 = 4294967295;
pub const _Z_QUERYABLE_COMPLETE_DEFAULT: u32 = 0;
pub const _Z_QUERYABLE_DISTANCE_DEFAULT: u32 = 0;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = ::std::os::raw::c_schar;
pub type __uint_least8_t = ::std::os::raw::c_uchar;
pub type __int_least16_t = ::std::os::raw::c_short;
pub type __uint_least16_t = ::std::os::raw::c_ushort;
pub type __int_least32_t = ::std::os::raw::c_int;
pub type __uint_least32_t = ::std::os::raw::c_uint;
pub type __int_least64_t = ::std::os::raw::c_long;
pub type __uint_least64_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __uintptr_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__max_align_ll"]
        [::std::mem::offset_of!(max_align_t, __max_align_ll) - 0usize];
    ["Offset of field: max_align_t::__max_align_ld"]
        [::std::mem::offset_of!(max_align_t, __max_align_ld) - 16usize];
};
unsafe extern "C" {
    pub fn __assert(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn __assert_func(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> !;
}
pub type wint_t = ::std::os::raw::c_uint;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
pub type __dev_t = ::std::os::raw::c_short;
pub type __uid_t = ::std::os::raw::c_ushort;
pub type __gid_t = ::std::os::raw::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::std::os::raw::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::std::os::raw::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type _fpos_t = ::std::os::raw::c_long;
pub type __size_t = ::std::os::raw::c_ulong;
pub type _ssize_t = ::std::os::raw::c_long;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::std::os::raw::c_uchar; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<_mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<_mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(_mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: _mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(_mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _mbstate_t"][::std::mem::size_of::<_mbstate_t>() - 8usize];
    ["Alignment of _mbstate_t"][::std::mem::align_of::<_mbstate_t>() - 4usize];
    ["Offset of field: _mbstate_t::__count"][::std::mem::offset_of!(_mbstate_t, __count) - 0usize];
    ["Offset of field: _mbstate_t::__value"][::std::mem::offset_of!(_mbstate_t, __value) - 4usize];
};
pub type _iconv_t = *mut ::std::os::raw::c_void;
pub type __clock_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __clockid_t = ::std::os::raw::c_ulong;
pub type __daddr_t = ::std::os::raw::c_long;
pub type __timer_t = ::std::os::raw::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = ::std::os::raw::c_ushort;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_ulong;
pub type __va_list = __builtin_va_list;
pub type __ULong = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
unsafe extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
unsafe extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::std::os::raw::c_int,
    pub _maxwds: ::std::os::raw::c_int,
    pub _sign: ::std::os::raw::c_int,
    pub _wds: ::std::os::raw::c_int,
    pub _x: [__ULong; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Bigint"][::std::mem::size_of::<_Bigint>() - 32usize];
    ["Alignment of _Bigint"][::std::mem::align_of::<_Bigint>() - 8usize];
    ["Offset of field: _Bigint::_next"][::std::mem::offset_of!(_Bigint, _next) - 0usize];
    ["Offset of field: _Bigint::_k"][::std::mem::offset_of!(_Bigint, _k) - 8usize];
    ["Offset of field: _Bigint::_maxwds"][::std::mem::offset_of!(_Bigint, _maxwds) - 12usize];
    ["Offset of field: _Bigint::_sign"][::std::mem::offset_of!(_Bigint, _sign) - 16usize];
    ["Offset of field: _Bigint::_wds"][::std::mem::offset_of!(_Bigint, _wds) - 20usize];
    ["Offset of field: _Bigint::_x"][::std::mem::offset_of!(_Bigint, _x) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::std::os::raw::c_int,
    pub __tm_min: ::std::os::raw::c_int,
    pub __tm_hour: ::std::os::raw::c_int,
    pub __tm_mday: ::std::os::raw::c_int,
    pub __tm_mon: ::std::os::raw::c_int,
    pub __tm_year: ::std::os::raw::c_int,
    pub __tm_wday: ::std::os::raw::c_int,
    pub __tm_yday: ::std::os::raw::c_int,
    pub __tm_isdst: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __tm"][::std::mem::size_of::<__tm>() - 36usize];
    ["Alignment of __tm"][::std::mem::align_of::<__tm>() - 4usize];
    ["Offset of field: __tm::__tm_sec"][::std::mem::offset_of!(__tm, __tm_sec) - 0usize];
    ["Offset of field: __tm::__tm_min"][::std::mem::offset_of!(__tm, __tm_min) - 4usize];
    ["Offset of field: __tm::__tm_hour"][::std::mem::offset_of!(__tm, __tm_hour) - 8usize];
    ["Offset of field: __tm::__tm_mday"][::std::mem::offset_of!(__tm, __tm_mday) - 12usize];
    ["Offset of field: __tm::__tm_mon"][::std::mem::offset_of!(__tm, __tm_mon) - 16usize];
    ["Offset of field: __tm::__tm_year"][::std::mem::offset_of!(__tm, __tm_year) - 20usize];
    ["Offset of field: __tm::__tm_wday"][::std::mem::offset_of!(__tm, __tm_wday) - 24usize];
    ["Offset of field: __tm::__tm_yday"][::std::mem::offset_of!(__tm, __tm_yday) - 28usize];
    ["Offset of field: __tm::__tm_isdst"][::std::mem::offset_of!(__tm, __tm_isdst) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::std::os::raw::c_void; 32usize],
    pub _dso_handle: [*mut ::std::os::raw::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _on_exit_args"][::std::mem::size_of::<_on_exit_args>() - 520usize];
    ["Alignment of _on_exit_args"][::std::mem::align_of::<_on_exit_args>() - 8usize];
    ["Offset of field: _on_exit_args::_fnargs"]
        [::std::mem::offset_of!(_on_exit_args, _fnargs) - 0usize];
    ["Offset of field: _on_exit_args::_dso_handle"]
        [::std::mem::offset_of!(_on_exit_args, _dso_handle) - 256usize];
    ["Offset of field: _on_exit_args::_fntypes"]
        [::std::mem::offset_of!(_on_exit_args, _fntypes) - 512usize];
    ["Offset of field: _on_exit_args::_is_cxa"]
        [::std::mem::offset_of!(_on_exit_args, _is_cxa) - 516usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::std::os::raw::c_int,
    pub _fns: [::std::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _atexit"][::std::mem::size_of::<_atexit>() - 280usize];
    ["Alignment of _atexit"][::std::mem::align_of::<_atexit>() - 8usize];
    ["Offset of field: _atexit::_next"][::std::mem::offset_of!(_atexit, _next) - 0usize];
    ["Offset of field: _atexit::_ind"][::std::mem::offset_of!(_atexit, _ind) - 8usize];
    ["Offset of field: _atexit::_fns"][::std::mem::offset_of!(_atexit, _fns) - 16usize];
    ["Offset of field: _atexit::_on_exit_args_ptr"]
        [::std::mem::offset_of!(_atexit, _on_exit_args_ptr) - 272usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::std::mem::size_of::<__sbuf>() - 16usize];
    ["Alignment of __sbuf"][::std::mem::align_of::<__sbuf>() - 8usize];
    ["Offset of field: __sbuf::_base"][::std::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::std::mem::offset_of!(__sbuf, _size) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
            arg3: _fpos_t,
            arg4: ::std::os::raw::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::std::os::raw::c_uchar,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::std::mem::size_of::<__sFILE>() - 184usize];
    ["Alignment of __sFILE"][::std::mem::align_of::<__sFILE>() - 8usize];
    ["Offset of field: __sFILE::_p"][::std::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::std::mem::offset_of!(__sFILE, _r) - 8usize];
    ["Offset of field: __sFILE::_w"][::std::mem::offset_of!(__sFILE, _w) - 12usize];
    ["Offset of field: __sFILE::_flags"][::std::mem::offset_of!(__sFILE, _flags) - 16usize];
    ["Offset of field: __sFILE::_file"][::std::mem::offset_of!(__sFILE, _file) - 18usize];
    ["Offset of field: __sFILE::_bf"][::std::mem::offset_of!(__sFILE, _bf) - 24usize];
    ["Offset of field: __sFILE::_lbfsize"][::std::mem::offset_of!(__sFILE, _lbfsize) - 40usize];
    ["Offset of field: __sFILE::_data"][::std::mem::offset_of!(__sFILE, _data) - 48usize];
    ["Offset of field: __sFILE::_cookie"][::std::mem::offset_of!(__sFILE, _cookie) - 56usize];
    ["Offset of field: __sFILE::_read"][::std::mem::offset_of!(__sFILE, _read) - 64usize];
    ["Offset of field: __sFILE::_write"][::std::mem::offset_of!(__sFILE, _write) - 72usize];
    ["Offset of field: __sFILE::_seek"][::std::mem::offset_of!(__sFILE, _seek) - 80usize];
    ["Offset of field: __sFILE::_close"][::std::mem::offset_of!(__sFILE, _close) - 88usize];
    ["Offset of field: __sFILE::_ub"][::std::mem::offset_of!(__sFILE, _ub) - 96usize];
    ["Offset of field: __sFILE::_up"][::std::mem::offset_of!(__sFILE, _up) - 112usize];
    ["Offset of field: __sFILE::_ur"][::std::mem::offset_of!(__sFILE, _ur) - 120usize];
    ["Offset of field: __sFILE::_ubuf"][::std::mem::offset_of!(__sFILE, _ubuf) - 124usize];
    ["Offset of field: __sFILE::_nbuf"][::std::mem::offset_of!(__sFILE, _nbuf) - 127usize];
    ["Offset of field: __sFILE::_lb"][::std::mem::offset_of!(__sFILE, _lb) - 128usize];
    ["Offset of field: __sFILE::_blksize"][::std::mem::offset_of!(__sFILE, _blksize) - 144usize];
    ["Offset of field: __sFILE::_offset"][::std::mem::offset_of!(__sFILE, _offset) - 152usize];
    ["Offset of field: __sFILE::_lock"][::std::mem::offset_of!(__sFILE, _lock) - 160usize];
    ["Offset of field: __sFILE::_mbstate"][::std::mem::offset_of!(__sFILE, _mbstate) - 168usize];
    ["Offset of field: __sFILE::_flags2"][::std::mem::offset_of!(__sFILE, _flags2) - 176usize];
};
pub type __FILE = __sFILE;
unsafe extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::std::os::raw::c_int,
    pub _iobs: *mut __FILE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _glue"][::std::mem::size_of::<_glue>() - 24usize];
    ["Alignment of _glue"][::std::mem::align_of::<_glue>() - 8usize];
    ["Offset of field: _glue::_next"][::std::mem::offset_of!(_glue, _next) - 0usize];
    ["Offset of field: _glue::_niobs"][::std::mem::offset_of!(_glue, _niobs) - 8usize];
    ["Offset of field: _glue::_iobs"][::std::mem::offset_of!(_glue, _iobs) - 16usize];
};
unsafe extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::std::os::raw::c_ushort; 3usize],
    pub _mult: [::std::os::raw::c_ushort; 3usize],
    pub _add: ::std::os::raw::c_ushort,
    pub _rand_next: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _rand48"][::std::mem::size_of::<_rand48>() - 24usize];
    ["Alignment of _rand48"][::std::mem::align_of::<_rand48>() - 8usize];
    ["Offset of field: _rand48::_seed"][::std::mem::offset_of!(_rand48, _seed) - 0usize];
    ["Offset of field: _rand48::_mult"][::std::mem::offset_of!(_rand48, _mult) - 6usize];
    ["Offset of field: _rand48::_add"][::std::mem::offset_of!(_rand48, _add) - 12usize];
    ["Offset of field: _rand48::_rand_next"][::std::mem::offset_of!(_rand48, _rand_next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: ::std::os::raw::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _mprec"][::std::mem::size_of::<_mprec>() - 32usize];
    ["Alignment of _mprec"][::std::mem::align_of::<_mprec>() - 8usize];
    ["Offset of field: _mprec::_result"][::std::mem::offset_of!(_mprec, _result) - 0usize];
    ["Offset of field: _mprec::_result_k"][::std::mem::offset_of!(_mprec, _result_k) - 8usize];
    ["Offset of field: _mprec::_p5s"][::std::mem::offset_of!(_mprec, _p5s) - 16usize];
    ["Offset of field: _mprec::_freelist"][::std::mem::offset_of!(_mprec, _freelist) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut ::std::os::raw::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [::std::os::raw::c_char; 8usize],
    pub _getdate_err: ::std::os::raw::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _misc_reent"][::std::mem::size_of::<_misc_reent>() - 88usize];
    ["Alignment of _misc_reent"][::std::mem::align_of::<_misc_reent>() - 8usize];
    ["Offset of field: _misc_reent::_strtok_last"]
        [::std::mem::offset_of!(_misc_reent, _strtok_last) - 0usize];
    ["Offset of field: _misc_reent::_mblen_state"]
        [::std::mem::offset_of!(_misc_reent, _mblen_state) - 8usize];
    ["Offset of field: _misc_reent::_wctomb_state"]
        [::std::mem::offset_of!(_misc_reent, _wctomb_state) - 16usize];
    ["Offset of field: _misc_reent::_mbtowc_state"]
        [::std::mem::offset_of!(_misc_reent, _mbtowc_state) - 24usize];
    ["Offset of field: _misc_reent::_l64a_buf"]
        [::std::mem::offset_of!(_misc_reent, _l64a_buf) - 32usize];
    ["Offset of field: _misc_reent::_getdate_err"]
        [::std::mem::offset_of!(_misc_reent, _getdate_err) - 40usize];
    ["Offset of field: _misc_reent::_mbrlen_state"]
        [::std::mem::offset_of!(_misc_reent, _mbrlen_state) - 44usize];
    ["Offset of field: _misc_reent::_mbrtowc_state"]
        [::std::mem::offset_of!(_misc_reent, _mbrtowc_state) - 52usize];
    ["Offset of field: _misc_reent::_mbsrtowcs_state"]
        [::std::mem::offset_of!(_misc_reent, _mbsrtowcs_state) - 60usize];
    ["Offset of field: _misc_reent::_wcrtomb_state"]
        [::std::mem::offset_of!(_misc_reent, _wcrtomb_state) - 68usize];
    ["Offset of field: _misc_reent::_wcsrtombs_state"]
        [::std::mem::offset_of!(_misc_reent, _wcsrtombs_state) - 76usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::std::os::raw::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::std::os::raw::c_int,
    pub _emergency: *mut ::std::os::raw::c_char,
    pub _reserved_0: ::std::os::raw::c_int,
    pub _reserved_1: ::std::os::raw::c_int,
    pub _locale: *mut __locale_t,
    pub _mp: *mut _mprec,
    pub __cleanup: ::std::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: ::std::os::raw::c_int,
    pub _cvtlen: ::std::os::raw::c_int,
    pub _cvtbuf: *mut ::std::os::raw::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut ::std::os::raw::c_char,
    pub _sig_func: *mut ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub _reserved_6: *mut _atexit,
    pub _reserved_7: _atexit,
    pub _reserved_8: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _reent"][::std::mem::size_of::<_reent>() - 464usize];
    ["Alignment of _reent"][::std::mem::align_of::<_reent>() - 8usize];
    ["Offset of field: _reent::_errno"][::std::mem::offset_of!(_reent, _errno) - 0usize];
    ["Offset of field: _reent::_stdin"][::std::mem::offset_of!(_reent, _stdin) - 8usize];
    ["Offset of field: _reent::_stdout"][::std::mem::offset_of!(_reent, _stdout) - 16usize];
    ["Offset of field: _reent::_stderr"][::std::mem::offset_of!(_reent, _stderr) - 24usize];
    ["Offset of field: _reent::_inc"][::std::mem::offset_of!(_reent, _inc) - 32usize];
    ["Offset of field: _reent::_emergency"][::std::mem::offset_of!(_reent, _emergency) - 40usize];
    ["Offset of field: _reent::_reserved_0"][::std::mem::offset_of!(_reent, _reserved_0) - 48usize];
    ["Offset of field: _reent::_reserved_1"][::std::mem::offset_of!(_reent, _reserved_1) - 52usize];
    ["Offset of field: _reent::_locale"][::std::mem::offset_of!(_reent, _locale) - 56usize];
    ["Offset of field: _reent::_mp"][::std::mem::offset_of!(_reent, _mp) - 64usize];
    ["Offset of field: _reent::__cleanup"][::std::mem::offset_of!(_reent, __cleanup) - 72usize];
    ["Offset of field: _reent::_gamma_signgam"]
        [::std::mem::offset_of!(_reent, _gamma_signgam) - 80usize];
    ["Offset of field: _reent::_cvtlen"][::std::mem::offset_of!(_reent, _cvtlen) - 84usize];
    ["Offset of field: _reent::_cvtbuf"][::std::mem::offset_of!(_reent, _cvtbuf) - 88usize];
    ["Offset of field: _reent::_r48"][::std::mem::offset_of!(_reent, _r48) - 96usize];
    ["Offset of field: _reent::_localtime_buf"]
        [::std::mem::offset_of!(_reent, _localtime_buf) - 104usize];
    ["Offset of field: _reent::_asctime_buf"]
        [::std::mem::offset_of!(_reent, _asctime_buf) - 112usize];
    ["Offset of field: _reent::_sig_func"][::std::mem::offset_of!(_reent, _sig_func) - 120usize];
    ["Offset of field: _reent::_reserved_6"]
        [::std::mem::offset_of!(_reent, _reserved_6) - 128usize];
    ["Offset of field: _reent::_reserved_7"]
        [::std::mem::offset_of!(_reent, _reserved_7) - 136usize];
    ["Offset of field: _reent::_reserved_8"]
        [::std::mem::offset_of!(_reent, _reserved_8) - 416usize];
    ["Offset of field: _reent::__sf"][::std::mem::offset_of!(_reent, __sf) - 440usize];
    ["Offset of field: _reent::_misc"][::std::mem::offset_of!(_reent, _misc) - 448usize];
    ["Offset of field: _reent::_signal_buf"]
        [::std::mem::offset_of!(_reent, _signal_buf) - 456usize];
};
unsafe extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
unsafe extern "C" {
    pub static mut _impure_data: _reent;
}
unsafe extern "C" {
    pub fn __getreent() -> *mut _reent;
}
unsafe extern "C" {
    pub static mut __atexit: *mut _atexit;
}
unsafe extern "C" {
    pub static mut __atexit0: _atexit;
}
unsafe extern "C" {
    pub static mut __stdio_exit_handler: ::std::option::Option<unsafe extern "C" fn()>;
}
unsafe extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
unsafe extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::std::os::raw::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::std::os::raw::c_int;
}
pub type locale_t = *mut __locale_t;
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
unsafe extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
unsafe extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlwr(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strupr(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__signo: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
unsafe extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        arg1: *mut ::std::os::raw::c_void,
        _size: ::std::os::raw::c_ulong,
        _n: ::std::os::raw::c_ulong,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        arg1: *const ::std::os::raw::c_void,
        _size: ::std::os::raw::c_ulong,
        _n: ::std::os::raw::c_ulong,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fopen(
        _name: *const ::std::os::raw::c_char,
        _type: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
unsafe extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn diprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iprintf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn iscanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vdiprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn viprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn viscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsiscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fmemopen(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize) -> *mut FILE;
}
unsafe extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
unsafe extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
unsafe extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::std::os::raw::c_char,
        _new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::std::os::raw::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funopen(
        __cookie: *const ::std::os::raw::c_void,
        __readfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::std::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::std::os::raw::c_void,
        __readfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::std::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::std::os::raw::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::std::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type z_result_t = i8;
pub const _z_res_t__Z_RES_OK: _z_res_t = 0;
pub const _z_res_t_Z_OK: _z_res_t = 0;
pub const _z_res_t__Z_RES_CHANNEL_CLOSED: _z_res_t = 1;
pub const _z_res_t_Z_CHANNEL_DISCONNECTED: _z_res_t = 1;
pub const _z_res_t__Z_RES_CHANNEL_NODATA: _z_res_t = 2;
pub const _z_res_t_Z_CHANNEL_NODATA: _z_res_t = 2;
pub const _z_res_t__Z_NO_DATA_PROCESSED: _z_res_t = 3;
pub const _z_res_t_Z_NO_DATA_PROCESSED: _z_res_t = 3;
pub const _z_res_t__Z_ERR_MESSAGE_DESERIALIZATION_FAILED: _z_res_t = -119;
pub const _z_res_t__Z_ERR_MESSAGE_SERIALIZATION_FAILED: _z_res_t = -118;
pub const _z_res_t__Z_ERR_MESSAGE_UNEXPECTED: _z_res_t = -117;
pub const _z_res_t__Z_ERR_MESSAGE_FLAG_UNEXPECTED: _z_res_t = -116;
pub const _z_res_t__Z_ERR_MESSAGE_ZENOH_DECLARATION_UNKNOWN: _z_res_t = -115;
pub const _z_res_t__Z_ERR_MESSAGE_ZENOH_UNKNOWN: _z_res_t = -114;
pub const _z_res_t__Z_ERR_MESSAGE_TRANSPORT_UNKNOWN: _z_res_t = -113;
pub const _z_res_t__Z_ERR_MESSAGE_EXTENSION_MANDATORY_AND_UNKNOWN: _z_res_t = -112;
pub const _z_res_t__Z_ERR_ENTITY_DECLARATION_FAILED: _z_res_t = -111;
pub const _z_res_t__Z_ERR_ENTITY_UNKNOWN: _z_res_t = -110;
pub const _z_res_t__Z_ERR_KEYEXPR_UNKNOWN: _z_res_t = -109;
pub const _z_res_t__Z_ERR_KEYEXPR_NOT_MATCH: _z_res_t = -108;
pub const _z_res_t__Z_ERR_QUERY_NOT_MATCH: _z_res_t = -107;
pub const _z_res_t__Z_ERR_TRANSPORT_NOT_AVAILABLE: _z_res_t = -103;
pub const _z_res_t__Z_ERR_TRANSPORT_OPEN_FAILED: _z_res_t = -102;
pub const _z_res_t__Z_ERR_TRANSPORT_OPEN_SN_RESOLUTION: _z_res_t = -101;
pub const _z_res_t__Z_ERR_TRANSPORT_TX_FAILED: _z_res_t = -100;
pub const _z_res_t__Z_ERR_TRANSPORT_RX_FAILED: _z_res_t = -99;
pub const _z_res_t__Z_ERR_TRANSPORT_NO_SPACE: _z_res_t = -98;
pub const _z_res_t__Z_ERR_TRANSPORT_NOT_ENOUGH_BYTES: _z_res_t = -97;
pub const _z_res_t__Z_ERR_CONFIG_FAILED_INSERT: _z_res_t = -95;
pub const _z_res_t__Z_ERR_CONFIG_UNSUPPORTED_CLIENT_MULTICAST: _z_res_t = -94;
pub const _z_res_t__Z_ERR_CONFIG_UNSUPPORTED_PEER_UNICAST: _z_res_t = -93;
pub const _z_res_t__Z_ERR_CONFIG_LOCATOR_SCHEMA_UNKNOWN: _z_res_t = -92;
pub const _z_res_t__Z_ERR_CONFIG_LOCATOR_INVALID: _z_res_t = -91;
pub const _z_res_t__Z_ERR_CONFIG_INVALID_MODE: _z_res_t = -90;
pub const _z_res_t__Z_ERR_SCOUT_NO_RESULTS: _z_res_t = -87;
pub const _z_res_t__Z_ERR_SYSTEM_GENERIC: _z_res_t = -80;
pub const _z_res_t__Z_ERR_SYSTEM_TASK_FAILED: _z_res_t = -79;
pub const _z_res_t__Z_ERR_SYSTEM_OUT_OF_MEMORY: _z_res_t = -78;
pub const _z_res_t__Z_ERR_CONNECTION_CLOSED: _z_res_t = -77;
pub const _z_res_t__Z_ERR_DID_NOT_READ: _z_res_t = -76;
pub const _z_res_t__Z_ERR_INVALID: _z_res_t = -75;
pub const _z_res_t_Z_EINVAL: _z_res_t = -75;
pub const _z_res_t__Z_ERR_OVERFLOW: _z_res_t = -74;
pub const _z_res_t__Z_ERR_SESSION_CLOSED: _z_res_t = -73;
pub const _z_res_t_Z_EDESERIALIZE: _z_res_t = -72;
pub const _z_res_t_Z_ETIMEDOUT: _z_res_t = -71;
pub const _z_res_t__Z_ERR_GENERIC: _z_res_t = -128;
pub type _z_res_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn __locale_mb_cur_max() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoff(__nptr: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn getenv(__string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _findenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn malloc(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
unsafe extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
unsafe extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realloc(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocarray(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocf(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realpath(
        path: *const ::std::os::raw::c_char,
        resolved_path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rpmatch(response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn strtod(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn system(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn a64l(__input: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn l64a(__input: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::std::os::raw::c_void),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn setenv(
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
unsafe extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn setstate(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn strtoll(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn cfree(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn unsetenv(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __eprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
        arg4: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::std::os::raw::c_void,
        _compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int);
}
pub type esp_err_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes\n\n This function finds the error code in a pre-generated lookup-table and\n returns its string representation.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes\n\n This function finds the error code in a pre-generated lookup-table of\n esp_err_t errors and returns its string representation. If the error code\n is not found then it is attempted to be found among system errors.\n\n The function is generated by the Python script\n tools/gen_esp_err_to_name.py which should be run each time an esp_err_t\n error is modified, created or removed from the IDF project.\n\n @param code esp_err_t error code\n @param[out] buf buffer where the error message should be written\n @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte).\n @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
#[doc = " Function prototype for interrupt handler function"]
pub type intr_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
#[doc = " Handle to an interrupt handler"]
pub type intr_handle_t = *mut intr_handle_data_t;
#[doc = "< Install the peripheral interrupt to ANY CPU core, decided by on which CPU the interrupt allocator is running"]
pub const esp_intr_cpu_affinity_t_ESP_INTR_CPU_AFFINITY_AUTO: esp_intr_cpu_affinity_t = 0;
#[doc = "< Install the peripheral interrupt to CPU core 0"]
pub const esp_intr_cpu_affinity_t_ESP_INTR_CPU_AFFINITY_0: esp_intr_cpu_affinity_t = 1;
#[doc = "< Install the peripheral interrupt to CPU core 1"]
pub const esp_intr_cpu_affinity_t_ESP_INTR_CPU_AFFINITY_1: esp_intr_cpu_affinity_t = 2;
#[doc = " @brief Interrupt CPU core affinity\n\n This type specify the CPU core that the peripheral interrupt is connected to."]
pub type esp_intr_cpu_affinity_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Mark an interrupt as a shared interrupt\n\n This will mark a certain interrupt on the specified CPU as\n an interrupt that can be used to hook shared interrupt handlers\n to.\n\n @param intno The number of the interrupt (0-31)\n @param cpu CPU on which the interrupt should be marked as shared (0 or 1)\n @param is_in_iram Shared interrupt is for handlers that reside in IRAM and\n                   the int can be left enabled while the flash cache is disabled.\n\n @return ESP_ERR_INVALID_ARG if cpu or intno is invalid\n         ESP_OK on success"]
    pub fn esp_intr_mark_shared(
        intno: ::std::os::raw::c_int,
        cpu: ::std::os::raw::c_int,
        is_in_iram: bool,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Reserve an interrupt to be used outside of this framework\n\n This will mark a certain interrupt on the specified CPU as\n reserved, not to be allocated for any reason.\n\n @param intno The number of the interrupt (0-31)\n @param cpu CPU on which the interrupt should be marked as shared (0 or 1)\n\n @return ESP_ERR_INVALID_ARG if cpu or intno is invalid\n         ESP_OK on success"]
    pub fn esp_intr_reserve(intno: ::std::os::raw::c_int, cpu: ::std::os::raw::c_int) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters.\n\n This finds an interrupt that matches the restrictions as given in the flags\n parameter, maps the given interrupt source to it and hooks up the given\n interrupt handler (with optional argument) as well. If needed, it can return\n a handle for the interrupt as well.\n\n The interrupt will always be allocated on the core that runs this function.\n\n If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or\n RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned.\n\n @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux\n               sources, as defined in soc/soc.h, or one of the internal\n               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header.\n @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the\n               choice of interrupts that this routine can choose from. If this value\n               is 0, it will default to allocating a non-shared interrupt of level\n               1, 2 or 3. If ESP_INTR_FLAG_SHARED mask is provided, a shared interrupt of\n               the given level will be allocated (or level 1 if not specified).\n               Setting ESP_INTR_FLAG_INTRDISABLED will return from this function with the\n               interrupt disabled.\n @param handler The interrupt handler. Must be NULL when an interrupt of level >3\n               is requested, because these types of interrupts aren't C-callable.\n @param arg    Optional argument for passed to the interrupt handler\n @param ret_handle Pointer to an intr_handle_t to store a handle that can later be\n               used to request details or free the interrupt. Can be NULL if no handle\n               is required.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags\n         ESP_OK on success"]
    pub fn esp_intr_alloc(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        handler: intr_handler_t,
        arg: *mut ::std::os::raw::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters, including an interrupt status register.\n\n\n This essentially does the same as esp_intr_alloc, but allows specifying a register and mask\n combo. For shared interrupts, the handler is only called if a read from the specified\n register, ANDed with the mask, returns non-zero. By passing an interrupt status register\n address and a fitting mask, this can be used to accelerate interrupt handling in the case\n a shared interrupt is triggered; by checking the interrupt statuses first, the code can\n decide which ISRs can be skipped\n\n @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux\n               sources, as defined in soc/soc.h, or one of the internal\n               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header.\n @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the\n               choice of interrupts that this routine can choose from. If this value\n               is 0, it will default to allocating a non-shared interrupt of level\n               1, 2 or 3. If ESP_INTR_FLAG_SHARED mask is provided, a shared interrupt of\n               the given level will be allocated (or level 1 if not specified).\n               Setting ESP_INTR_FLAG_INTRDISABLED will return from this function with the\n               interrupt disabled.\n @param intrstatusreg The address of an interrupt status register\n @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits\n               that are 1 in the mask set, the ISR will be called. If not, it will be\n               skipped.\n @param handler The interrupt handler. Must be NULL when an interrupt of level >3\n               is requested, because these types of interrupts aren't C-callable.\n @param arg    Optional argument for passed to the interrupt handler\n @param ret_handle Pointer to an intr_handle_t to store a handle that can later be\n               used to request details or free the interrupt. Can be NULL if no handle\n               is required.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags\n         ESP_OK on success"]
    pub fn esp_intr_alloc_intrstatus(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut ::std::os::raw::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters that can be bound to an existing interrupt handler.\n\n\n This function does the same as esp_intr_alloc, but allows specifying a previously allocated handler as\n the interrupt to share with the given source. This can be very handy to treat two pre-determined interrupt\n sources in the same interrupt handler. The interrupt will be allocated on the same core as the given\n `shared_handle`. Moreover, make sure to specify the same interrupt level as the one being used by `shared_handle`\n to prevent any failure from this function.\n\n @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux\n               sources, as defined in soc/soc.h, or one of the internal\n               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header.\n @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the\n               choice of interrupts that this routine can choose from. If this value\n               is 0, it will default to allocating a non-shared interrupt of level\n               1, 2 or 3. If ESP_INTR_FLAG_SHARED mask is provided, a shared interrupt of\n               the given level will be allocated (or level 1 if not specified).\n               Setting ESP_INTR_FLAG_INTRDISABLED will return from this function with the\n               interrupt disabled.\n @param handler The interrupt handler. Must be NULL when an interrupt of level >3\n               is requested, because these types of interrupts aren't C-callable.\n @param arg    Optional argument for passed to the interrupt handler\n @param shared_handle Previously allocated interrupt to share the CPU interrupt line with. If NULL,\n               calling this function equivalent to esp_intr_alloc, else, ESP_INTR_FLAG_SHARED must\n               be provided in the flags parameter.\n @param ret_handle Pointer to an intr_handle_t to store a handle that can later be\n               used to request details or free the interrupt. Can be NULL if no handle\n               is required.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_ERR_NOT_FOUND No free interrupt found with the specified flasg or the given level is different\n                           from the one assigned to the share_handle parameter.\n         ESP_OK on success"]
    pub fn esp_intr_alloc_bind(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        handler: intr_handler_t,
        arg: *mut ::std::os::raw::c_void,
        shared_handle: intr_handle_t,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters, including an interrupt status register, that can\n        be bound to an existing interrupt handler\n\n\n This function does the same as esp_intr_alloc_intrstatus, but allows specifying a previously allocated handler as\n the interrupt to share with the given source. This can be very handy to treat two pre-determined interrupt\n sources in the same interrupt handler. The interrupt will be allocated on the same core as the given\n `shared_handle`. Moreover, make sure to specify the same interrupt level as the one being used by `shared_handle`\n to prevent any failure from this function.\n\n @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux\n               sources, as defined in soc/soc.h, or one of the internal\n               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header.\n @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the\n               choice of interrupts that this routine can choose from. If this value\n               is 0, it will default to allocating a non-shared interrupt of level\n               1, 2 or 3. If ESP_INTR_FLAG_SHARED mask is provided, a shared interrupt of\n               the given level will be allocated (or level 1 if not specified).\n               Setting ESP_INTR_FLAG_INTRDISABLED will return from this function with the\n               interrupt disabled.\n @param intrstatusreg The address of an interrupt status register\n @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits\n               that are 1 in the mask set, the ISR will be called. If not, it will be\n               skipped.\n @param handler The interrupt handler. Must be NULL when an interrupt of level >3\n               is requested, because these types of interrupts aren't C-callable.\n @param arg    Optional argument for passed to the interrupt handler\n @param shared_handle Previously allocated interrupt to share the CPU interrupt line with. If NULL,\n               calling this function equivalent to esp_intr_alloc, else, ESP_INTR_FLAG_SHARED must\n               be provided in the flags parameter.\n @param ret_handle Pointer to an intr_handle_t to store a handle that can later be\n               used to request details or free the interrupt. Can be NULL if no handle\n               is required.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_ERR_NOT_FOUND No free interrupt found with the specified flasg or the given level is different\n                           from the one assigned to the share_handle parameter.\n         ESP_OK on success"]
    pub fn esp_intr_alloc_intrstatus_bind(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut ::std::os::raw::c_void,
        shared_handle: intr_handle_t,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Disable and free an interrupt.\n\n Use an interrupt handle to disable the interrupt and release the resources associated with it.\n If the current core is not the core that registered this interrupt, this routine will be assigned to\n the core that allocated this interrupt, blocking and waiting until the resource is successfully released.\n\n @note\n When the handler shares its source with other handlers, the interrupt status\n bits it's responsible for should be managed properly before freeing it. see\n ``esp_intr_disable`` for more details. Please do not call this function in ``esp_ipc_call_blocking``.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return ESP_ERR_INVALID_ARG the handle is NULL\n         ESP_FAIL failed to release this handle\n         ESP_OK on success"]
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get CPU number an interrupt is tied to\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return The core number where the interrupt is allocated"]
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get the allocated interrupt for a certain handle\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return The interrupt number"]
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Disable the interrupt associated with the handle\n\n @note\n 1. For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the\n CPU the interrupt is allocated on. Other interrupts have no such restriction.\n 2. When several handlers sharing a same interrupt source, interrupt status bits, which are\n handled in the handler to be disabled, should be masked before the disabling, or handled\n in other enabled interrupts properly. Miss of interrupt status handling will cause infinite\n interrupt calls and finally system crash.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_OK on success"]
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Enable the interrupt associated with the handle\n\n @note For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the\n       CPU the interrupt is allocated on. Other interrupts have no such restriction.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_OK on success"]
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the \"in IRAM\" status of the handler.\n\n @note Does not work on shared interrupts.\n\n @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus\n @param is_in_iram Whether the handler associated with this handle resides in IRAM.\n                   Handlers residing in IRAM can be called when cache is disabled.\n\n @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid.\n         ESP_OK on success"]
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Disable interrupts that aren't specifically marked as running from IRAM"]
    pub fn esp_intr_noniram_disable();
}
unsafe extern "C" {
    #[doc = " @brief Re-enable interrupts disabled by esp_intr_noniram_disable"]
    pub fn esp_intr_noniram_enable();
}
unsafe extern "C" {
    #[doc = " @brief enable the interrupt source based on its number\n @param inum interrupt number from 0 to 31"]
    pub fn esp_intr_enable_source(inum: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief disable the interrupt source based on its number\n @param inum interrupt number from 0 to 31"]
    pub fn esp_intr_disable_source(inum: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Dump the status of allocated interrupts\n @param stream  The stream to dump to, if NULL then stdout is used\n @return ESP_OK on success"]
    pub fn esp_intr_dump(stream: *mut FILE) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Check if the given pointer is in the safe ISR area.\n In other words, make sure that the pointer's content is accessible at\n any time, regardless of the cache status\n\n @param ptr Pointer to check\n\n @return true if `ptr` points to ISR area, false else"]
    pub fn esp_intr_ptr_in_isr_region(ptr: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    pub static Xthal_rev_no: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_save_extra(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_extra(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cpregs(base: *mut ::std::os::raw::c_void, arg1: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn xthal_restore_cpregs(base: *mut ::std::os::raw::c_void, arg1: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn xthal_save_cp0(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp1(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp2(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp3(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp4(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp5(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp6(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_save_cp7(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp0(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp1(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp2(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp3(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp4(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp5(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp6(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_restore_cp7(base: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut ::std::os::raw::c_void; 8usize];
}
unsafe extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut ::std::os::raw::c_void; 8usize];
}
unsafe extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut ::std::os::raw::c_void; 8usize];
}
unsafe extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut ::std::os::raw::c_void; 8usize];
}
unsafe extern "C" {
    pub static Xthal_extra_size: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_extra_align: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cpregs_size: [::std::os::raw::c_uint; 8usize];
}
unsafe extern "C" {
    pub static Xthal_cpregs_align: [::std::os::raw::c_uint; 8usize];
}
unsafe extern "C" {
    pub static Xthal_all_extra_size: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_all_extra_align: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_names: [*const ::std::os::raw::c_char; 8usize];
}
unsafe extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub static Xthal_num_coprocessors: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_num: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_max: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_num_aregs: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_num_aregs_log2: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_icache_linewidth: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_dcache_linewidth: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_icache_linesize: ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub static Xthal_dcache_linesize: ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub static Xthal_icache_size: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_dcache_size: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_dcache_is_writeback: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn xthal_icache_region_invalidate(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_region_invalidate(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_region_writeback(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_region_writeback_inv(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_icache_sync();
}
unsafe extern "C" {
    pub fn xthal_dcache_sync();
}
unsafe extern "C" {
    pub fn xthal_icache_get_ways() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_icache_set_ways(ways: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_dcache_get_ways() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_dcache_set_ways(ways: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_cache_coherence_on();
}
unsafe extern "C" {
    pub fn xthal_cache_coherence_off();
}
unsafe extern "C" {
    pub fn xthal_cache_coherence_optin();
}
unsafe extern "C" {
    pub fn xthal_cache_coherence_optout();
}
unsafe extern "C" {
    pub fn xthal_get_cache_prefetch() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_cache_prefetch_long(
        arg1: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static Xthal_debug_configured: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_soft_break(addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut ::std::os::raw::c_void, arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut ::std::os::raw::c_uchar,
        tgt_addr: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_memcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn xthal_bcopy(
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut ::std::os::raw::c_int,
        test_val: ::std::os::raw::c_int,
        compare_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static Xthal_release_major: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_release_minor: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_release_name: *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static Xthal_release_internal: *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static Xthal_memory_order: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_windowed: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_density: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_booleans: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_loops: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_nsa: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_minmax: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_sext: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_clamps: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_mac16: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_mul16: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_fp: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_speculation: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_threadptr: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_pif: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_writebuffer_entries: ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub static Xthal_build_unique_id: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_hw_configid0: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_hw_configid1: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_hw_release_major: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_hw_release_minor: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_hw_release_name: *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static Xthal_hw_release_internal: *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn xthal_clear_regcached_code();
}
unsafe extern "C" {
    pub fn xthal_window_spill();
}
unsafe extern "C" {
    pub fn xthal_validate_cp(arg1: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn xthal_invalidate_cp(arg1: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn xthal_set_cpenable(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_get_cpenable() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_num_intlevels: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_interrupts: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_excm_level: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_intlevel_mask: [::std::os::raw::c_uint; 16usize];
}
unsafe extern "C" {
    pub static Xthal_intlevel_andbelow_mask: [::std::os::raw::c_uint; 16usize];
}
unsafe extern "C" {
    pub static Xthal_intlevel: [::std::os::raw::c_uchar; 32usize];
}
unsafe extern "C" {
    pub static Xthal_inttype: [::std::os::raw::c_uchar; 32usize];
}
unsafe extern "C" {
    pub static Xthal_inttype_mask: [::std::os::raw::c_uint; 11usize];
}
unsafe extern "C" {
    pub static Xthal_timer_interrupt: [::std::os::raw::c_int; 4usize];
}
unsafe extern "C" {
    pub fn xthal_get_intenable() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_intenable(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_get_interrupt() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_intset(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_set_intclear(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub static Xthal_num_ibreak: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static Xthal_num_dbreak: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static Xthal_have_ccount: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_ccompare: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn xthal_get_ccount() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_ccompare(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_get_ccompare(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_have_prid: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_exceptions: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_xea_version: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_interrupts: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_highlevel_interrupts: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_nmi: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn xthal_get_prid() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_int_enable(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_int_disable(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_int_vpri(
        intnum: ::std::os::raw::c_int,
        vpri: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_get_int_vpri(intnum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_get_vpri_locklevel() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_vpri(vpri: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_get_vpri() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_vpri_lock() -> ::std::os::raw::c_uint;
}
pub type XtHalVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub static mut Xthal_tram_pending: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static mut Xthal_tram_enabled: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static mut Xthal_tram_sync: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_tram_pending_to_service() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_tram_done(serviced_mask: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_tram_set_sync(
        intnum: ::std::os::raw::c_int,
        sync: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
unsafe extern "C" {
    pub static Xthal_num_instrom: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_instram: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_datarom: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_dataram: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_num_xlmi: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_instrom_vaddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_instrom_paddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_instrom_size: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_instram_vaddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_instram_paddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_instram_size: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_datarom_vaddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_datarom_paddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_datarom_size: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_dataram_vaddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_dataram_paddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_dataram_size: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_xlmi_vaddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_xlmi_paddr: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_xlmi_size: [::std::os::raw::c_uint; 0usize];
}
unsafe extern "C" {
    pub static Xthal_icache_setwidth: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_dcache_setwidth: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_icache_ways: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_dcache_ways: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_icache_line_lockable: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_dcache_line_lockable: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn xthal_get_cacheattr() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_get_icacheattr() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_get_dcacheattr() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn xthal_set_cacheattr(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_set_icacheattr(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_set_dcacheattr(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        cattr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_icache_enable();
}
unsafe extern "C" {
    pub fn xthal_dcache_enable();
}
unsafe extern "C" {
    pub fn xthal_icache_disable();
}
unsafe extern "C" {
    pub fn xthal_dcache_disable();
}
unsafe extern "C" {
    pub fn xthal_icache_all_invalidate();
}
unsafe extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
unsafe extern "C" {
    pub fn xthal_dcache_all_writeback();
}
unsafe extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
unsafe extern "C" {
    pub fn xthal_icache_all_unlock();
}
unsafe extern "C" {
    pub fn xthal_dcache_all_unlock();
}
unsafe extern "C" {
    pub fn xthal_icache_region_lock(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_region_lock(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_icache_region_unlock(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_region_unlock(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_icache_hugerange_invalidate(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_icache_hugerange_unlock(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_hugerange_invalidate(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_hugerange_unlock(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_hugerange_writeback(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_dcache_hugerange_writeback_inv(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn xthal_memep_inject_error(
        addr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub static Xthal_have_spanning_way: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_identity_map: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_mimic_cacheattr: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_xlt_cacheattr: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_cacheattr: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_have_tlbs: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_asid_bits: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_asid_kernel: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_rings: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_ring_bits: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_sr_bits: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_ca_bits: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_mmu_max_pte_page_size: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_mmu_min_pte_page_size: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_itlb_way_bits: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_itlb_ways: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_itlb_arf_ways: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_dtlb_way_bits: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_dtlb_ways: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_dtlb_arf_ways: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn xthal_static_v2p(
        vaddr: ::std::os::raw::c_uint,
        paddrp: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_static_p2v(
        paddr: ::std::os::raw::c_uint,
        vaddrp: *mut ::std::os::raw::c_uint,
        cached: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_region_translation(
        vaddr: *mut ::std::os::raw::c_void,
        paddr: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        cache_atr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_v2p(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_uint,
        arg4: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_invalidate_region(addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_set_region_translation_raw(
        vaddr: *mut ::std::os::raw::c_void,
        paddr: *mut ::std::os::raw::c_void,
        cattr: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xthal_MPU_entry {
    pub as_: u32,
    pub at: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xthal_MPU_entry"][::std::mem::size_of::<xthal_MPU_entry>() - 8usize];
    ["Alignment of xthal_MPU_entry"][::std::mem::align_of::<xthal_MPU_entry>() - 4usize];
    ["Offset of field: xthal_MPU_entry::as_"]
        [::std::mem::offset_of!(xthal_MPU_entry, as_) - 0usize];
    ["Offset of field: xthal_MPU_entry::at"][::std::mem::offset_of!(xthal_MPU_entry, at) - 4usize];
};
unsafe extern "C" {
    pub static Xthal_mpu_bgmap: [xthal_MPU_entry; 0usize];
}
unsafe extern "C" {
    pub fn xthal_is_kernel_readable(accessRights: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_kernel_writeable(accessRights: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_kernel_executable(accessRights: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_user_readable(accessRights: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_user_writeable(accessRights: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_user_executable(accessRights: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_encode_memory_type(x: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_is_cacheable(memoryType: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_writeback(memoryType: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_is_device(memoryType: u32) -> i32;
}
unsafe extern "C" {
    pub fn xthal_read_map(entries: *mut xthal_MPU_entry) -> i32;
}
unsafe extern "C" {
    pub fn xthal_write_map(entries: *const xthal_MPU_entry, n: u32);
}
unsafe extern "C" {
    pub fn xthal_check_map(entries: *const xthal_MPU_entry, n: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_get_entry_for_address(
        vaddr: *mut ::std::os::raw::c_void,
        infgmap: *mut i32,
    ) -> xthal_MPU_entry;
}
unsafe extern "C" {
    pub fn xthal_calc_cacheadrdis(e: *const xthal_MPU_entry, n: u32) -> u32;
}
unsafe extern "C" {
    pub fn xthal_mpu_set_region_attribute(
        vaddr: *mut ::std::os::raw::c_void,
        size: usize,
        accessRights: i32,
        memoryType: i32,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn xthal_read_background_map(entries: *mut xthal_MPU_entry) -> i32;
}
unsafe extern "C" {
    pub static Xthal_cp_id_FPU: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_FPU: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelFrame {
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub areg: [::std::os::raw::c_long; 4usize],
    pub sar: ::std::os::raw::c_long,
    pub lcount: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub acclo: ::std::os::raw::c_long,
    pub acchi: ::std::os::raw::c_long,
    pub mr: [::std::os::raw::c_long; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of KernelFrame"][::std::mem::size_of::<KernelFrame>() - 128usize];
    ["Alignment of KernelFrame"][::std::mem::align_of::<KernelFrame>() - 8usize];
    ["Offset of field: KernelFrame::pc"][::std::mem::offset_of!(KernelFrame, pc) - 0usize];
    ["Offset of field: KernelFrame::ps"][::std::mem::offset_of!(KernelFrame, ps) - 8usize];
    ["Offset of field: KernelFrame::areg"][::std::mem::offset_of!(KernelFrame, areg) - 16usize];
    ["Offset of field: KernelFrame::sar"][::std::mem::offset_of!(KernelFrame, sar) - 48usize];
    ["Offset of field: KernelFrame::lcount"][::std::mem::offset_of!(KernelFrame, lcount) - 56usize];
    ["Offset of field: KernelFrame::lbeg"][::std::mem::offset_of!(KernelFrame, lbeg) - 64usize];
    ["Offset of field: KernelFrame::lend"][::std::mem::offset_of!(KernelFrame, lend) - 72usize];
    ["Offset of field: KernelFrame::acclo"][::std::mem::offset_of!(KernelFrame, acclo) - 80usize];
    ["Offset of field: KernelFrame::acchi"][::std::mem::offset_of!(KernelFrame, acchi) - 88usize];
    ["Offset of field: KernelFrame::mr"][::std::mem::offset_of!(KernelFrame, mr) - 96usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserFrame {
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub vpri: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
    pub a4: ::std::os::raw::c_long,
    pub a5: ::std::os::raw::c_long,
    pub exccause: ::std::os::raw::c_long,
    pub lcount: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub acclo: ::std::os::raw::c_long,
    pub acchi: ::std::os::raw::c_long,
    pub mr: [::std::os::raw::c_long; 4usize],
    pub pad: [::std::os::raw::c_long; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UserFrame"][::std::mem::size_of::<UserFrame>() - 160usize];
    ["Alignment of UserFrame"][::std::mem::align_of::<UserFrame>() - 8usize];
    ["Offset of field: UserFrame::pc"][::std::mem::offset_of!(UserFrame, pc) - 0usize];
    ["Offset of field: UserFrame::ps"][::std::mem::offset_of!(UserFrame, ps) - 8usize];
    ["Offset of field: UserFrame::sar"][::std::mem::offset_of!(UserFrame, sar) - 16usize];
    ["Offset of field: UserFrame::vpri"][::std::mem::offset_of!(UserFrame, vpri) - 24usize];
    ["Offset of field: UserFrame::a2"][::std::mem::offset_of!(UserFrame, a2) - 32usize];
    ["Offset of field: UserFrame::a3"][::std::mem::offset_of!(UserFrame, a3) - 40usize];
    ["Offset of field: UserFrame::a4"][::std::mem::offset_of!(UserFrame, a4) - 48usize];
    ["Offset of field: UserFrame::a5"][::std::mem::offset_of!(UserFrame, a5) - 56usize];
    ["Offset of field: UserFrame::exccause"][::std::mem::offset_of!(UserFrame, exccause) - 64usize];
    ["Offset of field: UserFrame::lcount"][::std::mem::offset_of!(UserFrame, lcount) - 72usize];
    ["Offset of field: UserFrame::lbeg"][::std::mem::offset_of!(UserFrame, lbeg) - 80usize];
    ["Offset of field: UserFrame::lend"][::std::mem::offset_of!(UserFrame, lend) - 88usize];
    ["Offset of field: UserFrame::acclo"][::std::mem::offset_of!(UserFrame, acclo) - 96usize];
    ["Offset of field: UserFrame::acchi"][::std::mem::offset_of!(UserFrame, acchi) - 104usize];
    ["Offset of field: UserFrame::mr"][::std::mem::offset_of!(UserFrame, mr) - 112usize];
    ["Offset of field: UserFrame::pad"][::std::mem::offset_of!(UserFrame, pad) - 144usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtExcFrame {
    pub exit: ::std::os::raw::c_long,
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub a0: ::std::os::raw::c_long,
    pub a1: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
    pub a4: ::std::os::raw::c_long,
    pub a5: ::std::os::raw::c_long,
    pub a6: ::std::os::raw::c_long,
    pub a7: ::std::os::raw::c_long,
    pub a8: ::std::os::raw::c_long,
    pub a9: ::std::os::raw::c_long,
    pub a10: ::std::os::raw::c_long,
    pub a11: ::std::os::raw::c_long,
    pub a12: ::std::os::raw::c_long,
    pub a13: ::std::os::raw::c_long,
    pub a14: ::std::os::raw::c_long,
    pub a15: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub exccause: ::std::os::raw::c_long,
    pub excvaddr: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub lcount: ::std::os::raw::c_long,
    pub tmp0: ::std::os::raw::c_long,
    pub tmp1: ::std::os::raw::c_long,
    pub tmp2: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XtExcFrame"][::std::mem::size_of::<XtExcFrame>() - 224usize];
    ["Alignment of XtExcFrame"][::std::mem::align_of::<XtExcFrame>() - 8usize];
    ["Offset of field: XtExcFrame::exit"][::std::mem::offset_of!(XtExcFrame, exit) - 0usize];
    ["Offset of field: XtExcFrame::pc"][::std::mem::offset_of!(XtExcFrame, pc) - 8usize];
    ["Offset of field: XtExcFrame::ps"][::std::mem::offset_of!(XtExcFrame, ps) - 16usize];
    ["Offset of field: XtExcFrame::a0"][::std::mem::offset_of!(XtExcFrame, a0) - 24usize];
    ["Offset of field: XtExcFrame::a1"][::std::mem::offset_of!(XtExcFrame, a1) - 32usize];
    ["Offset of field: XtExcFrame::a2"][::std::mem::offset_of!(XtExcFrame, a2) - 40usize];
    ["Offset of field: XtExcFrame::a3"][::std::mem::offset_of!(XtExcFrame, a3) - 48usize];
    ["Offset of field: XtExcFrame::a4"][::std::mem::offset_of!(XtExcFrame, a4) - 56usize];
    ["Offset of field: XtExcFrame::a5"][::std::mem::offset_of!(XtExcFrame, a5) - 64usize];
    ["Offset of field: XtExcFrame::a6"][::std::mem::offset_of!(XtExcFrame, a6) - 72usize];
    ["Offset of field: XtExcFrame::a7"][::std::mem::offset_of!(XtExcFrame, a7) - 80usize];
    ["Offset of field: XtExcFrame::a8"][::std::mem::offset_of!(XtExcFrame, a8) - 88usize];
    ["Offset of field: XtExcFrame::a9"][::std::mem::offset_of!(XtExcFrame, a9) - 96usize];
    ["Offset of field: XtExcFrame::a10"][::std::mem::offset_of!(XtExcFrame, a10) - 104usize];
    ["Offset of field: XtExcFrame::a11"][::std::mem::offset_of!(XtExcFrame, a11) - 112usize];
    ["Offset of field: XtExcFrame::a12"][::std::mem::offset_of!(XtExcFrame, a12) - 120usize];
    ["Offset of field: XtExcFrame::a13"][::std::mem::offset_of!(XtExcFrame, a13) - 128usize];
    ["Offset of field: XtExcFrame::a14"][::std::mem::offset_of!(XtExcFrame, a14) - 136usize];
    ["Offset of field: XtExcFrame::a15"][::std::mem::offset_of!(XtExcFrame, a15) - 144usize];
    ["Offset of field: XtExcFrame::sar"][::std::mem::offset_of!(XtExcFrame, sar) - 152usize];
    ["Offset of field: XtExcFrame::exccause"]
        [::std::mem::offset_of!(XtExcFrame, exccause) - 160usize];
    ["Offset of field: XtExcFrame::excvaddr"]
        [::std::mem::offset_of!(XtExcFrame, excvaddr) - 168usize];
    ["Offset of field: XtExcFrame::lbeg"][::std::mem::offset_of!(XtExcFrame, lbeg) - 176usize];
    ["Offset of field: XtExcFrame::lend"][::std::mem::offset_of!(XtExcFrame, lend) - 184usize];
    ["Offset of field: XtExcFrame::lcount"][::std::mem::offset_of!(XtExcFrame, lcount) - 192usize];
    ["Offset of field: XtExcFrame::tmp0"][::std::mem::offset_of!(XtExcFrame, tmp0) - 200usize];
    ["Offset of field: XtExcFrame::tmp1"][::std::mem::offset_of!(XtExcFrame, tmp1) - 208usize];
    ["Offset of field: XtExcFrame::tmp2"][::std::mem::offset_of!(XtExcFrame, tmp2) - 216usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtSolFrame {
    pub exit: ::std::os::raw::c_long,
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub threadptr: ::std::os::raw::c_long,
    pub a0: ::std::os::raw::c_long,
    pub a1: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XtSolFrame"][::std::mem::size_of::<XtSolFrame>() - 64usize];
    ["Alignment of XtSolFrame"][::std::mem::align_of::<XtSolFrame>() - 8usize];
    ["Offset of field: XtSolFrame::exit"][::std::mem::offset_of!(XtSolFrame, exit) - 0usize];
    ["Offset of field: XtSolFrame::pc"][::std::mem::offset_of!(XtSolFrame, pc) - 8usize];
    ["Offset of field: XtSolFrame::ps"][::std::mem::offset_of!(XtSolFrame, ps) - 16usize];
    ["Offset of field: XtSolFrame::threadptr"]
        [::std::mem::offset_of!(XtSolFrame, threadptr) - 24usize];
    ["Offset of field: XtSolFrame::a0"][::std::mem::offset_of!(XtSolFrame, a0) - 32usize];
    ["Offset of field: XtSolFrame::a1"][::std::mem::offset_of!(XtSolFrame, a1) - 40usize];
    ["Offset of field: XtSolFrame::a2"][::std::mem::offset_of!(XtSolFrame, a2) - 48usize];
    ["Offset of field: XtSolFrame::a3"][::std::mem::offset_of!(XtSolFrame, a3) - 56usize];
};
pub type TaskFunction_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtosCoreState {
    pub signature: ::std::os::raw::c_long,
    pub restore_label: ::std::os::raw::c_long,
    pub aftersave_label: ::std::os::raw::c_long,
    pub areg: [::std::os::raw::c_long; 64usize],
    pub caller_regs: [::std::os::raw::c_long; 16usize],
    pub caller_regs_saved: ::std::os::raw::c_long,
    pub windowbase: ::std::os::raw::c_long,
    pub windowstart: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub epc1: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub excsave1: ::std::os::raw::c_long,
    pub depc: ::std::os::raw::c_long,
    pub epc: [::std::os::raw::c_long; 6usize],
    pub eps: [::std::os::raw::c_long; 6usize],
    pub excsave: [::std::os::raw::c_long; 6usize],
    pub lcount: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub vecbase: ::std::os::raw::c_long,
    pub atomctl: ::std::os::raw::c_long,
    pub memctl: ::std::os::raw::c_long,
    pub ccount: ::std::os::raw::c_long,
    pub ccompare: [::std::os::raw::c_long; 3usize],
    pub intenable: ::std::os::raw::c_long,
    pub interrupt: ::std::os::raw::c_long,
    pub icount: ::std::os::raw::c_long,
    pub icountlevel: ::std::os::raw::c_long,
    pub debugcause: ::std::os::raw::c_long,
    pub dbreakc: [::std::os::raw::c_long; 2usize],
    pub dbreaka: [::std::os::raw::c_long; 2usize],
    pub ibreaka: [::std::os::raw::c_long; 2usize],
    pub ibreakenable: ::std::os::raw::c_long,
    pub misc: [::std::os::raw::c_long; 4usize],
    pub cpenable: ::std::os::raw::c_long,
    pub tlbs: [::std::os::raw::c_long; 16usize],
    pub ncp: [::std::os::raw::c_char; 48usize],
    pub cp0: [::std::os::raw::c_char; 72usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of XtosCoreState"][::std::mem::size_of::<XtosCoreState>() - 1336usize];
    ["Alignment of XtosCoreState"][::std::mem::align_of::<XtosCoreState>() - 8usize];
    ["Offset of field: XtosCoreState::signature"]
        [::std::mem::offset_of!(XtosCoreState, signature) - 0usize];
    ["Offset of field: XtosCoreState::restore_label"]
        [::std::mem::offset_of!(XtosCoreState, restore_label) - 8usize];
    ["Offset of field: XtosCoreState::aftersave_label"]
        [::std::mem::offset_of!(XtosCoreState, aftersave_label) - 16usize];
    ["Offset of field: XtosCoreState::areg"][::std::mem::offset_of!(XtosCoreState, areg) - 24usize];
    ["Offset of field: XtosCoreState::caller_regs"]
        [::std::mem::offset_of!(XtosCoreState, caller_regs) - 536usize];
    ["Offset of field: XtosCoreState::caller_regs_saved"]
        [::std::mem::offset_of!(XtosCoreState, caller_regs_saved) - 664usize];
    ["Offset of field: XtosCoreState::windowbase"]
        [::std::mem::offset_of!(XtosCoreState, windowbase) - 672usize];
    ["Offset of field: XtosCoreState::windowstart"]
        [::std::mem::offset_of!(XtosCoreState, windowstart) - 680usize];
    ["Offset of field: XtosCoreState::sar"][::std::mem::offset_of!(XtosCoreState, sar) - 688usize];
    ["Offset of field: XtosCoreState::epc1"]
        [::std::mem::offset_of!(XtosCoreState, epc1) - 696usize];
    ["Offset of field: XtosCoreState::ps"][::std::mem::offset_of!(XtosCoreState, ps) - 704usize];
    ["Offset of field: XtosCoreState::excsave1"]
        [::std::mem::offset_of!(XtosCoreState, excsave1) - 712usize];
    ["Offset of field: XtosCoreState::depc"]
        [::std::mem::offset_of!(XtosCoreState, depc) - 720usize];
    ["Offset of field: XtosCoreState::epc"][::std::mem::offset_of!(XtosCoreState, epc) - 728usize];
    ["Offset of field: XtosCoreState::eps"][::std::mem::offset_of!(XtosCoreState, eps) - 776usize];
    ["Offset of field: XtosCoreState::excsave"]
        [::std::mem::offset_of!(XtosCoreState, excsave) - 824usize];
    ["Offset of field: XtosCoreState::lcount"]
        [::std::mem::offset_of!(XtosCoreState, lcount) - 872usize];
    ["Offset of field: XtosCoreState::lbeg"]
        [::std::mem::offset_of!(XtosCoreState, lbeg) - 880usize];
    ["Offset of field: XtosCoreState::lend"]
        [::std::mem::offset_of!(XtosCoreState, lend) - 888usize];
    ["Offset of field: XtosCoreState::vecbase"]
        [::std::mem::offset_of!(XtosCoreState, vecbase) - 896usize];
    ["Offset of field: XtosCoreState::atomctl"]
        [::std::mem::offset_of!(XtosCoreState, atomctl) - 904usize];
    ["Offset of field: XtosCoreState::memctl"]
        [::std::mem::offset_of!(XtosCoreState, memctl) - 912usize];
    ["Offset of field: XtosCoreState::ccount"]
        [::std::mem::offset_of!(XtosCoreState, ccount) - 920usize];
    ["Offset of field: XtosCoreState::ccompare"]
        [::std::mem::offset_of!(XtosCoreState, ccompare) - 928usize];
    ["Offset of field: XtosCoreState::intenable"]
        [::std::mem::offset_of!(XtosCoreState, intenable) - 952usize];
    ["Offset of field: XtosCoreState::interrupt"]
        [::std::mem::offset_of!(XtosCoreState, interrupt) - 960usize];
    ["Offset of field: XtosCoreState::icount"]
        [::std::mem::offset_of!(XtosCoreState, icount) - 968usize];
    ["Offset of field: XtosCoreState::icountlevel"]
        [::std::mem::offset_of!(XtosCoreState, icountlevel) - 976usize];
    ["Offset of field: XtosCoreState::debugcause"]
        [::std::mem::offset_of!(XtosCoreState, debugcause) - 984usize];
    ["Offset of field: XtosCoreState::dbreakc"]
        [::std::mem::offset_of!(XtosCoreState, dbreakc) - 992usize];
    ["Offset of field: XtosCoreState::dbreaka"]
        [::std::mem::offset_of!(XtosCoreState, dbreaka) - 1008usize];
    ["Offset of field: XtosCoreState::ibreaka"]
        [::std::mem::offset_of!(XtosCoreState, ibreaka) - 1024usize];
    ["Offset of field: XtosCoreState::ibreakenable"]
        [::std::mem::offset_of!(XtosCoreState, ibreakenable) - 1040usize];
    ["Offset of field: XtosCoreState::misc"]
        [::std::mem::offset_of!(XtosCoreState, misc) - 1048usize];
    ["Offset of field: XtosCoreState::cpenable"]
        [::std::mem::offset_of!(XtosCoreState, cpenable) - 1080usize];
    ["Offset of field: XtosCoreState::tlbs"]
        [::std::mem::offset_of!(XtosCoreState, tlbs) - 1088usize];
    ["Offset of field: XtosCoreState::ncp"][::std::mem::offset_of!(XtosCoreState, ncp) - 1216usize];
    ["Offset of field: XtosCoreState::cp0"][::std::mem::offset_of!(XtosCoreState, cp0) - 1264usize];
};
pub type _xtos_handler_func = ::std::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
unsafe extern "C" {
    pub fn _xtos_ints_off(mask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_ints_on(mask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_set_intlevel(intlevel: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_restore_just_intlevel(
        restoreval: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_set_interrupt_handler(n: ::std::os::raw::c_int, f: _xtos_handler)
        -> _xtos_handler;
}
unsafe extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: ::std::os::raw::c_int,
        f: _xtos_handler,
        arg: *mut ::std::os::raw::c_void,
    ) -> _xtos_handler;
}
unsafe extern "C" {
    pub fn _xtos_set_exception_handler(n: ::std::os::raw::c_int, f: _xtos_handler)
        -> _xtos_handler;
}
unsafe extern "C" {
    pub fn _xtos_memep_initrams();
}
unsafe extern "C" {
    pub fn _xtos_memep_enable(flags: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn _xtos_dispatch_level1_interrupts();
}
unsafe extern "C" {
    pub fn _xtos_dispatch_level2_interrupts();
}
unsafe extern "C" {
    pub fn _xtos_dispatch_level3_interrupts();
}
unsafe extern "C" {
    pub fn _xtos_dispatch_level4_interrupts();
}
unsafe extern "C" {
    pub fn _xtos_dispatch_level5_interrupts();
}
unsafe extern "C" {
    pub fn _xtos_dispatch_level6_interrupts();
}
unsafe extern "C" {
    pub fn _xtos_read_ints() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn _xtos_clear_ints(mask: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn _xtos_core_shutoff(flags: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _xtos_core_save(
        flags: ::std::os::raw::c_uint,
        savearea: *mut XtosCoreState,
        code: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _xtos_core_restore(retvalue: ::std::os::raw::c_uint, savearea: *mut XtosCoreState);
}
unsafe extern "C" {
    pub fn _xtos_timer_0_delta(cycles: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn _xtos_timer_1_delta(cycles: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn _xtos_timer_2_delta(cycles: ::std::os::raw::c_int);
}
pub type xt_handler =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type xt_exc_handler = ::std::option::Option<unsafe extern "C" fn(arg1: *mut XtExcFrame)>;
unsafe extern "C" {
    pub fn xt_set_exception_handler(n: ::std::os::raw::c_int, f: xt_exc_handler) -> xt_exc_handler;
}
unsafe extern "C" {
    pub fn xt_set_interrupt_handler(
        n: ::std::os::raw::c_int,
        f: xt_handler,
        arg: *mut ::std::os::raw::c_void,
    ) -> xt_handler;
}
unsafe extern "C" {
    pub fn xt_ints_on(mask: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xt_ints_off(mask: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn xt_get_interrupt_handler_arg(n: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn xt_int_has_handler(intr: ::std::os::raw::c_int, cpu: ::std::os::raw::c_int) -> bool;
}
#[doc = " @brief CPU cycle count type\n\n This data type represents the CPU's clock cycle count"]
pub type esp_cpu_cycle_count_t = u32;
pub const esp_cpu_intr_type_t_ESP_CPU_INTR_TYPE_LEVEL: esp_cpu_intr_type_t = 0;
pub const esp_cpu_intr_type_t_ESP_CPU_INTR_TYPE_EDGE: esp_cpu_intr_type_t = 1;
pub const esp_cpu_intr_type_t_ESP_CPU_INTR_TYPE_NA: esp_cpu_intr_type_t = 2;
#[doc = " @brief CPU interrupt type"]
pub type esp_cpu_intr_type_t = ::std::os::raw::c_uint;
#[doc = " @brief CPU interrupt descriptor\n\n Each particular CPU interrupt has an associated descriptor describing that\n particular interrupt's characteristics. Call esp_cpu_intr_get_desc() to get\n the descriptors of a particular interrupt."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_cpu_intr_desc_t {
    #[doc = "< Priority of the interrupt if it has a fixed priority, (-1) if the priority is configurable."]
    pub priority: ::std::os::raw::c_int,
    #[doc = "< Whether the interrupt is an edge or level type interrupt, ESP_CPU_INTR_TYPE_NA if the type is configurable."]
    pub type_: esp_cpu_intr_type_t,
    #[doc = "< Flags indicating extra details."]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of esp_cpu_intr_desc_t"][::std::mem::size_of::<esp_cpu_intr_desc_t>() - 12usize];
    ["Alignment of esp_cpu_intr_desc_t"][::std::mem::align_of::<esp_cpu_intr_desc_t>() - 4usize];
    ["Offset of field: esp_cpu_intr_desc_t::priority"]
        [::std::mem::offset_of!(esp_cpu_intr_desc_t, priority) - 0usize];
    ["Offset of field: esp_cpu_intr_desc_t::type_"]
        [::std::mem::offset_of!(esp_cpu_intr_desc_t, type_) - 4usize];
    ["Offset of field: esp_cpu_intr_desc_t::flags"]
        [::std::mem::offset_of!(esp_cpu_intr_desc_t, flags) - 8usize];
};
#[doc = " @brief CPU interrupt handler type"]
pub type esp_cpu_intr_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
pub const esp_cpu_watchpoint_trigger_t_ESP_CPU_WATCHPOINT_LOAD: esp_cpu_watchpoint_trigger_t = 0;
pub const esp_cpu_watchpoint_trigger_t_ESP_CPU_WATCHPOINT_STORE: esp_cpu_watchpoint_trigger_t = 1;
pub const esp_cpu_watchpoint_trigger_t_ESP_CPU_WATCHPOINT_ACCESS: esp_cpu_watchpoint_trigger_t = 2;
#[doc = " @brief CPU watchpoint trigger type"]
pub type esp_cpu_watchpoint_trigger_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Stall a CPU core\n\n @param core_id  The core's ID"]
    pub fn esp_cpu_stall(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Resume a previously stalled CPU core\n\n @param core_id The core's ID"]
    pub fn esp_cpu_unstall(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Reset a CPU core\n\n @param core_id The core's ID"]
    pub fn esp_cpu_reset(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Wait for Interrupt\n\n This function causes the current CPU core to execute its Wait For Interrupt\n (WFI or equivalent) instruction. After executing this function, the CPU core\n will stop execution until an interrupt occurs."]
    pub fn esp_cpu_wait_for_intr();
}
unsafe extern "C" {
    #[doc = " @brief Get a CPU interrupt's descriptor\n\n Each CPU interrupt has a descriptor describing the interrupt's capabilities\n and restrictions. This function gets the descriptor of a particular interrupt\n on a particular CPU.\n\n @param[in] core_id The core's ID\n @param[in] intr_num Interrupt number\n @param[out] intr_desc_ret The interrupt's descriptor"]
    pub fn esp_cpu_intr_get_desc(
        core_id: ::std::os::raw::c_int,
        intr_num: ::std::os::raw::c_int,
        intr_desc_ret: *mut esp_cpu_intr_desc_t,
    );
}
unsafe extern "C" {
    #[doc = " @brief Configure the CPU to disable access to invalid memory regions"]
    pub fn esp_cpu_configure_region_protection();
}
unsafe extern "C" {
    #[doc = " @brief Set and enable a hardware breakpoint on the current CPU\n\n @note This function is meant to be called by the panic handler to set a\n breakpoint for an attached debugger during a panic.\n @note Overwrites previously set breakpoint with same breakpoint number.\n @param bp_num Hardware breakpoint number [0..SOC_CPU_BREAKPOINTS_NUM - 1]\n @param bp_addr Address to set a breakpoint on\n @return ESP_OK if breakpoint is set. Failure otherwise"]
    pub fn esp_cpu_set_breakpoint(
        bp_num: ::std::os::raw::c_int,
        bp_addr: *const ::std::os::raw::c_void,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Clear a hardware breakpoint on the current CPU\n\n @note Clears a breakpoint regardless of whether it was previously set\n @param bp_num Hardware breakpoint number [0..SOC_CPU_BREAKPOINTS_NUM - 1]\n @return ESP_OK if breakpoint is cleared. Failure otherwise"]
    pub fn esp_cpu_clear_breakpoint(bp_num: ::std::os::raw::c_int) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set and enable a hardware watchpoint on the current CPU\n\n Set and enable a hardware watchpoint on the current CPU, specifying the\n memory range and trigger operation. Watchpoints will break/panic the CPU when\n the CPU accesses (according to the trigger type) on a certain memory range.\n\n @note Overwrites previously set watchpoint with same watchpoint number.\n       On RISC-V chips, this API uses method0(Exact matching) and method1(NAPOT matching) according to the\n       riscv-debug-spec-0.13 specification for address matching.\n       If the watch region size is 1byte, it uses exact matching (method 0).\n       If the watch region size is larger than 1byte, it uses NAPOT matching (method 1). This mode requires\n       the watching region start address to be aligned to the watching region size.\n\n @param wp_num Hardware watchpoint number [0..SOC_CPU_WATCHPOINTS_NUM - 1]\n @param wp_addr Watchpoint's base address, must be naturally aligned to the size of the region\n @param size Size of the region to watch. Must be one of 2^n and in the range of [1 ... SOC_CPU_WATCHPOINT_MAX_REGION_SIZE]\n @param trigger Trigger type\n @return ESP_ERR_INVALID_ARG on invalid arg, ESP_OK otherwise"]
    pub fn esp_cpu_set_watchpoint(
        wp_num: ::std::os::raw::c_int,
        wp_addr: *const ::std::os::raw::c_void,
        size: usize,
        trigger: esp_cpu_watchpoint_trigger_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Clear a hardware watchpoint on the current CPU\n\n @note Clears a watchpoint regardless of whether it was previously set\n @param wp_num Hardware watchpoint number [0..SOC_CPU_WATCHPOINTS_NUM - 1]\n @return ESP_OK if watchpoint was cleared. Failure otherwise."]
    pub fn esp_cpu_clear_watchpoint(wp_num: ::std::os::raw::c_int) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Atomic compare-and-set operation\n\n @param addr Address of atomic variable\n @param compare_value Value to compare the atomic variable to\n @param new_value New value to set the atomic variable to\n @return Whether the atomic variable was set or not"]
    pub fn esp_cpu_compare_and_set(addr: *mut u32, compare_value: u32, new_value: u32) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spinlock_t {
    pub owner: u32,
    pub count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spinlock_t"][::std::mem::size_of::<spinlock_t>() - 8usize];
    ["Alignment of spinlock_t"][::std::mem::align_of::<spinlock_t>() - 4usize];
    ["Offset of field: spinlock_t::owner"][::std::mem::offset_of!(spinlock_t, owner) - 0usize];
    ["Offset of field: spinlock_t::count"][::std::mem::offset_of!(spinlock_t, count) - 4usize];
};
unsafe extern "C" {
    #[doc = " Initialize the crosscore interrupt system for this CPU.\n This needs to be called once on every CPU that is used\n by FreeRTOS.\n\n If multicore FreeRTOS support is enabled, this will be\n called automatically by the startup code and should not\n be called manually."]
    pub fn esp_crosscore_int_init();
}
unsafe extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should yield its\n currently running task in favour of a higher-priority task\n that presumably just woke up.\n\n This is used internally by FreeRTOS in multicore mode\n and should not be called by the user.\n\n @param core_id Core that should do the yielding"]
    pub fn esp_crosscore_int_send_yield(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should update its\n CCOMPARE1 value due to a frequency switch.\n\n This is used internally when dynamic frequency switching is\n enabled, and should not be called from application code.\n\n @param core_id Core that should update its CCOMPARE1 value"]
    pub fn esp_crosscore_int_send_freq_switch(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn esp_crosscore_int_send_gdb_call(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should print its current backtrace\n\n This is used internally by the Task Watchdog to dump the backtrace of the\n opposite core and should not be called from application code.\n\n @param core_id Core that should print its backtrace"]
    pub fn esp_crosscore_int_send_print_backtrace(core_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it call `task_wdt_timeout_abort_xtensa`.\n This will make the CPU abort, using the interrupted task frame.\n\n This is used internally by the Task Watchdog when it should abort after a task,\n running on the other core than the one running the TWDT ISR, failed to reset\n its timer.\n\n @param core_id Core that should abort"]
    pub fn esp_crosscore_int_send_twdt_abort(core_id: ::std::os::raw::c_int);
}
#[doc = "< interrupt of WiFi MAC, level"]
pub const periph_interrupt_t_ETS_WIFI_MAC_INTR_SOURCE: periph_interrupt_t = 0;
#[doc = "< interrupt of WiFi MAC, NMI, use if MAC have bug to fix in NMI"]
pub const periph_interrupt_t_ETS_WIFI_MAC_NMI_SOURCE: periph_interrupt_t = 1;
#[doc = "< interrupt of WiFi BB, level, we can do some calibartion"]
pub const periph_interrupt_t_ETS_WIFI_BB_INTR_SOURCE: periph_interrupt_t = 2;
#[doc = "< will be cancelled"]
pub const periph_interrupt_t_ETS_BT_MAC_INTR_SOURCE: periph_interrupt_t = 3;
#[doc = "< interrupt of BT BB, level"]
pub const periph_interrupt_t_ETS_BT_BB_INTR_SOURCE: periph_interrupt_t = 4;
#[doc = "< interrupt of BT BB, NMI, use if BB have bug to fix in NMI"]
pub const periph_interrupt_t_ETS_BT_BB_NMI_SOURCE: periph_interrupt_t = 5;
#[doc = "< interrupt of RWBT, level"]
pub const periph_interrupt_t_ETS_RWBT_INTR_SOURCE: periph_interrupt_t = 6;
#[doc = "< interrupt of RWBLE, level"]
pub const periph_interrupt_t_ETS_RWBLE_INTR_SOURCE: periph_interrupt_t = 7;
#[doc = "< interrupt of RWBT, NMI, use if RWBT have bug to fix in NMI"]
pub const periph_interrupt_t_ETS_RWBT_NMI_SOURCE: periph_interrupt_t = 8;
#[doc = "< interrupt of RWBLE, NMI, use if RWBT have bug to fix in NMI"]
pub const periph_interrupt_t_ETS_RWBLE_NMI_SOURCE: periph_interrupt_t = 9;
#[doc = "< interrupt of SLC0, level"]
pub const periph_interrupt_t_ETS_SLC0_INTR_SOURCE: periph_interrupt_t = 10;
#[doc = "< interrupt of SLC1, level"]
pub const periph_interrupt_t_ETS_SLC1_INTR_SOURCE: periph_interrupt_t = 11;
#[doc = "< interrupt of UHCI0, level"]
pub const periph_interrupt_t_ETS_UHCI0_INTR_SOURCE: periph_interrupt_t = 12;
#[doc = "< interrupt of UHCI1, level"]
pub const periph_interrupt_t_ETS_UHCI1_INTR_SOURCE: periph_interrupt_t = 13;
#[doc = "< interrupt of TIMER_GROUP0, TIMER0, level, we would like use EDGE for timer if permission"]
pub const periph_interrupt_t_ETS_TG0_T0_LEVEL_INTR_SOURCE: periph_interrupt_t = 14;
#[doc = "< interrupt of TIMER_GROUP0, TIMER1, level, we would like use EDGE for timer if permission"]
pub const periph_interrupt_t_ETS_TG0_T1_LEVEL_INTR_SOURCE: periph_interrupt_t = 15;
#[doc = "< interrupt of TIMER_GROUP0, WATCHDOG, level"]
pub const periph_interrupt_t_ETS_TG0_WDT_LEVEL_INTR_SOURCE: periph_interrupt_t = 16;
#[doc = "< interrupt of TIMER_GROUP0, LACT, level"]
pub const periph_interrupt_t_ETS_TG0_LACT_LEVEL_INTR_SOURCE: periph_interrupt_t = 17;
#[doc = "< interrupt of TIMER_GROUP1, TIMER0, level, we would like use EDGE for timer if permission"]
pub const periph_interrupt_t_ETS_TG1_T0_LEVEL_INTR_SOURCE: periph_interrupt_t = 18;
#[doc = "< interrupt of TIMER_GROUP1, TIMER1, level, we would like use EDGE for timer if permission"]
pub const periph_interrupt_t_ETS_TG1_T1_LEVEL_INTR_SOURCE: periph_interrupt_t = 19;
#[doc = "< interrupt of TIMER_GROUP1, WATCHDOG, level"]
pub const periph_interrupt_t_ETS_TG1_WDT_LEVEL_INTR_SOURCE: periph_interrupt_t = 20;
#[doc = "< interrupt of TIMER_GROUP1, LACT, level"]
pub const periph_interrupt_t_ETS_TG1_LACT_LEVEL_INTR_SOURCE: periph_interrupt_t = 21;
#[doc = "< interrupt of GPIO, level"]
pub const periph_interrupt_t_ETS_GPIO_INTR_SOURCE: periph_interrupt_t = 22;
#[doc = "< interrupt of GPIO, NMI"]
pub const periph_interrupt_t_ETS_GPIO_NMI_SOURCE: periph_interrupt_t = 23;
#[doc = "< interrupt0 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR0_SOURCE: periph_interrupt_t = 24;
#[doc = "< interrupt1 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR1_SOURCE: periph_interrupt_t = 25;
#[doc = "< interrupt2 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR2_SOURCE: periph_interrupt_t = 26;
#[doc = "< interrupt3 generated from a CPU, level"]
pub const periph_interrupt_t_ETS_FROM_CPU_INTR3_SOURCE: periph_interrupt_t = 27;
#[doc = "< interrupt of SPI0, level, SPI0 is for Cache Access, do not use this"]
pub const periph_interrupt_t_ETS_SPI0_INTR_SOURCE: periph_interrupt_t = 28;
#[doc = "< interrupt of SPI1, level, SPI1 is for flash read/write, do not use this"]
pub const periph_interrupt_t_ETS_SPI1_INTR_SOURCE: periph_interrupt_t = 29;
#[doc = "< interrupt of SPI2, level"]
pub const periph_interrupt_t_ETS_SPI2_INTR_SOURCE: periph_interrupt_t = 30;
#[doc = "< interrupt of SPI3, level"]
pub const periph_interrupt_t_ETS_SPI3_INTR_SOURCE: periph_interrupt_t = 31;
#[doc = "< interrupt of I2S0, level"]
pub const periph_interrupt_t_ETS_I2S0_INTR_SOURCE: periph_interrupt_t = 32;
#[doc = "< interrupt of I2S1, level"]
pub const periph_interrupt_t_ETS_I2S1_INTR_SOURCE: periph_interrupt_t = 33;
#[doc = "< interrupt of UART0, level"]
pub const periph_interrupt_t_ETS_UART0_INTR_SOURCE: periph_interrupt_t = 34;
#[doc = "< interrupt of UART1, level"]
pub const periph_interrupt_t_ETS_UART1_INTR_SOURCE: periph_interrupt_t = 35;
#[doc = "< interrupt of UART2, level"]
pub const periph_interrupt_t_ETS_UART2_INTR_SOURCE: periph_interrupt_t = 36;
#[doc = "< interrupt of SD/SDIO/MMC HOST, level"]
pub const periph_interrupt_t_ETS_SDIO_HOST_INTR_SOURCE: periph_interrupt_t = 37;
#[doc = "< interrupt of ethernet mac, level"]
pub const periph_interrupt_t_ETS_ETH_MAC_INTR_SOURCE: periph_interrupt_t = 38;
#[doc = "< interrupt of PWM0, level, Reserved"]
pub const periph_interrupt_t_ETS_PWM0_INTR_SOURCE: periph_interrupt_t = 39;
#[doc = "< interrupt of PWM1, level, Reserved"]
pub const periph_interrupt_t_ETS_PWM1_INTR_SOURCE: periph_interrupt_t = 40;
#[doc = "< interrupt of LED PWM, level"]
pub const periph_interrupt_t_ETS_LEDC_INTR_SOURCE: periph_interrupt_t = 43;
#[doc = "< interrupt of efuse, level, not likely to use"]
pub const periph_interrupt_t_ETS_EFUSE_INTR_SOURCE: periph_interrupt_t = 44;
#[doc = "< interrupt of twai, level"]
pub const periph_interrupt_t_ETS_TWAI_INTR_SOURCE: periph_interrupt_t = 45;
#[doc = "< interrupt of rtc core, level, include rtc watchdog"]
pub const periph_interrupt_t_ETS_RTC_CORE_INTR_SOURCE: periph_interrupt_t = 46;
#[doc = "< interrupt of remote controller, level"]
pub const periph_interrupt_t_ETS_RMT_INTR_SOURCE: periph_interrupt_t = 47;
#[doc = "< interrupt of pulse count, level"]
pub const periph_interrupt_t_ETS_PCNT_INTR_SOURCE: periph_interrupt_t = 48;
#[doc = "< interrupt of I2C controller1, level"]
pub const periph_interrupt_t_ETS_I2C_EXT0_INTR_SOURCE: periph_interrupt_t = 49;
#[doc = "< interrupt of I2C controller0, level"]
pub const periph_interrupt_t_ETS_I2C_EXT1_INTR_SOURCE: periph_interrupt_t = 50;
#[doc = "< interrupt of RSA accelerator, level"]
pub const periph_interrupt_t_ETS_RSA_INTR_SOURCE: periph_interrupt_t = 51;
#[doc = "< interrupt of SPI1 DMA, SPI1 is for flash read/write, do not use this"]
pub const periph_interrupt_t_ETS_SPI1_DMA_INTR_SOURCE: periph_interrupt_t = 52;
#[doc = "< interrupt of SPI2 DMA, level"]
pub const periph_interrupt_t_ETS_SPI2_DMA_INTR_SOURCE: periph_interrupt_t = 53;
#[doc = "< interrupt of SPI3 DMA, level"]
pub const periph_interrupt_t_ETS_SPI3_DMA_INTR_SOURCE: periph_interrupt_t = 54;
#[doc = "< will be cancelled"]
pub const periph_interrupt_t_ETS_WDT_INTR_SOURCE: periph_interrupt_t = 55;
#[doc = "< will be cancelled"]
pub const periph_interrupt_t_ETS_TIMER1_INTR_SOURCE: periph_interrupt_t = 56;
#[doc = "< will be cancelled"]
pub const periph_interrupt_t_ETS_TIMER2_INTR_SOURCE: periph_interrupt_t = 57;
#[doc = "< interrupt of TIMER_GROUP0, TIMER0, EDGE"]
pub const periph_interrupt_t_ETS_TG0_T0_EDGE_INTR_SOURCE: periph_interrupt_t = 58;
#[doc = "< interrupt of TIMER_GROUP0, TIMER1, EDGE"]
pub const periph_interrupt_t_ETS_TG0_T1_EDGE_INTR_SOURCE: periph_interrupt_t = 59;
#[doc = "< interrupt of TIMER_GROUP0, WATCH DOG, EDGE"]
pub const periph_interrupt_t_ETS_TG0_WDT_EDGE_INTR_SOURCE: periph_interrupt_t = 60;
#[doc = "< interrupt of TIMER_GROUP0, LACT, EDGE"]
pub const periph_interrupt_t_ETS_TG0_LACT_EDGE_INTR_SOURCE: periph_interrupt_t = 61;
#[doc = "< interrupt of TIMER_GROUP1, TIMER0, EDGE"]
pub const periph_interrupt_t_ETS_TG1_T0_EDGE_INTR_SOURCE: periph_interrupt_t = 62;
#[doc = "< interrupt of TIMER_GROUP1, TIMER1, EDGE"]
pub const periph_interrupt_t_ETS_TG1_T1_EDGE_INTR_SOURCE: periph_interrupt_t = 63;
#[doc = "< interrupt of TIMER_GROUP1, WATCHDOG, EDGE"]
pub const periph_interrupt_t_ETS_TG1_WDT_EDGE_INTR_SOURCE: periph_interrupt_t = 64;
#[doc = "< interrupt of TIMER_GROUP0, LACT, EDGE"]
pub const periph_interrupt_t_ETS_TG1_LACT_EDGE_INTR_SOURCE: periph_interrupt_t = 65;
#[doc = "< interrupt of MMU Invalid Access, LEVEL"]
pub const periph_interrupt_t_ETS_MMU_IA_INTR_SOURCE: periph_interrupt_t = 66;
#[doc = "< interrupt of MPU Invalid Access, LEVEL"]
pub const periph_interrupt_t_ETS_MPU_IA_INTR_SOURCE: periph_interrupt_t = 67;
#[doc = "< interrupt of Cache Invalid Access, LEVEL"]
pub const periph_interrupt_t_ETS_CACHE_IA_INTR_SOURCE: periph_interrupt_t = 68;
#[doc = "< total number of interrupt sources"]
pub const periph_interrupt_t_ETS_MAX_INTR_SOURCE: periph_interrupt_t = 69;
pub type periph_interrupt_t = ::std::os::raw::c_uint;
pub use self::periph_interrupt_t as periph_interrput_t;
unsafe extern "C" {
    pub static esp_isr_names: [*const ::std::os::raw::c_char; 69usize];
}
unsafe extern "C" {
    #[doc = " @brief Check if the pointer is in external ram dma capable region\n\n @param p pointer\n\n @return true: capable; false: not capable"]
    pub fn esp_ptr_dma_ext_capable(p: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check if the pointer is executable\n\n @param p pointer\n\n @return true: is executable; false: not executable"]
    pub fn esp_ptr_executable(p: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check if the pointer is byte accessible\n\n @param p pointer\n\n @return true: is byte accessible; false: not byte accessible"]
    pub fn esp_ptr_byte_accessible(p: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check if the pointer is in external ram\n\n @param p pointer\n\n @return true: is in external ram; false: not in external ram"]
    pub fn esp_ptr_external_ram(p: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " Function which sets up newlib in ROM for use with ESP-IDF\n\n Includes defining the syscall table, setting up any common locks, etc.\n\n Called from the startup code, not intended to be called from application\n code."]
    pub fn esp_libc_init();
}
unsafe extern "C" {
    pub fn esp_setup_syscall_table();
}
unsafe extern "C" {
    pub fn esp_libc_init_global_stdio(stdio_dev: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn esp_libc_time_init();
}
unsafe extern "C" {
    #[doc = " Clean up some of lazily allocated buffers in REENT structures."]
    pub fn esp_reent_cleanup();
}
unsafe extern "C" {
    #[doc = " Update current microsecond time from RTC"]
    pub fn esp_set_time_from_rtc();
}
unsafe extern "C" {
    pub fn esp_sync_timekeeping_timers();
}
unsafe extern "C" {
    #[doc = " Initialize libc static locks"]
    pub fn esp_libc_locks_init();
}
unsafe extern "C" {
    pub fn esp_newlib_time_init();
}
unsafe extern "C" {
    pub fn esp_newlib_init();
}
unsafe extern "C" {
    pub fn esp_newlib_locks_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to a registered heap"]
pub type multi_heap_handle_t = *mut multi_heap_info;
unsafe extern "C" {
    #[doc = " @brief allocate a chunk of memory with specific alignment\n\n @param heap  Handle to a registered heap.\n @param size  size in bytes of memory chunk\n @param alignment  how the memory must be aligned\n\n @return pointer to the memory allocated, NULL on failure"]
    pub fn multi_heap_aligned_alloc(
        heap: multi_heap_handle_t,
        size: usize,
        alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief malloc() a buffer in a given heap\n\n Semantics are the same as standard malloc(), only the returned buffer will be allocated in the specified heap.\n\n @param heap Handle to a registered heap.\n @param size Size of desired buffer.\n\n @return Pointer to new memory, or NULL if allocation fails."]
    pub fn multi_heap_malloc(heap: multi_heap_handle_t, size: usize)
        -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief free() a buffer aligned in a given heap.\n\n @param heap Handle to a registered heap.\n @param p NULL, or a pointer previously returned from multi_heap_aligned_alloc() for the same heap.\n @note This function is deprecated, consider using multi_heap_free() instead"]
    pub fn multi_heap_aligned_free(heap: multi_heap_handle_t, p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief free() a buffer in a given heap.\n\n Semantics are the same as standard free(), only the argument 'p' must be NULL or have been allocated in the specified heap.\n\n @param heap Handle to a registered heap.\n @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    pub fn multi_heap_free(heap: multi_heap_handle_t, p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief realloc() a buffer in a given heap.\n\n Semantics are the same as standard realloc(), only the argument 'p' must be NULL or have been allocated in the specified heap.\n\n @param heap Handle to a registered heap.\n @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap.\n @param size Desired new size for buffer.\n\n @return New buffer of 'size' containing contents of 'p', or NULL if reallocation failed."]
    pub fn multi_heap_realloc(
        heap: multi_heap_handle_t,
        p: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with.\n\n @param heap Handle to a registered heap.\n @param p Pointer, must have been previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap.\n\n @return Size of the memory allocated at this block. May be more than the original size argument, due\n to padding and minimum block sizes."]
    pub fn multi_heap_get_allocated_size(
        heap: multi_heap_handle_t,
        p: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Register a new heap for use\n\n This function initialises a heap at the specified address, and returns a handle for future heap operations.\n\n There is no equivalent function for deregistering a heap - if all blocks in the heap are free, you can immediately start using the memory for other purposes.\n\n @param start Start address of the memory to use for a new heap.\n @param size Size (in bytes) of the new heap.\n\n @return Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised."]
    pub fn multi_heap_register(
        start: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> multi_heap_handle_t;
}
unsafe extern "C" {
    #[doc = " @brief Associate a private lock pointer with a heap\n\n The lock argument is supplied to the MULTI_HEAP_LOCK() and MULTI_HEAP_UNLOCK() macros, defined in multi_heap_platform.h.\n\n The lock in question must be recursive.\n\n When the heap is first registered, the associated lock is NULL.\n\n @param heap Handle to a registered heap.\n @param lock Optional pointer to a locking structure to associate with this heap."]
    pub fn multi_heap_set_lock(heap: multi_heap_handle_t, lock: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Dump heap information to stdout\n\n For debugging purposes, this function dumps information about every block in the heap to stdout.\n\n @param heap Handle to a registered heap."]
    pub fn multi_heap_dump(heap: multi_heap_handle_t);
}
unsafe extern "C" {
    #[doc = " @brief Check heap integrity\n\n Walks the heap and checks all heap data structures are valid. If any errors are detected, an error-specific message\n can be optionally printed to stderr. Print behaviour can be overridden at compile time by defining\n MULTI_CHECK_FAIL_PRINTF in multi_heap_platform.h.\n\n @note This function is not thread-safe as it sets a global variable with the value of print_errors.\n\n @param heap Handle to a registered heap.\n @param print_errors If true, errors will be printed to stderr.\n @return true if heap is valid, false otherwise."]
    pub fn multi_heap_check(heap: multi_heap_handle_t, print_errors: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Return free heap size\n\n Returns the number of bytes available in the heap.\n\n Equivalent to the total_free_bytes member returned by multi_heap_get_heap_info().\n\n Note that the heap may be fragmented, so the actual maximum size for a single malloc() may be lower. To know this\n size, see the largest_free_block member returned by multi_heap_get_heap_info().\n\n @param heap Handle to a registered heap.\n @return Number of free bytes."]
    pub fn multi_heap_free_size(heap: multi_heap_handle_t) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Return the lifetime minimum free heap size\n\n Equivalent to the minimum_free_bytes member returned by multi_heap_get_info().\n\n Returns the lifetime \"low watermark\" of possible values returned from multi_free_heap_size(), for the specified\n heap.\n\n @param heap Handle to a registered heap.\n @return Number of free bytes."]
    pub fn multi_heap_minimum_free_size(heap: multi_heap_handle_t) -> usize;
}
#[doc = " @brief Structure to access heap metadata via multi_heap_get_info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info_t {
    #[doc = "<  Total free bytes in the heap. Equivalent to multi_free_heap_size()."]
    pub total_free_bytes: usize,
    #[doc = "<  Total bytes allocated to data in the heap."]
    pub total_allocated_bytes: usize,
    #[doc = "<  Size of the largest free block in the heap. This is the largest malloc-able size."]
    pub largest_free_block: usize,
    #[doc = "<  Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size()."]
    pub minimum_free_bytes: usize,
    #[doc = "<  Number of (variable size) blocks allocated in the heap."]
    pub allocated_blocks: usize,
    #[doc = "<  Number of (variable size) free blocks in the heap."]
    pub free_blocks: usize,
    #[doc = "<  Total number of (variable size) blocks in the heap."]
    pub total_blocks: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of multi_heap_info_t"][::std::mem::size_of::<multi_heap_info_t>() - 56usize];
    ["Alignment of multi_heap_info_t"][::std::mem::align_of::<multi_heap_info_t>() - 8usize];
    ["Offset of field: multi_heap_info_t::total_free_bytes"]
        [::std::mem::offset_of!(multi_heap_info_t, total_free_bytes) - 0usize];
    ["Offset of field: multi_heap_info_t::total_allocated_bytes"]
        [::std::mem::offset_of!(multi_heap_info_t, total_allocated_bytes) - 8usize];
    ["Offset of field: multi_heap_info_t::largest_free_block"]
        [::std::mem::offset_of!(multi_heap_info_t, largest_free_block) - 16usize];
    ["Offset of field: multi_heap_info_t::minimum_free_bytes"]
        [::std::mem::offset_of!(multi_heap_info_t, minimum_free_bytes) - 24usize];
    ["Offset of field: multi_heap_info_t::allocated_blocks"]
        [::std::mem::offset_of!(multi_heap_info_t, allocated_blocks) - 32usize];
    ["Offset of field: multi_heap_info_t::free_blocks"]
        [::std::mem::offset_of!(multi_heap_info_t, free_blocks) - 40usize];
    ["Offset of field: multi_heap_info_t::total_blocks"]
        [::std::mem::offset_of!(multi_heap_info_t, total_blocks) - 48usize];
};
unsafe extern "C" {
    #[doc = " @brief Return metadata about a given heap\n\n Fills a multi_heap_info_t structure with information about the specified heap.\n\n @param heap Handle to a registered heap.\n @param info Pointer to a structure to fill with heap metadata."]
    pub fn multi_heap_get_info(heap: multi_heap_handle_t, info: *mut multi_heap_info_t);
}
unsafe extern "C" {
    #[doc = " @brief Perform an aligned allocation from the provided offset\n\n @param heap The heap in which to perform the allocation\n @param size The size of the allocation\n @param alignment How the memory must be aligned\n @param offset The offset at which the alignment should start\n @return void* The ptr to the allocated memory"]
    pub fn multi_heap_aligned_alloc_offs(
        heap: multi_heap_handle_t,
        size: usize,
        alignment: usize,
        offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Reset the minimum_free_bytes value (setting it to free_bytes) and return the former value\n\n @param heap The heap in which the reset is taking place\n @return size_t the value of minimum_free_bytes before it is reset"]
    pub fn multi_heap_reset_minimum_free_bytes(heap: multi_heap_handle_t) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Set the value of minimum_free_bytes to new_minimum_free_bytes_value or keep\n the current value of minimum_free_bytes if it is smaller than new_minimum_free_bytes_value\n\n @param heap The heap in which the restore is taking place\n @param new_minimum_free_bytes_value The value to restore the minimum_free_bytes to"]
    pub fn multi_heap_restore_minimum_free_bytes(
        heap: multi_heap_handle_t,
        new_minimum_free_bytes_value: usize,
    );
}
#[doc = " @brief Callback called when walking the given heap blocks of memory\n\n @param block_ptr Pointer to the block data\n @param block_size The size of the block\n @param block_used Block status. 0: free, 1: allocated\n @param user_data Opaque pointer to user defined data\n\n @return True if the walker is expected to continue the heap traversal\n         False if the walker is expected to stop the traversal of the heap"]
pub type multi_heap_walker_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        block_ptr: *mut ::std::os::raw::c_void,
        block_size: usize,
        block_used: ::std::os::raw::c_int,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = " @brief Call the tlsf_walk_pool function of the heap given as parameter with\n the walker function passed as parameter\n\n @param heap The heap to traverse\n @param walker_func The walker to trigger on each block of the heap\n @param user_data Opaque pointer to user defined data"]
    pub fn multi_heap_walk(
        heap: multi_heap_handle_t,
        walker_func: multi_heap_walker_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn multi_heap_get_full_block_size(
        heap: multi_heap_handle_t,
        p: *mut ::std::os::raw::c_void,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Function walking through a given heap and returning the pointer to the\n allocated block containing the pointer passed as parameter.\n\n @note The heap parameter must be valid and the pointer parameter must\n belong to a block of allocated memory. The app will crash with an\n assertion failure if at least one of the parameter is invalid.\n\n @param heap The heap to walk through\n @param ptr The pointer to find the allocated block of\n @return Pointer to the allocated block containing the pointer ptr"]
    pub fn multi_heap_find_containing_block(
        heap: multi_heap_handle_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " @brief callback called when an allocation operation fails, if registered\n @param size in bytes of failed allocation\n @param caps capabilities requested of failed allocation\n @param function_name function which generated the failure"]
pub type esp_alloc_failed_hook_t = ::std::option::Option<
    unsafe extern "C" fn(size: usize, caps: u32, function_name: *const ::std::os::raw::c_char),
>;
unsafe extern "C" {
    #[doc = " @brief registers a callback function to be invoked if a memory allocation operation fails\n @param callback caller defined callback to be invoked\n @return ESP_OK if callback was registered."]
    pub fn heap_caps_register_failed_alloc_callback(callback: esp_alloc_failed_hook_t)
        -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities\n\n Equivalent semantics to libc malloc(), for capability-aware memory.\n\n @param size Size, in bytes, of the amount of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc(size: usize, caps: u32) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Free memory previously allocated via heap_caps_malloc() or heap_caps_realloc().\n\n Equivalent semantics to libc free(), for capability-aware memory.\n\n  In IDF, ``free(p)`` is equivalent to ``heap_caps_free(p)``.\n\n @param ptr Pointer to memory previously returned from heap_caps_malloc() or heap_caps_realloc(). Can be NULL."]
    pub fn heap_caps_free(ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Reallocate memory previously allocated via heap_caps_malloc() or heap_caps_realloc().\n\n Equivalent semantics to libc realloc(), for capability-aware memory.\n\n In IDF, ``realloc(p, s)`` is equivalent to ``heap_caps_realloc(p, s, MALLOC_CAP_8BIT)``.\n\n 'caps' parameter can be different to the capabilities that any original 'ptr' was allocated with. In this way,\n realloc can be used to \"move\" a buffer if necessary to ensure it meets a new set of capabilities.\n\n @param ptr Pointer to previously allocated memory, or NULL for a new allocation.\n @param size Size of the new buffer requested, or 0 to free the buffer.\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory desired for the new allocation.\n\n @return Pointer to a new buffer of size 'size' with capabilities 'caps', or NULL if allocation failed."]
    pub fn heap_caps_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        caps: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Allocate an aligned chunk of memory which has the given capabilities\n\n Equivalent semantics to libc aligned_alloc(), for capability-aware memory.\n @param alignment  How the pointer received needs to be aligned\n                   must be a power of two\n @param size Size, in bytes, of the amount of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure\n\n"]
    pub fn heap_caps_aligned_alloc(
        alignment: usize,
        size: usize,
        caps: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Used to deallocate memory previously allocated with heap_caps_aligned_alloc\n\n @param ptr Pointer to the memory allocated\n @note This function is deprecated, please consider using heap_caps_free() instead"]
    pub fn heap_caps_aligned_free(ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief Allocate an aligned chunk of memory which has the given capabilities. The initialized value in the memory is set to zero.\n\n @param alignment  How the pointer received needs to be aligned\n                   must be a power of two\n @param n    Number of continuing chunks of memory to allocate\n @param size Size, in bytes, of a chunk of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure\n"]
    pub fn heap_caps_aligned_calloc(
        alignment: usize,
        n: usize,
        size: usize,
        caps: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities. The initialized value in the memory is set to zero.\n\n Equivalent semantics to libc calloc(), for capability-aware memory.\n\n In IDF, ``calloc(p)`` is equivalent to ``heap_caps_calloc(p, MALLOC_CAP_8BIT)``.\n\n @param n    Number of continuing chunks of memory to allocate\n @param size Size, in bytes, of a chunk of memory to allocate\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory to be returned\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc(n: usize, size: usize, caps: u32) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Get the total size of all the regions that have the given capabilities\n\n This function takes all regions capable of having the given capabilities allocated in them\n and adds up the total space they have.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return total size in bytes"]
    pub fn heap_caps_get_total_size(caps: u32) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities\n\n This function takes all regions capable of having the given capabilities allocated in them\n and adds up the free space they have.\n\n @note Note that because of heap fragmentation it is probably not possible to allocate a single block of memory\n of this size. Use heap_caps_get_largest_free_block() for this purpose.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities\n\n This adds all the low watermarks of the regions capable of delivering the memory\n with the given capabilities.\n\n @note Note the result may be less than the global all-time minimum available heap of this kind, as \"low watermarks\" are\n tracked per-region. Individual regions' heaps may have reached their \"low watermarks\" at different points in time. However,\n this result still gives a \"worst case\" indication for all-time minimum free heap.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Get the largest free block of memory able to be allocated with the given capabilities.\n\n Returns the largest value of ``s`` for which ``heap_caps_malloc(s, caps)`` will succeed.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n\n @return Size of the largest free block in bytes."]
    pub fn heap_caps_get_largest_free_block(caps: u32) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Start monitoring the value of minimum_free_bytes from the moment this\n function is called instead of from startup.\n\n @note This allows to detect local lows of the minimum_free_bytes value\n that wouldn't be detected otherwise.\n\n @return esp_err_t ESP_OK if the function executed properly\n                   ESP_FAIL if called when monitoring already active"]
    pub fn heap_caps_monitor_local_minimum_free_size_start() -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Stop monitoring the value of minimum_free_bytes. After this call\n the minimum_free_bytes value calculated from startup will be returned in\n heap_caps_get_info and heap_caps_get_minimum_free_size.\n\n @return esp_err_t ESP_OK if the function executed properly\n                   ESP_FAIL if called when monitoring not active"]
    pub fn heap_caps_monitor_local_minimum_free_size_stop() -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get heap info for all regions with the given capabilities.\n\n Calls multi_heap_info() on all heaps which share the given capabilities. The information returned is an aggregate\n across all matching heaps. The meanings of fields are the same as defined for multi_heap_info_t, except that\n ``minimum_free_bytes`` has the same caveats described in heap_caps_get_minimum_free_size().\n\n @param info        Pointer to a structure which will be filled with relevant\n                    heap metadata.\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n"]
    pub fn heap_caps_get_info(info: *mut multi_heap_info_t, caps: u32);
}
unsafe extern "C" {
    #[doc = " @brief Print a summary of all memory with the given capabilities.\n\n Calls multi_heap_info on all heaps which share the given capabilities, and\n prints a two-line summary for each, then a total summary.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n"]
    pub fn heap_caps_print_heap_info(caps: u32);
}
unsafe extern "C" {
    #[doc = " @brief Check integrity of all heap memory in the system.\n\n Calls multi_heap_check on all heaps. Optionally print errors if heaps are corrupt.\n\n Calling this function is equivalent to calling heap_caps_check_integrity\n with the caps argument set to MALLOC_CAP_INVALID.\n\n @param print_errors Print specific errors if heap corruption is found.\n\n @note Please increase the value of `CONFIG_ESP_INT_WDT_TIMEOUT_MS` when using this API\n with PSRAM enabled.\n\n @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity_all(print_errors: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check integrity of all heaps with the given capabilities.\n\n Calls multi_heap_check on all heaps which share the given capabilities. Optionally\n print errors if the heaps are corrupt.\n\n See also heap_caps_check_integrity_all to check all heap memory\n in the system and heap_caps_check_integrity_addr to check memory\n around a single address.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory\n @param print_errors Print specific errors if heap corruption is found.\n\n @note Please increase the value of `CONFIG_ESP_INT_WDT_TIMEOUT_MS` when using this API\n with PSRAM capability flag.\n\n @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity(caps: u32, print_errors: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Check integrity of heap memory around a given address.\n\n This function can be used to check the integrity of a single region of heap memory,\n which contains the given address.\n\n This can be useful if debugging heap integrity for corruption at a known address,\n as it has a lower overhead than checking all heap regions. Note that if the corrupt\n address moves around between runs (due to timing or other factors) then this approach\n won't work, and you should call heap_caps_check_integrity or\n heap_caps_check_integrity_all instead.\n\n @note The entire heap region around the address is checked, not only the adjacent\n heap blocks.\n\n @param addr Address in memory. Check for corruption in region containing this address.\n @param print_errors Print specific errors if heap corruption is found.\n\n @return True if the heap containing the specified address is valid,\n False if at least one heap is corrupt or the address doesn't belong to a heap region."]
    pub fn heap_caps_check_integrity_addr(addr: isize, print_errors: bool) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Enable malloc() in external memory and set limit below which\n        malloc() attempts are placed in internal memory.\n\n When external memory is in use, the allocation strategy is to initially try to\n satisfy smaller allocation requests with internal memory and larger requests\n with external memory. This sets the limit between the two, as well as generally\n enabling allocation in external memory.\n\n @param limit       Limit, in bytes."]
    pub fn heap_caps_malloc_extmem_enable(limit: usize);
}
unsafe extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order.\n\n @attention The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory.\n            This API prefers to allocate memory with the first parameter. If failed, allocate memory with\n            the next parameter. It will try in this order until allocating a chunk of memory successfully\n            or fail to allocate memories with any of the parameters.\n\n @param size Size, in bytes, of the amount of memory to allocate\n @param num Number of variable parameters\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc_prefer(size: usize, num: usize, ...) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Reallocate a chunk of memory as preference in decreasing order.\n\n @param ptr Pointer to previously allocated memory, or NULL for a new allocation.\n @param size Size of the new buffer requested, or 0 to free the buffer.\n @param num Number of variable parameters\n\n @return Pointer to a new buffer of size 'size', or NULL if allocation failed."]
    pub fn heap_caps_realloc_prefer(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        num: usize,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order.\n\n @param n    Number of continuing chunks of memory to allocate\n @param size Size, in bytes, of a chunk of memory to allocate\n @param num  Number of variable parameters\n\n @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc_prefer(
        n: usize,
        size: usize,
        num: usize,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Dump the full structure of all heaps with matching capabilities.\n\n Prints a large amount of output to serial (because of locking limitations,\n the output bypasses stdout/stderr). For each (variable sized) block\n in each matching heap, the following output is printed on a single line:\n\n - Block address (the data buffer returned by malloc is 4 bytes after this\n   if heap debugging is set to Basic, or 8 bytes otherwise).\n - Data size (the data size may be larger than the size requested by malloc,\n   either due to heap fragmentation or because of heap debugging level).\n - Address of next block in the heap.\n - If the block is free, the address of the next free block is also printed.\n\n @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type\n                    of memory"]
    pub fn heap_caps_dump(caps: u32);
}
unsafe extern "C" {
    #[doc = " @brief Dump the full structure of all heaps.\n\n Covers all registered heaps. Prints a large amount of output to serial.\n\n Output is the same as for heap_caps_dump.\n"]
    pub fn heap_caps_dump_all();
}
unsafe extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with.\n\n @param ptr Pointer to currently allocated heap memory. Must be a pointer value previously\n returned by heap_caps_malloc, malloc, calloc, etc. and not yet freed.\n\n @note The app will crash with an assertion failure if the pointer is not valid.\n\n @return Size of the memory allocated at this block.\n"]
    pub fn heap_caps_get_allocated_size(ptr: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    #[doc = " @brief Return the size of the block containing the pointer passed as parameter.\n\n @param ptr Pointer to currently allocated heap memory. The pointer value\n must be within the allocated memory and the memory must not be freed.\n\n @note The app will crash with an assertion failure if the pointer is invalid.\n\n @return Size of the containing block allocated.\n"]
    pub fn heap_caps_get_containing_block_size(ptr: *mut ::std::os::raw::c_void) -> usize;
}
#[doc = " @brief Structure used to store heap related data passed to\n the walker callback function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct walker_heap_info {
    #[doc = "< Start address of the heap in which the block is located"]
    pub start: isize,
    #[doc = "< End address of the heap in which the block is located"]
    pub end: isize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of walker_heap_info"][::std::mem::size_of::<walker_heap_info>() - 16usize];
    ["Alignment of walker_heap_info"][::std::mem::align_of::<walker_heap_info>() - 8usize];
    ["Offset of field: walker_heap_info::start"]
        [::std::mem::offset_of!(walker_heap_info, start) - 0usize];
    ["Offset of field: walker_heap_info::end"]
        [::std::mem::offset_of!(walker_heap_info, end) - 8usize];
};
#[doc = " @brief Structure used to store heap related data passed to\n the walker callback function"]
pub type walker_heap_into_t = walker_heap_info;
#[doc = " @brief Structure used to store block related data passed to\n the walker callback function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct walker_block_info {
    #[doc = "< Pointer to the block data"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< The size of the block"]
    pub size: usize,
    #[doc = "< Block status. True: used, False: free"]
    pub used: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of walker_block_info"][::std::mem::size_of::<walker_block_info>() - 24usize];
    ["Alignment of walker_block_info"][::std::mem::align_of::<walker_block_info>() - 8usize];
    ["Offset of field: walker_block_info::ptr"]
        [::std::mem::offset_of!(walker_block_info, ptr) - 0usize];
    ["Offset of field: walker_block_info::size"]
        [::std::mem::offset_of!(walker_block_info, size) - 8usize];
    ["Offset of field: walker_block_info::used"]
        [::std::mem::offset_of!(walker_block_info, used) - 16usize];
};
#[doc = " @brief Structure used to store block related data passed to\n the walker callback function"]
pub type walker_block_info_t = walker_block_info;
#[doc = " @brief Function callback used to get information of memory block\n during calls to heap_caps_walk or heap_caps_walk_all\n\n @param heap_info See walker_heap_into_t\n @param block_info See walker_block_info_t\n @param user_data Opaque pointer to user defined data\n\n @return True to proceed with the heap traversal\n         False to stop the traversal of the current heap and continue\n         with the traversal of the next heap (if any)"]
pub type heap_caps_walker_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        heap_info: walker_heap_into_t,
        block_info: walker_block_info_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = " @brief Function called to walk through the heaps with the given set of capabilities\n\n @param caps The set of capabilities assigned to the heaps to walk through\n @param walker_func Callback called for each block of the heaps being traversed\n @param user_data Opaque pointer to user defined data"]
    pub fn heap_caps_walk(
        caps: u32,
        walker_func: heap_caps_walker_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @brief Function called to walk through all heaps defined by the heap component\n\n @param walker_func Callback called for each block of the heaps being traversed\n @param user_data Opaque pointer to user defined data"]
    pub fn heap_caps_walk_all(
        walker_func: heap_caps_walker_cb_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
unsafe extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
}
unsafe extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn _strtoimax_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn _strtoumax_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
        arg4: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn _wcstoimax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::std::os::raw::c_int,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn _wcstoumax_r(
        arg1: *mut _reent,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
        arg4: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn strtoimax_l(
        arg1: *const ::std::os::raw::c_char,
        _restrict: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn strtoumax_l(
        arg1: *const ::std::os::raw::c_char,
        _restrict: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
unsafe extern "C" {
    pub fn wcstoimax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::std::os::raw::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
unsafe extern "C" {
    pub fn wcstoumax_l(
        arg1: *const wchar_t,
        _restrict: *mut *mut wchar_t,
        arg2: ::std::os::raw::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
pub const soc_reset_reason_t_RESET_REASON_CHIP_POWER_ON: soc_reset_reason_t = 1;
pub const soc_reset_reason_t_RESET_REASON_CORE_SW: soc_reset_reason_t = 3;
pub const soc_reset_reason_t_RESET_REASON_CORE_DEEP_SLEEP: soc_reset_reason_t = 5;
pub const soc_reset_reason_t_RESET_REASON_CORE_SDIO: soc_reset_reason_t = 6;
pub const soc_reset_reason_t_RESET_REASON_CORE_MWDT0: soc_reset_reason_t = 7;
pub const soc_reset_reason_t_RESET_REASON_CORE_MWDT1: soc_reset_reason_t = 8;
pub const soc_reset_reason_t_RESET_REASON_CORE_RTC_WDT: soc_reset_reason_t = 9;
pub const soc_reset_reason_t_RESET_REASON_CPU0_MWDT0: soc_reset_reason_t = 11;
pub const soc_reset_reason_t_RESET_REASON_CPU1_MWDT1: soc_reset_reason_t = 11;
pub const soc_reset_reason_t_RESET_REASON_CPU0_SW: soc_reset_reason_t = 12;
pub const soc_reset_reason_t_RESET_REASON_CPU1_SW: soc_reset_reason_t = 12;
pub const soc_reset_reason_t_RESET_REASON_CPU0_RTC_WDT: soc_reset_reason_t = 13;
pub const soc_reset_reason_t_RESET_REASON_CPU1_RTC_WDT: soc_reset_reason_t = 13;
pub const soc_reset_reason_t_RESET_REASON_CPU1_CPU0: soc_reset_reason_t = 14;
pub const soc_reset_reason_t_RESET_REASON_SYS_BROWN_OUT: soc_reset_reason_t = 15;
pub const soc_reset_reason_t_RESET_REASON_SYS_RTC_WDT: soc_reset_reason_t = 16;
#[doc = " @brief Naming conventions: RESET_REASON_{reset level}_{reset reason}\n @note refer to TRM: <Reset and Clock> chapter"]
pub type soc_reset_reason_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Software Reset digital core include RTC.\n\n It is not recommended to use this function in esp-idf, use\n esp_restart() instead."]
    pub fn esp_rom_software_reset_system();
}
unsafe extern "C" {
    #[doc = " @brief Software Reset cpu core.\n\n It is not recommended to use this function in esp-idf, use\n esp_restart() instead.\n\n @param  cpu_no : The CPU to reset, 0 for PRO CPU, 1 for APP CPU."]
    pub fn esp_rom_software_reset_cpu(cpu_no: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " @brief Print formatted string to console device\n @note float and long long data are not supported!\n\n @param fmt Format string\n @param ... Additional arguments, depending on the format string\n @return int: Total number of characters written on success; A negative number on failure."]
    pub fn esp_rom_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Print formatted string to console device\n @note float and long long data are not supported!\n\n @param fmt Format string\n @param ap List of arguments.\n @return int: Total number of characters written on success; A negative number on failure."]
    pub fn esp_rom_vprintf(
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Convert an unsigned integer value to a string representation in the specified radix.\n\n This function converts the given unsigned integer value to a string representation in the specified radix.\n The resulting string is stored in the provided character buffer `buf`.\n\n @param[in] val    The unsigned integer value to be converted.\n @param[in] radix  The base of the numeral system to be used for the conversion.\n                   It determines the number of unique digits in the numeral system\n                   (e.g., 2 for binary, 10 for decimal, 16 for hexadecimal).\n @param[in] pad    The optional padding width (0 - unused) for the resulting string. It adds zero-padding.\n                   (val=123, pad=6 -> result=000123).\n @param[in] digits Pointer to a character array representing the digits of the\n                   numeral system. The array must contain characters in the order of increasing\n                   values, corresponding to the digits of the radix. For example, \"0123456789ABCDEF\"\n                   or hexadecimal.\n @param[out] buf   Pointer to the character buffer where the resulting string will\n                   be stored. The buffer must have enough space to accommodate the entire converted\n                   string, including the null-terminator.\n\n @return The length of the resulting string (excluding the null-terminator).\n\n @note The buffer `buf` must have sufficient space to hold the entire converted string, including the null-terminator.\n       The caller is responsible for ensuring the buffer's size is large enough to prevent buffer overflow.\n @note The provided `digits` array must have enough elements to cover the entire radix used for conversion. Otherwise, undefined behavior may occur."]
    pub fn esp_rom_cvt(
        val: ::std::os::raw::c_ulonglong,
        radix: ::std::os::raw::c_long,
        pad: ::std::os::raw::c_int,
        digits: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Pauses execution for us microseconds\n\n @param us Number of microseconds to pause"]
    pub fn esp_rom_delay_us(us: u32);
}
unsafe extern "C" {
    #[doc = " @brief esp_rom_printf can print message to different channels simultaneously.\n        This function can help install the low level putc function for esp_rom_printf.\n\n @param channel Channel number (starting from 1)\n @param putc Function pointer to the putc implementation. Set NULL can disconnect esp_rom_printf with putc."]
    pub fn esp_rom_install_channel_putc(
        channel: ::std::os::raw::c_int,
        putc: ::std::option::Option<unsafe extern "C" fn(c: ::std::os::raw::c_char)>,
    );
}
unsafe extern "C" {
    #[doc = " @brief It outputs a character to different channels simultaneously.\n        This function is used by esp_rom_printf/esp_rom_vprintf.\n\n @param c Char to output."]
    pub fn esp_rom_output_to_channels(c: ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief Install UART1 as the default console channel, equivalent to `esp_rom_install_channel_putc(1, esp_rom_output_putc)`"]
    pub fn esp_rom_install_uart_printf();
}
unsafe extern "C" {
    #[doc = " @brief Get reset reason of CPU\n\n @param cpu_no CPU number\n @return Reset reason code (see in soc/reset_reasons.h)"]
    pub fn esp_rom_get_reset_reason(cpu_no: ::std::os::raw::c_int) -> soc_reset_reason_t;
}
unsafe extern "C" {
    #[doc = " @brief Route peripheral interrupt sources to CPU's interrupt port by matrix\n\n Usually there're 4 steps to use an interrupt:\n 1. Route peripheral interrupt source to CPU. e.g.  esp_rom_route_intr_matrix(0, ETS_WIFI_MAC_INTR_SOURCE, ETS_WMAC_INUM)\n 2. Set interrupt handler for CPU\n 3. Enable CPU interrupt\n 4. Enable peripheral interrupt\n\n @param cpu_core The CPU number, which the peripheral interrupt will inform to\n @param periph_intr_id The peripheral interrupt source number\n @param cpu_intr_num The CPU (external) interrupt number. On targets that use CLIC as their interrupt controller,\n                     this number represents the external interrupt number. For example, passing `cpu_intr_num = i`\n                     to this function would in fact bind peripheral source to CPU interrupt `CLIC_EXT_INTR_NUM_OFFSET + i`."]
    pub fn esp_rom_route_intr_matrix(
        cpu_core: ::std::os::raw::c_int,
        periph_intr_id: u32,
        cpu_intr_num: u32,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the real CPU ticks per us\n\n @return CPU ticks per us"]
    pub fn esp_rom_get_cpu_ticks_per_us() -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Set the real CPU tick rate\n\n @note Call this function when CPU frequency is changed, otherwise the `esp_rom_delay_us` can be inaccurate.\n\n @param ticks_per_us CPU ticks per us"]
    pub fn esp_rom_set_cpu_ticks_per_us(ticks_per_us: u32);
}
unsafe extern "C" {
    #[doc = " Return full IDF version string, same as 'git describe' output.\n\n @note If you are printing the ESP-IDF version in a log file or other information,\n this function provides more information than using the numerical version macros.\n For example, numerical version macros don't differentiate between development,\n pre-release and release versions, but the output of this function does.\n\n @return constant string from IDF_VER"]
    pub fn esp_get_idf_version() -> *const ::std::os::raw::c_char;
}
#[doc = "!< Reset reason can not be determined"]
pub const esp_reset_reason_t_ESP_RST_UNKNOWN: esp_reset_reason_t = 0;
#[doc = "!< Reset due to power-on event"]
pub const esp_reset_reason_t_ESP_RST_POWERON: esp_reset_reason_t = 1;
#[doc = "!< Reset by external pin (not applicable for ESP32)"]
pub const esp_reset_reason_t_ESP_RST_EXT: esp_reset_reason_t = 2;
#[doc = "!< Software reset via esp_restart"]
pub const esp_reset_reason_t_ESP_RST_SW: esp_reset_reason_t = 3;
#[doc = "!< Software reset due to exception/panic"]
pub const esp_reset_reason_t_ESP_RST_PANIC: esp_reset_reason_t = 4;
#[doc = "!< Reset (software or hardware) due to interrupt watchdog"]
pub const esp_reset_reason_t_ESP_RST_INT_WDT: esp_reset_reason_t = 5;
#[doc = "!< Reset due to task watchdog"]
pub const esp_reset_reason_t_ESP_RST_TASK_WDT: esp_reset_reason_t = 6;
#[doc = "!< Reset due to other watchdogs"]
pub const esp_reset_reason_t_ESP_RST_WDT: esp_reset_reason_t = 7;
#[doc = "!< Reset after exiting deep sleep mode"]
pub const esp_reset_reason_t_ESP_RST_DEEPSLEEP: esp_reset_reason_t = 8;
#[doc = "!< Brownout reset (software or hardware)"]
pub const esp_reset_reason_t_ESP_RST_BROWNOUT: esp_reset_reason_t = 9;
#[doc = "!< Reset over SDIO"]
pub const esp_reset_reason_t_ESP_RST_SDIO: esp_reset_reason_t = 10;
#[doc = "!< Reset by USB peripheral"]
pub const esp_reset_reason_t_ESP_RST_USB: esp_reset_reason_t = 11;
#[doc = "!< Reset by JTAG"]
pub const esp_reset_reason_t_ESP_RST_JTAG: esp_reset_reason_t = 12;
#[doc = "!< Reset due to efuse error"]
pub const esp_reset_reason_t_ESP_RST_EFUSE: esp_reset_reason_t = 13;
#[doc = "!< Reset due to power glitch detected"]
pub const esp_reset_reason_t_ESP_RST_PWR_GLITCH: esp_reset_reason_t = 14;
#[doc = "!< Reset due to CPU lock up (double exception)"]
pub const esp_reset_reason_t_ESP_RST_CPU_LOCKUP: esp_reset_reason_t = 15;
#[doc = " @brief Reset reasons"]
pub type esp_reset_reason_t = ::std::os::raw::c_uint;
#[doc = " Shutdown handler type"]
pub type shutdown_handler_t = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    #[doc = " @brief  Register shutdown handler\n\n This function allows you to register a handler that gets invoked before\n the application is restarted using esp_restart function.\n @param handle function to execute on restart\n @return\n   - ESP_OK on success\n   - ESP_ERR_INVALID_STATE if the handler has already been registered\n   - ESP_ERR_NO_MEM if no more shutdown handler slots are available"]
    pub fn esp_register_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief  Unregister shutdown handler\n\n This function allows you to unregister a handler which was previously\n registered using esp_register_shutdown_handler function.\n   - ESP_OK on success\n   - ESP_ERR_INVALID_STATE if the given handler hasn't been registered before"]
    pub fn esp_unregister_shutdown_handler(handle: shutdown_handler_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief  Restart PRO and APP CPUs.\n\n This function can be called both from PRO and APP CPUs.\n After successful restart, CPU reset reason will be SW_CPU_RESET.\n Peripherals (except for Wi-Fi, BT, UART0, SPI1, and legacy timers) are not reset.\n This function does not return."]
    pub fn esp_restart() -> !;
}
unsafe extern "C" {
    #[doc = " @brief  Get reason of last reset\n @return See description of esp_reset_reason_t for explanation of each value."]
    pub fn esp_reset_reason() -> esp_reset_reason_t;
}
unsafe extern "C" {
    #[doc = " @brief  Get the size of available heap.\n\n @note Note that the returned value may be larger than the maximum contiguous block\n which can be allocated.\n\n @return Available heap size, in bytes."]
    pub fn esp_get_free_heap_size() -> u32;
}
unsafe extern "C" {
    #[doc = " @brief  Get the size of available internal heap.\n\n @note Note that the returned value may be larger than the maximum contiguous block\n which can be allocated.\n\n @return Available internal heap size, in bytes."]
    pub fn esp_get_free_internal_heap_size() -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Get the minimum heap that has ever been available\n\n @return Minimum free heap ever available"]
    pub fn esp_get_minimum_free_heap_size() -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Trigger a software abort\n\n @param details Details that will be displayed during panic handling."]
    pub fn esp_system_abort(details: *const ::std::os::raw::c_char) -> !;
}
pub type StackType_t = u8;
pub type BaseType_t = ::std::os::raw::c_int;
pub type UBaseType_t = ::std::os::raw::c_uint;
pub type TickType_t = u32;
unsafe extern "C" {
    #[doc = " @brief Checks if the current core is in an ISR context\n\n - ISR context consist of Low/Mid priority ISR, or time tick ISR\n - High priority ISRs aren't detected here, but they normally cannot call C code, so that should not be an issue anyway.\n\n @note [refactor-todo] Check if this should be inlined\n @return\n  - pdTRUE if in ISR\n  - pdFALSE otherwise"]
    pub fn xPortInIsrContext() -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @brief Assert if in ISR context\n\n - Asserts on xPortInIsrContext() internally"]
    pub fn vPortAssertIfInISR();
}
unsafe extern "C" {
    #[doc = " @brief Check if in ISR context from High priority ISRs\n\n - Called from High priority ISR\n - Checks if the previous context (before high priority interrupt) was in ISR context (meaning low/med priority)\n\n @note [refactor-todo] Check if this should be inlined\n @return\n  - pdTRUE if in previous in ISR context\n  - pdFALSE otherwise"]
    pub fn xPortInterruptedFromISRContext() -> BaseType_t;
}
pub type portMUX_TYPE = spinlock_t;
unsafe extern "C" {
    #[doc = " @brief Enter a SMP critical section with a timeout\n\n This function enters an SMP critical section by disabling interrupts then\n taking a spinlock with a specified timeout.\n\n This function can be called in a nested manner.\n\n @note This function is made non-inline on purpose to reduce code size\n @param mux Spinlock\n @param timeout Timeout to wait for spinlock in number of CPU cycles.\n                Use portMUX_NO_TIMEOUT to wait indefinitely\n                Use portMUX_TRY_LOCK to only getting the spinlock a single time\n @retval pdPASS Critical section entered (spinlock taken)\n @retval pdFAIL If timed out waiting for spinlock (will not occur if using portMUX_NO_TIMEOUT)"]
    pub fn xPortEnterCriticalTimeout(mux: *mut portMUX_TYPE, timeout: BaseType_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @brief Exit a SMP critical section\n\n This function can be called in a nested manner. On the outer most level of nesting, this function will:\n\n - Release the spinlock\n - Restore the previous interrupt level before the critical section was entered\n\n If still nesting, this function simply decrements a critical nesting count\n\n @note This function is made non-inline on purpose to reduce code size\n @param[in] mux Spinlock"]
    pub fn vPortExitCritical(mux: *mut portMUX_TYPE);
}
unsafe extern "C" {
    #[doc = " @brief FreeRTOS Compliant version of xPortEnterCriticalTimeout()\n\n Compliant version of xPortEnterCriticalTimeout() will ensure that this is\n called from a task context only. An abort is called otherwise.\n\n @note This function is made non-inline on purpose to reduce code size\n\n @param mux Spinlock\n @param timeout Timeout\n @return BaseType_t"]
    pub fn xPortEnterCriticalTimeoutCompliance(
        mux: *mut portMUX_TYPE,
        timeout: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @brief FreeRTOS compliant version of vPortExitCritical()\n\n Compliant version of vPortExitCritical() will ensure that this is\n called from a task context only. An abort is called otherwise.\n\n @note This function is made non-inline on purpose to reduce code size\n @param[in] mux Spinlock"]
    pub fn vPortExitCriticalCompliance(mux: *mut portMUX_TYPE);
}
unsafe extern "C" {
    #[doc = " @brief Perform a solicited context switch\n\n - Defined in portasm.S\n\n @note [refactor-todo] The rest of ESP-IDF should call taskYield() instead"]
    pub fn vPortYield();
}
unsafe extern "C" {
    #[doc = " @brief Yields the other core\n\n - Send an interrupt to another core in order to make the task running on it yield for a higher-priority task.\n - Can be used to yield current core as well\n\n @note [refactor-todo] Put this into private macros as its only called from task.c and is not public API\n @param coreid ID of core to yield"]
    pub fn vPortYieldOtherCore(coreid: BaseType_t);
}
unsafe extern "C" {
    #[doc = " @brief Hook function called on entry to tickless idle\n\n - Implemented in pm_impl.c\n\n @param xExpectedIdleTime Expected idle time"]
    pub fn vApplicationSleep(xExpectedIdleTime: TickType_t);
}
unsafe extern "C" {
    #[doc = " @brief Get the tick rate per second\n\n @note [refactor-todo] make this inline\n @return uint32_t Tick rate in Hz"]
    pub fn xPortGetTickRateHz() -> u32;
}
unsafe extern "C" {
    #[doc = " @brief Set a watchpoint to watch the last 32 bytes of the stack\n\n Callback to set a watchpoint on the end of the stack. Called every context switch to change the stack watchpoint\n around.\n\n @param pxStackStart Pointer to the start of the stack"]
    pub fn vPortSetStackWatchpoint(pxStackStart: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " @brief TCB cleanup hook\n\n The portCLEAN_UP_TCB() macro is called in prvDeleteTCB() right before a\n deleted task's memory is freed. We map that macro to this internal function\n so that IDF FreeRTOS ports can inject some task pre-deletion operations.\n\n @note We can't use vPortCleanUpTCB() due to API compatibility issues. See\n CONFIG_FREERTOS_ENABLE_STATIC_TASK_CLEAN_UP. Todo: IDF-8097"]
    pub fn vPortTCBPreDeleteHook(pxTCB: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _frxt_setup_switch();
}
unsafe extern "C" {
    #[doc = " @brief Checks if a given piece of memory can be used to store a FreeRTOS list\n\n - Defined in heap_idf.c\n\n @param ptr Pointer to memory\n @return true Memory can be used to store a List\n @return false Otherwise"]
    pub fn xPortCheckValidListMem(ptr: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Checks if a given piece of memory can be used to store a task's TCB\n\n - Defined in heap_idf.c\n\n @param ptr Pointer to memory\n @return true Memory can be used to store a TCB\n @return false Otherwise"]
    pub fn xPortCheckValidTCBMem(ptr: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Checks if a given piece of memory can be used to store a task's stack\n\n - Defined in heap_idf.c\n\n @param ptr Pointer to memory\n @return true Memory can be used to store a task stack\n @return false Otherwise"]
    pub fn xPortcheckValidStackMem(ptr: *const ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::std::os::raw::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of HeapRegion"][::std::mem::size_of::<HeapRegion>() - 16usize];
    ["Alignment of HeapRegion"][::std::mem::align_of::<HeapRegion>() - 8usize];
    ["Offset of field: HeapRegion::pucStartAddress"]
        [::std::mem::offset_of!(HeapRegion, pucStartAddress) - 0usize];
    ["Offset of field: HeapRegion::xSizeInBytes"]
        [::std::mem::offset_of!(HeapRegion, xSizeInBytes) - 8usize];
};
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xHeapStats {
    pub xAvailableHeapSpaceInBytes: usize,
    pub xSizeOfLargestFreeBlockInBytes: usize,
    pub xSizeOfSmallestFreeBlockInBytes: usize,
    pub xNumberOfFreeBlocks: usize,
    pub xMinimumEverFreeBytesRemaining: usize,
    pub xNumberOfSuccessfulAllocations: usize,
    pub xNumberOfSuccessfulFrees: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xHeapStats"][::std::mem::size_of::<xHeapStats>() - 56usize];
    ["Alignment of xHeapStats"][::std::mem::align_of::<xHeapStats>() - 8usize];
    ["Offset of field: xHeapStats::xAvailableHeapSpaceInBytes"]
        [::std::mem::offset_of!(xHeapStats, xAvailableHeapSpaceInBytes) - 0usize];
    ["Offset of field: xHeapStats::xSizeOfLargestFreeBlockInBytes"]
        [::std::mem::offset_of!(xHeapStats, xSizeOfLargestFreeBlockInBytes) - 8usize];
    ["Offset of field: xHeapStats::xSizeOfSmallestFreeBlockInBytes"]
        [::std::mem::offset_of!(xHeapStats, xSizeOfSmallestFreeBlockInBytes) - 16usize];
    ["Offset of field: xHeapStats::xNumberOfFreeBlocks"]
        [::std::mem::offset_of!(xHeapStats, xNumberOfFreeBlocks) - 24usize];
    ["Offset of field: xHeapStats::xMinimumEverFreeBytesRemaining"]
        [::std::mem::offset_of!(xHeapStats, xMinimumEverFreeBytesRemaining) - 32usize];
    ["Offset of field: xHeapStats::xNumberOfSuccessfulAllocations"]
        [::std::mem::offset_of!(xHeapStats, xNumberOfSuccessfulAllocations) - 40usize];
    ["Offset of field: xHeapStats::xNumberOfSuccessfulFrees"]
        [::std::mem::offset_of!(xHeapStats, xNumberOfSuccessfulFrees) - 48usize];
};
pub type HeapStats_t = xHeapStats;
unsafe extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
unsafe extern "C" {
    pub fn vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
unsafe extern "C" {
    pub fn pvPortMalloc(xSize: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pvPortCalloc(xNum: usize, xSize: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vPortFree(pv: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vPortInitialiseBlocks();
}
unsafe extern "C" {
    pub fn xPortGetFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> usize;
}
unsafe extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vPortEndScheduler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST_ITEM"][::std::mem::size_of::<xSTATIC_LIST_ITEM>() - 40usize];
    ["Alignment of xSTATIC_LIST_ITEM"][::std::mem::align_of::<xSTATIC_LIST_ITEM>() - 8usize];
    ["Offset of field: xSTATIC_LIST_ITEM::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_LIST_ITEM, xDummy2) - 0usize];
    ["Offset of field: xSTATIC_LIST_ITEM::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_MINI_LIST_ITEM"][::std::mem::size_of::<xSTATIC_MINI_LIST_ITEM>() - 24usize];
    ["Alignment of xSTATIC_MINI_LIST_ITEM"]
        [::std::mem::align_of::<xSTATIC_MINI_LIST_ITEM>() - 8usize];
    ["Offset of field: xSTATIC_MINI_LIST_ITEM::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_MINI_LIST_ITEM, xDummy2) - 0usize];
    ["Offset of field: xSTATIC_MINI_LIST_ITEM::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_MINI_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut ::std::os::raw::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST"][::std::mem::size_of::<xSTATIC_LIST>() - 40usize];
    ["Alignment of xSTATIC_LIST"][::std::mem::align_of::<xSTATIC_LIST>() - 8usize];
    ["Offset of field: xSTATIC_LIST::uxDummy2"]
        [::std::mem::offset_of!(xSTATIC_LIST, uxDummy2) - 0usize];
    ["Offset of field: xSTATIC_LIST::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_LIST, pvDummy3) - 8usize];
    ["Offset of field: xSTATIC_LIST::xDummy4"]
        [::std::mem::offset_of!(xSTATIC_LIST, xDummy4) - 16usize];
};
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::std::os::raw::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::std::os::raw::c_void,
    pub ucDummy7: [u8; 16usize],
    pub xDummyCoreID: BaseType_t,
    pub pxDummy8: *mut ::std::os::raw::c_void,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut ::std::os::raw::c_void; 2usize],
    pub ulDummy18: [u32; 1usize],
    pub ucDummy19: [u8; 1usize],
    pub uxDummy20: u8,
    pub ucDummy21: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TCB"][::std::mem::size_of::<xSTATIC_TCB>() - 168usize];
    ["Alignment of xSTATIC_TCB"][::std::mem::align_of::<xSTATIC_TCB>() - 8usize];
    ["Offset of field: xSTATIC_TCB::pxDummy1"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy1) - 0usize];
    ["Offset of field: xSTATIC_TCB::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_TCB, xDummy3) - 8usize];
    ["Offset of field: xSTATIC_TCB::uxDummy5"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy5) - 88usize];
    ["Offset of field: xSTATIC_TCB::pxDummy6"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy6) - 96usize];
    ["Offset of field: xSTATIC_TCB::ucDummy7"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy7) - 104usize];
    ["Offset of field: xSTATIC_TCB::xDummyCoreID"]
        [::std::mem::offset_of!(xSTATIC_TCB, xDummyCoreID) - 120usize];
    ["Offset of field: xSTATIC_TCB::pxDummy8"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy8) - 128usize];
    ["Offset of field: xSTATIC_TCB::uxDummy12"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy12) - 136usize];
    ["Offset of field: xSTATIC_TCB::pvDummy15"]
        [::std::mem::offset_of!(xSTATIC_TCB, pvDummy15) - 144usize];
    ["Offset of field: xSTATIC_TCB::ulDummy18"]
        [::std::mem::offset_of!(xSTATIC_TCB, ulDummy18) - 160usize];
    ["Offset of field: xSTATIC_TCB::ucDummy19"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy19) - 164usize];
    ["Offset of field: xSTATIC_TCB::uxDummy20"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy20) - 165usize];
    ["Offset of field: xSTATIC_TCB::ucDummy21"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy21) - 166usize];
};
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ::std::os::raw::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub ucDummy6: u8,
    pub pvDummy7: *mut ::std::os::raw::c_void,
    pub xDummyQueueLock: portMUX_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ::std::os::raw::c_void,
    pub uxDummy2: UBaseType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_QUEUE__bindgen_ty_1"]
        [::std::mem::size_of::<xSTATIC_QUEUE__bindgen_ty_1>() - 8usize];
    ["Alignment of xSTATIC_QUEUE__bindgen_ty_1"]
        [::std::mem::align_of::<xSTATIC_QUEUE__bindgen_ty_1>() - 8usize];
    ["Offset of field: xSTATIC_QUEUE__bindgen_ty_1::pvDummy2"]
        [::std::mem::offset_of!(xSTATIC_QUEUE__bindgen_ty_1, pvDummy2) - 0usize];
    ["Offset of field: xSTATIC_QUEUE__bindgen_ty_1::uxDummy2"]
        [::std::mem::offset_of!(xSTATIC_QUEUE__bindgen_ty_1, uxDummy2) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_QUEUE"][::std::mem::size_of::<xSTATIC_QUEUE>() - 144usize];
    ["Alignment of xSTATIC_QUEUE"][::std::mem::align_of::<xSTATIC_QUEUE>() - 8usize];
    ["Offset of field: xSTATIC_QUEUE::pvDummy1"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, pvDummy1) - 0usize];
    ["Offset of field: xSTATIC_QUEUE::u"][::std::mem::offset_of!(xSTATIC_QUEUE, u) - 24usize];
    ["Offset of field: xSTATIC_QUEUE::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, xDummy3) - 32usize];
    ["Offset of field: xSTATIC_QUEUE::uxDummy4"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, uxDummy4) - 112usize];
    ["Offset of field: xSTATIC_QUEUE::ucDummy5"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, ucDummy5) - 124usize];
    ["Offset of field: xSTATIC_QUEUE::ucDummy6"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, ucDummy6) - 126usize];
    ["Offset of field: xSTATIC_QUEUE::pvDummy7"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, pvDummy7) - 128usize];
    ["Offset of field: xSTATIC_QUEUE::xDummyQueueLock"]
        [::std::mem::offset_of!(xSTATIC_QUEUE, xDummyQueueLock) - 136usize];
};
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub ucDummy4: u8,
    pub xDummyEventGroupLock: portMUX_TYPE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_EVENT_GROUP"][::std::mem::size_of::<xSTATIC_EVENT_GROUP>() - 64usize];
    ["Alignment of xSTATIC_EVENT_GROUP"][::std::mem::align_of::<xSTATIC_EVENT_GROUP>() - 8usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::xDummy1"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummy1) - 0usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummy2) - 8usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::ucDummy4"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, ucDummy4) - 48usize];
    ["Offset of field: xSTATIC_EVENT_GROUP::xDummyEventGroupLock"]
        [::std::mem::offset_of!(xSTATIC_EVENT_GROUP, xDummyEventGroupLock) - 52usize];
};
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ::std::os::raw::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut ::std::os::raw::c_void,
    pub pvDummy6: TaskFunction_t,
    pub ucDummy8: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TIMER"][::std::mem::size_of::<xSTATIC_TIMER>() - 80usize];
    ["Alignment of xSTATIC_TIMER"][::std::mem::align_of::<xSTATIC_TIMER>() - 8usize];
    ["Offset of field: xSTATIC_TIMER::pvDummy1"]
        [::std::mem::offset_of!(xSTATIC_TIMER, pvDummy1) - 0usize];
    ["Offset of field: xSTATIC_TIMER::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_TIMER, xDummy2) - 8usize];
    ["Offset of field: xSTATIC_TIMER::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_TIMER, xDummy3) - 48usize];
    ["Offset of field: xSTATIC_TIMER::pvDummy5"]
        [::std::mem::offset_of!(xSTATIC_TIMER, pvDummy5) - 56usize];
    ["Offset of field: xSTATIC_TIMER::pvDummy6"]
        [::std::mem::offset_of!(xSTATIC_TIMER, pvDummy6) - 64usize];
    ["Offset of field: xSTATIC_TIMER::ucDummy8"]
        [::std::mem::offset_of!(xSTATIC_TIMER, ucDummy8) - 72usize];
};
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [usize; 4usize],
    pub pvDummy2: [*mut ::std::os::raw::c_void; 3usize],
    pub ucDummy3: u8,
    pub xDummyStreamBufferLock: portMUX_TYPE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_STREAM_BUFFER"][::std::mem::size_of::<xSTATIC_STREAM_BUFFER>() - 72usize];
    ["Alignment of xSTATIC_STREAM_BUFFER"]
        [::std::mem::align_of::<xSTATIC_STREAM_BUFFER>() - 8usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::uxDummy1"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, uxDummy1) - 0usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::pvDummy2"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, pvDummy2) - 32usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::ucDummy3"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, ucDummy3) - 56usize];
    ["Offset of field: xSTATIC_STREAM_BUFFER::xDummyStreamBufferLock"]
        [::std::mem::offset_of!(xSTATIC_STREAM_BUFFER, xDummyStreamBufferLock) - 60usize];
};
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut ::std::os::raw::c_void,
    pub pxContainer: *mut xLIST,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xLIST_ITEM"][::std::mem::size_of::<xLIST_ITEM>() - 40usize];
    ["Alignment of xLIST_ITEM"][::std::mem::align_of::<xLIST_ITEM>() - 8usize];
    ["Offset of field: xLIST_ITEM::xItemValue"]
        [::std::mem::offset_of!(xLIST_ITEM, xItemValue) - 0usize];
    ["Offset of field: xLIST_ITEM::pxNext"][::std::mem::offset_of!(xLIST_ITEM, pxNext) - 8usize];
    ["Offset of field: xLIST_ITEM::pxPrevious"]
        [::std::mem::offset_of!(xLIST_ITEM, pxPrevious) - 16usize];
    ["Offset of field: xLIST_ITEM::pvOwner"][::std::mem::offset_of!(xLIST_ITEM, pvOwner) - 24usize];
    ["Offset of field: xLIST_ITEM::pxContainer"]
        [::std::mem::offset_of!(xLIST_ITEM, pxContainer) - 32usize];
};
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xMINI_LIST_ITEM"][::std::mem::size_of::<xMINI_LIST_ITEM>() - 24usize];
    ["Alignment of xMINI_LIST_ITEM"][::std::mem::align_of::<xMINI_LIST_ITEM>() - 8usize];
    ["Offset of field: xMINI_LIST_ITEM::xItemValue"]
        [::std::mem::offset_of!(xMINI_LIST_ITEM, xItemValue) - 0usize];
    ["Offset of field: xMINI_LIST_ITEM::pxNext"]
        [::std::mem::offset_of!(xMINI_LIST_ITEM, pxNext) - 8usize];
    ["Offset of field: xMINI_LIST_ITEM::pxPrevious"]
        [::std::mem::offset_of!(xMINI_LIST_ITEM, pxPrevious) - 16usize];
};
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xLIST"][::std::mem::size_of::<xLIST>() - 40usize];
    ["Alignment of xLIST"][::std::mem::align_of::<xLIST>() - 8usize];
    ["Offset of field: xLIST::uxNumberOfItems"]
        [::std::mem::offset_of!(xLIST, uxNumberOfItems) - 0usize];
    ["Offset of field: xLIST::pxIndex"][::std::mem::offset_of!(xLIST, pxIndex) - 8usize];
    ["Offset of field: xLIST::xListEnd"][::std::mem::offset_of!(xLIST, xListEnd) - 16usize];
};
pub type List_t = xLIST;
unsafe extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
unsafe extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
unsafe extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate\n returns (via a pointer parameter) an TaskHandle_t variable that can then\n be used as a parameter to vTaskDelete to delete the task.\n\n \\ingroup Tasks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
#[doc = " Defines the prototype to which the application task hook function must\n conform."]
pub type TaskHookFunction_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> BaseType_t>;
#[doc = "< A task is querying the state of itself, so must be running."]
pub const eTaskState_eRunning: eTaskState = 0;
#[doc = "< The task being queried is in a ready or pending ready list."]
pub const eTaskState_eReady: eTaskState = 1;
#[doc = "< The task being queried is in the Blocked state."]
pub const eTaskState_eBlocked: eTaskState = 2;
#[doc = "< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out."]
pub const eTaskState_eSuspended: eTaskState = 3;
#[doc = "< The task being queried has been deleted, but its TCB has not yet been freed."]
pub const eTaskState_eDeleted: eTaskState = 4;
#[doc = "< Used as an 'invalid state' value."]
pub const eTaskState_eInvalid: eTaskState = 5;
#[doc = " Task states returned by eTaskGetState."]
pub type eTaskState = ::std::os::raw::c_uint;
#[doc = "< Notify the task without updating its notify value."]
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
#[doc = "< Set bits in the task's notification value."]
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
#[doc = "< Increment the task's notification value."]
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
#[doc = "< Set the task's notification value to a specific value even if the previous value has not yet been read by the task."]
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
#[doc = "< Set the task's notification value if the previous value has been read by the task."]
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
#[doc = " Actions that can be performed when vTaskNotify() is called."]
pub type eNotifyAction = ::std::os::raw::c_uint;
#[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTIME_OUT"][::std::mem::size_of::<xTIME_OUT>() - 8usize];
    ["Alignment of xTIME_OUT"][::std::mem::align_of::<xTIME_OUT>() - 4usize];
    ["Offset of field: xTIME_OUT::xOverflowCount"]
        [::std::mem::offset_of!(xTIME_OUT, xOverflowCount) - 0usize];
    ["Offset of field: xTIME_OUT::xTimeOnEntering"]
        [::std::mem::offset_of!(xTIME_OUT, xTimeOnEntering) - 4usize];
};
#[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ::std::os::raw::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xMEMORY_REGION"][::std::mem::size_of::<xMEMORY_REGION>() - 16usize];
    ["Alignment of xMEMORY_REGION"][::std::mem::align_of::<xMEMORY_REGION>() - 8usize];
    ["Offset of field: xMEMORY_REGION::pvBaseAddress"]
        [::std::mem::offset_of!(xMEMORY_REGION, pvBaseAddress) - 0usize];
    ["Offset of field: xMEMORY_REGION::ulLengthInBytes"]
        [::std::mem::offset_of!(xMEMORY_REGION, ulLengthInBytes) - 8usize];
    ["Offset of field: xMEMORY_REGION::ulParameters"]
        [::std::mem::offset_of!(xMEMORY_REGION, ulParameters) - 12usize];
};
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ::std::os::raw::c_char,
    pub usStackDepth: u32,
    pub pvParameters: *mut ::std::os::raw::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTASK_PARAMETERS"][::std::mem::size_of::<xTASK_PARAMETERS>() - 64usize];
    ["Alignment of xTASK_PARAMETERS"][::std::mem::align_of::<xTASK_PARAMETERS>() - 8usize];
    ["Offset of field: xTASK_PARAMETERS::pvTaskCode"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, pvTaskCode) - 0usize];
    ["Offset of field: xTASK_PARAMETERS::pcName"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, pcName) - 8usize];
    ["Offset of field: xTASK_PARAMETERS::usStackDepth"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, usStackDepth) - 16usize];
    ["Offset of field: xTASK_PARAMETERS::pvParameters"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, pvParameters) - 24usize];
    ["Offset of field: xTASK_PARAMETERS::uxPriority"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, uxPriority) - 32usize];
    ["Offset of field: xTASK_PARAMETERS::puxStackBuffer"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, puxStackBuffer) - 40usize];
    ["Offset of field: xTASK_PARAMETERS::xRegions"]
        [::std::mem::offset_of!(xTASK_PARAMETERS, xRegions) - 48usize];
};
pub type TaskParameters_t = xTASK_PARAMETERS;
#[doc = " Used with the uxTaskGetSystemState() function to return the state of each task\n in the system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    #[doc = "< The handle of the task to which the rest of the information in the structure relates."]
    pub xHandle: TaskHandle_t,
    #[doc = "< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated!"]
    pub pcTaskName: *const ::std::os::raw::c_char,
    #[doc = "< A number unique to the task."]
    pub xTaskNumber: UBaseType_t,
    #[doc = "< The state in which the task existed when the structure was populated."]
    pub eCurrentState: eTaskState,
    #[doc = "< The priority at which the task was running (may be inherited) when the structure was populated."]
    pub uxCurrentPriority: UBaseType_t,
    #[doc = "< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h."]
    pub uxBasePriority: UBaseType_t,
    #[doc = "< The total run time allocated to the task so far, as defined by the run time stats clock.  See https://www.FreeRTOS.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h."]
    pub ulRunTimeCounter: u32,
    #[doc = "< Points to the lowest address of the task's stack area."]
    pub pxStackBase: *mut StackType_t,
    #[doc = "< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack."]
    pub usStackHighWaterMark: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xTASK_STATUS"][::std::mem::size_of::<xTASK_STATUS>() - 56usize];
    ["Alignment of xTASK_STATUS"][::std::mem::align_of::<xTASK_STATUS>() - 8usize];
    ["Offset of field: xTASK_STATUS::xHandle"]
        [::std::mem::offset_of!(xTASK_STATUS, xHandle) - 0usize];
    ["Offset of field: xTASK_STATUS::pcTaskName"]
        [::std::mem::offset_of!(xTASK_STATUS, pcTaskName) - 8usize];
    ["Offset of field: xTASK_STATUS::xTaskNumber"]
        [::std::mem::offset_of!(xTASK_STATUS, xTaskNumber) - 16usize];
    ["Offset of field: xTASK_STATUS::eCurrentState"]
        [::std::mem::offset_of!(xTASK_STATUS, eCurrentState) - 20usize];
    ["Offset of field: xTASK_STATUS::uxCurrentPriority"]
        [::std::mem::offset_of!(xTASK_STATUS, uxCurrentPriority) - 24usize];
    ["Offset of field: xTASK_STATUS::uxBasePriority"]
        [::std::mem::offset_of!(xTASK_STATUS, uxBasePriority) - 28usize];
    ["Offset of field: xTASK_STATUS::ulRunTimeCounter"]
        [::std::mem::offset_of!(xTASK_STATUS, ulRunTimeCounter) - 32usize];
    ["Offset of field: xTASK_STATUS::pxStackBase"]
        [::std::mem::offset_of!(xTASK_STATUS, pxStackBase) - 40usize];
    ["Offset of field: xTASK_STATUS::usStackHighWaterMark"]
        [::std::mem::offset_of!(xTASK_STATUS, usStackHighWaterMark) - 48usize];
};
#[doc = " Used with the uxTaskGetSystemState() function to return the state of each task\n in the system."]
pub type TaskStatus_t = xTASK_STATUS;
#[doc = "< A task has been made ready or a context switch pended since portSUPPRESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode."]
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
#[doc = "< Enter a sleep mode that will not last any longer than the expected idle time."]
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
#[doc = "< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt."]
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
#[doc = " Possible return values for eTaskConfirmSleepModeStatus()."]
pub type eSleepModeStatus = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Memory regions are assigned to a restricted task when the task is created by\n a call to xTaskCreateRestricted().  These regions can be redefined using\n vTaskAllocateMPURegions().\n\n @param xTask The handle of the task being updated.\n\n @param pxRegions A pointer to a MemoryRegion_t structure that contains the\n new memory region definitions.\n\n Example usage:\n @code{c}\n // Define an array of MemoryRegion_t structures that configures an MPU region\n // allowing read/write access for 1024 bytes starting at the beginning of the\n // ucOneKByte array.  The other two of the maximum 3 definable regions are\n // unused so set to zero.\n static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =\n {\n  // Base address     Length      Parameters\n  { ucOneKByte,       1024,       portMPU_REGION_READ_WRITE },\n  { 0,                0,          0 },\n  { 0,                0,          0 }\n };\n\n void vATask( void *pvParameters )\n {\n  // This task was created such that it has access to certain regions of\n  // memory as defined by the MPU configuration.  At some point it is\n  // desired that these MPU regions are replaced with that defined in the\n  // xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()\n  // for this purpose.  NULL is used as the task handle to indicate that this\n  // function should modify the MPU regions of the calling task.\n  vTaskAllocateMPURegions( NULL, xAltRegions );\n\n  // Now the task can continue its function, but from this point on can only\n  // access its stack and the ucOneKByte array (unless any other statically\n  // defined or shared regions have been declared elsewhere).\n }\n @endcode\n \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
unsafe extern "C" {
    #[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Remove a task from the RTOS real time kernel's management.  The task being\n deleted will be removed from all ready, blocked, suspended and event lists.\n\n NOTE:  The idle task is responsible for freeing the kernel allocated\n memory from tasks that have been deleted.  It is therefore important that\n the idle task is not starved of microcontroller processing time if your\n application makes any calls to vTaskDelete ().  Memory allocated by the\n task code is not automatically freed, and should be freed before the task\n is deleted.\n\n See the demo application file death.c for sample code that utilises\n vTaskDelete ().\n\n @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will\n cause the calling task to be deleted.\n\n Example usage:\n @code{c}\n void vOtherFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create the task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // Use the handle to delete the task.\n   vTaskDelete( xHandle );\n }\n @endcode\n \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
unsafe extern "C" {
    #[doc = " Delay a task for a given number of ticks.  The actual time that the\n task remains blocked depends on the tick rate.  The constant\n portTICK_PERIOD_MS can be used to calculate real time from the tick\n rate - with the resolution of one tick period.\n\n INCLUDE_vTaskDelay must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n\n vTaskDelay() specifies a time at which the task wishes to unblock relative to\n the time at which vTaskDelay() is called.  For example, specifying a block\n period of 100 ticks will cause the task to unblock 100 ticks after\n vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method\n of controlling the frequency of a periodic task as the path taken through the\n code, as well as other task and interrupt activity, will affect the frequency\n at which vTaskDelay() gets called and therefore the time at which the task\n next executes.  See xTaskDelayUntil() for an alternative API function designed\n to facilitate fixed frequency execution.  It does this by specifying an\n absolute time (rather than a relative time) at which the calling task should\n unblock.\n\n @param xTicksToDelay The amount of time, in tick periods, that\n the calling task should block.\n\n Example usage:\n @code{c}\n void vTaskFunction( void * pvParameters )\n {\n // Block for 500ms.\n const TickType_t xDelay = 500 / portTICK_PERIOD_MS;\n\n   for( ;; )\n   {\n       // Simply toggle the LED every 500ms, blocking between each toggle.\n       vToggleLED();\n       vTaskDelay( xDelay );\n   }\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
unsafe extern "C" {
    #[doc = " INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Delay a task until a specified time.  This function can be used by periodic\n tasks to ensure a constant execution frequency.\n\n This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will\n cause a task to block for the specified number of ticks from the time vTaskDelay () is\n called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed\n execution frequency as the time between a task starting to execute and that task\n calling vTaskDelay () may not be fixed [the task may take a different path though the\n code between calls, or may get interrupted or preempted a different number of times\n each time it executes].\n\n Whereas vTaskDelay () specifies a wake time relative to the time at which the function\n is called, xTaskDelayUntil () specifies the absolute (exact) time at which it wishes to\n unblock.\n\n The macro pdMS_TO_TICKS() can be used to calculate the number of ticks from a\n time specified in milliseconds with a resolution of one tick period.\n\n @param pxPreviousWakeTime Pointer to a variable that holds the time at which the\n task was last unblocked.  The variable must be initialised with the current time\n prior to its first use (see the example below).  Following this the variable is\n automatically updated within xTaskDelayUntil ().\n\n @param xTimeIncrement The cycle time period.  The task will be unblocked at\n time *pxPreviousWakeTime + xTimeIncrement.  Calling xTaskDelayUntil with the\n same xTimeIncrement parameter value will cause the task to execute with\n a fixed interface period.\n\n @return Value which can be used to check whether the task was actually delayed.\n Will be pdTRUE if the task way delayed and pdFALSE otherwise.  A task will not\n be delayed if the next expected wake time is in the past.\n\n Example usage:\n @code{c}\n // Perform an action every 10 ticks.\n void vTaskFunction( void * pvParameters )\n {\n TickType_t xLastWakeTime;\n const TickType_t xFrequency = 10;\n BaseType_t xWasDelayed;\n\n     // Initialise the xLastWakeTime variable with the current time.\n     xLastWakeTime = xTaskGetTickCount ();\n     for( ;; )\n     {\n         // Wait for the next cycle.\n         xWasDelayed = xTaskDelayUntil( &xLastWakeTime, xFrequency );\n\n         // Perform action here. xWasDelayed value can be used to determine\n         // whether a deadline was missed if the code here took too long.\n     }\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this\n function to be available.\n\n A task will enter the Blocked state when it is waiting for an event.  The\n event it is waiting for can be a temporal event (waiting for a time), such\n as when vTaskDelay() is called, or an event on an object, such as when\n xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task\n that is in the Blocked state is used in a call to xTaskAbortDelay() then the\n task will leave the Blocked state, and return from whichever function call\n placed the task into the Blocked state.\n\n There is no 'FromISR' version of this function as an interrupt would need to\n know which object a task was blocked on in order to know which actions to\n take.  For example, if the task was blocked on a queue the interrupt handler\n would then need to know if the queue was locked.\n\n @param xTask The handle of the task to remove from the Blocked state.\n\n @return If the task referenced by xTask was not in the Blocked state then\n pdFAIL is returned.  Otherwise pdPASS is returned.\n\n \\ingroup TaskCtrl"]
    pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Obtain the priority of any task.\n\n @param xTask Handle of the task to be queried.  Passing a NULL\n handle results in the priority of the calling task being returned.\n\n @return The priority of xTask.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to obtain the priority of the created task.\n   // It was created with tskIDLE_PRIORITY, but may have changed\n   // it itself.\n   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )\n   {\n       // The task has changed it's priority.\n   }\n\n   // ...\n\n   // Is our priority higher than the created task?\n   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )\n   {\n       // Our priority (obtained using NULL handle) is higher.\n   }\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Obtain the state of any task.  States are encoded by the eTaskState\n enumerated type.\n\n @param xTask Handle of the task to be queried.\n\n @return The state of xTask at the time the function was called.  Note the\n state of the task might change between the function being called, and the\n functions return value being tested by the calling task."]
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
unsafe extern "C" {
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 for this function to be\n available.  See the configuration section for more information.\n\n Populates a TaskStatus_t structure with information about a task.\n\n @param xTask Handle of the task being queried.  If xTask is NULL then\n information will be returned about the calling task.\n\n @param pxTaskStatus A pointer to the TaskStatus_t structure that will be\n filled with information about the task referenced by the handle passed using\n the xTask parameter.\n\n @param xGetFreeStackSpace The TaskStatus_t structure contains a member to report\n the stack high water mark of the task being queried.  Calculating the stack\n high water mark takes a relatively long time, and can make the system\n temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to\n allow the high water mark checking to be skipped.  The high watermark value\n will only be written to the TaskStatus_t structure if xGetFreeStackSpace is\n not set to pdFALSE;\n\n @param eState The TaskStatus_t structure contains a member to report the\n state of the task being queried.  Obtaining the task state is not as fast as\n a simple assignment - so the eState parameter is provided to allow the state\n information to be omitted from the TaskStatus_t structure.  To obtain state\n information then set eState to eInvalid - otherwise the value passed in\n eState will be reported as the task state in the TaskStatus_t structure.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n TaskStatus_t xTaskDetails;\n\n  // Obtain the handle of a task from its name.\n  xHandle = xTaskGetHandle( \"Task_Name\" );\n\n  // Check the handle is not NULL.\n  configASSERT( xHandle );\n\n  // Use the handle to obtain further information about the task.\n  vTaskGetInfo( xHandle,\n                &xTaskDetails,\n                pdTRUE, // Include the high water mark in xTaskDetails.\n                eInvalid ); // Include the task state in xTaskDetails.\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
unsafe extern "C" {
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Set the priority of any task.\n\n A context switch will occur before the function returns if the priority\n being set is higher than the currently executing task.\n\n @param xTask Handle to the task for which the priority is being set.\n Passing a NULL handle results in the priority of the calling task being set.\n\n @param uxNewPriority The priority to which the task will be set.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to raise the priority of the created task.\n   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );\n\n   // ...\n\n   // Use a NULL handle to raise our priority to the same value.\n   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
unsafe extern "C" {
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Suspend any task.  When suspended a task will never get any microcontroller\n processing time, no matter what its priority.\n\n Calls to vTaskSuspend are not accumulative -\n i.e. calling vTaskSuspend () twice on the same task still only requires one\n call to vTaskResume () to ready the suspended task.\n\n @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL\n handle will cause the calling task to be suspended.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to suspend the created task.\n   vTaskSuspend( xHandle );\n\n   // ...\n\n   // The created task will not run during this period, unless\n   // another task calls vTaskResume( xHandle ).\n\n   //...\n\n\n   // Suspend ourselves.\n   vTaskSuspend( NULL );\n\n   // We cannot get here unless another task calls vTaskResume\n   // with our handle as the parameter.\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
unsafe extern "C" {
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.\n See the configuration section for more information.\n\n Resumes a suspended task.\n\n A task that has been suspended by one or more calls to vTaskSuspend ()\n will be made available for running again by a single call to\n vTaskResume ().\n\n @param xTaskToResume Handle to the task being readied.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n TaskHandle_t xHandle;\n\n   // Create a task, storing the handle.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );\n\n   // ...\n\n   // Use the handle to suspend the created task.\n   vTaskSuspend( xHandle );\n\n   // ...\n\n   // The created task will not run during this period, unless\n   // another task calls vTaskResume( xHandle ).\n\n   //...\n\n\n   // Resume the suspended task ourselves.\n   vTaskResume( xHandle );\n\n   // The created task will once again get microcontroller processing\n   // time in accordance with its priority within the system.\n }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
unsafe extern "C" {
    #[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be\n available.  See the configuration section for more information.\n\n An implementation of vTaskResume() that can be called from within an ISR.\n\n A task that has been suspended by one or more calls to vTaskSuspend ()\n will be made available for running again by a single call to\n xTaskResumeFromISR ().\n\n xTaskResumeFromISR() should not be used to synchronise a task with an\n interrupt if there is a chance that the interrupt could arrive prior to the\n task being suspended - as this can lead to interrupts being missed. Use of a\n semaphore as a synchronisation mechanism would avoid this eventuality.\n\n @param xTaskToResume Handle to the task being readied.\n\n @return pdTRUE if resuming the task should result in a context switch,\n otherwise pdFALSE. This is used by the ISR to determine if a context switch\n may be required following the ISR.\n\n \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Starts the real time kernel tick processing.  After calling the kernel\n has control over which tasks are executed and when.\n\n See the demo application file main.c for an example of creating\n tasks and starting the kernel.\n\n Example usage:\n @code{c}\n void vAFunction( void )\n {\n   // Create at least one task before starting the kernel.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n   // Start the real time kernel with preemption.\n   vTaskStartScheduler ();\n\n   // Will not get here unless a task calls vTaskEndScheduler ()\n }\n @endcode\n\n \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
unsafe extern "C" {
    #[doc = " NOTE:  At the time of writing only the x86 real mode port, which runs on a PC\n in place of DOS, implements this function.\n\n Stops the real time kernel tick.  All created tasks will be automatically\n deleted and multitasking (either preemptive or cooperative) will\n stop.  Execution then resumes from the point where vTaskStartScheduler ()\n was called, as if vTaskStartScheduler () had just returned.\n\n See the demo application file main. c in the demo/PC directory for an\n example that uses vTaskEndScheduler ().\n\n vTaskEndScheduler () requires an exit function to be defined within the\n portable layer (see vPortEndScheduler () in port. c for the PC port).  This\n performs hardware specific operations such as stopping the kernel tick.\n\n vTaskEndScheduler () will cause all of the resources allocated by the\n kernel to be freed - but will not free resources allocated by application\n tasks.\n\n Example usage:\n @code{c}\n void vTaskCode( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // At some point we want to end the real time kernel processing\n       // so call ...\n       vTaskEndScheduler ();\n   }\n }\n\n void vAFunction( void )\n {\n   // Create at least one task before starting the kernel.\n   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );\n\n   // Start the real time kernel with preemption.\n   vTaskStartScheduler ();\n\n   // Will only get here when the vTaskCode () task has called\n   // vTaskEndScheduler ().  When we get here we are back to single task\n   // execution.\n }\n @endcode\n\n \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
unsafe extern "C" {
    #[doc = " Suspends the scheduler without disabling interrupts.  Context switches will\n not occur while the scheduler is suspended.\n\n After calling vTaskSuspendAll () the calling task will continue to execute\n without risk of being swapped out until a call to xTaskResumeAll () has been\n made.\n\n API functions that have the potential to cause a context switch (for example,\n xTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler\n is suspended.\n\n Example usage:\n @code{c}\n void vTask1( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // ...\n\n       // At some point the task wants to perform a long operation during\n       // which it does not want to get swapped out.  It cannot use\n       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n       // operation may cause interrupts to be missed - including the\n       // ticks.\n\n       // Prevent the real time kernel swapping out the task.\n       vTaskSuspendAll ();\n\n       // Perform the operation here.  There is no need to use critical\n       // sections as we have all the microcontroller processing time.\n       // During this time interrupts will still operate and the kernel\n       // tick count will be maintained.\n\n       // ...\n\n       // The operation is complete.  Restart the kernel.\n       xTaskResumeAll ();\n   }\n }\n @endcode\n \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
unsafe extern "C" {
    #[doc = " Resumes scheduler activity after it was suspended by a call to\n vTaskSuspendAll().\n\n xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks\n that were previously suspended by a call to vTaskSuspend().\n\n @return If resuming the scheduler caused a context switch then pdTRUE is\n         returned, otherwise pdFALSE is returned.\n\n Example usage:\n @code{c}\n void vTask1( void * pvParameters )\n {\n   for( ;; )\n   {\n       // Task code goes here.\n\n       // ...\n\n       // At some point the task wants to perform a long operation during\n       // which it does not want to get swapped out.  It cannot use\n       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the\n       // operation may cause interrupts to be missed - including the\n       // ticks.\n\n       // Prevent the real time kernel swapping out the task.\n       vTaskSuspendAll ();\n\n       // Perform the operation here.  There is no need to use critical\n       // sections as we have all the microcontroller processing time.\n       // During this time interrupts will still operate and the real\n       // time kernel tick count will be maintained.\n\n       // ...\n\n       // The operation is complete.  Restart the kernel.  We want to force\n       // a context switch - but there is no point if resuming the scheduler\n       // caused a context switch already.\n       if( !xTaskResumeAll () )\n       {\n            taskYIELD ();\n       }\n   }\n }\n @endcode\n \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @return The count of ticks since vTaskStartScheduler was called.\n\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
unsafe extern "C" {
    #[doc = " @return The count of ticks since vTaskStartScheduler was called.\n\n This is a version of xTaskGetTickCount() that is safe to be called from an\n ISR - provided that TickType_t is the natural word size of the\n microcontroller being used or interrupt nesting is either not supported or\n not being used.\n\n \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
unsafe extern "C" {
    #[doc = " @return The number of tasks that the real time kernel is currently managing.\n This includes all ready, blocked and suspended tasks.  A task that\n has been deleted but not yet freed by the idle task will also be\n included in the count.\n\n \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " @return The text (human readable) name of the task referenced by the handle\n xTaskToQuery.  A task can query its own name by either passing in its own\n handle, or by setting xTaskToQuery to NULL.\n\n \\ingroup TaskUtils"]
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " NOTE:  This function takes a relatively long time to complete and should be\n used sparingly.\n\n @return The handle of the task that has the human readable name pcNameToQuery.\n NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle\n must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.\n\n \\ingroup TaskUtils"]
    pub fn xTaskGetHandle(pcNameToQuery: *const ::std::os::raw::c_char) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xTaskGetStaticBuffers(
        xTask: TaskHandle_t,
        ppuxStackBuffer: *mut *mut StackType_t,
        ppxTaskBuffer: *mut *mut StaticTask_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for\n this function to be available.\n\n Returns the high water mark of the stack associated with xTask.  That is,\n the minimum free stack space there has been (in words, so on a 32 bit machine\n a value of 1 means 4 bytes) since the task started.  The smaller the returned\n number the closer the task has come to overflowing its stack.\n\n uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the\n same except for their return type.  Using configSTACK_DEPTH_TYPE allows the\n user to determine the return type.  It gets around the problem of the value\n overflowing on 8-bit types without breaking backward compatibility for\n applications that expect an 8-bit return type.\n\n @param xTask Handle of the task associated with the stack to be checked.\n Set xTask to NULL to check the stack of the calling task.\n\n @return The smallest amount of free stack space there has been (in words, so\n actual spaces on the stack rather than bytes) since the task referenced by\n xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark2 must be set to 1 in FreeRTOSConfig.h for\n this function to be available.\n\n Returns the high water mark of the stack associated with xTask.  That is,\n the minimum free stack space there has been (in words, so on a 32 bit machine\n a value of 1 means 4 bytes) since the task started.  The smaller the returned\n number the closer the task has come to overflowing its stack.\n\n uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the\n same except for their return type.  Using configSTACK_DEPTH_TYPE allows the\n user to determine the return type.  It gets around the problem of the value\n overflowing on 8-bit types without breaking backward compatibility for\n applications that expect an 8-bit return type.\n\n @param xTask Handle of the task associated with the stack to be checked.\n Set xTask to NULL to check the stack of the calling task.\n\n @return The smallest amount of free stack space there has been (in words, so\n actual spaces on the stack rather than bytes) since the task referenced by\n xTask was created."]
    pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Each task contains an array of pointers that is dimensioned by the\n configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The\n kernel does not use the pointers itself, so the application writer can use\n the pointers for any purpose they wish.  The following two functions are\n used to set and query a pointer respectively."]
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " The application stack overflow hook is called when a stack overflow is detected for a task.\n\n Details on stack overflow detection can be found here: https://www.FreeRTOS.org/Stacks-and-stack-overflow-checking.html\n\n @param xTask the task that just exceeded its stack boundaries.\n @param pcTaskName A character string containing the name of the offending task."]
    pub fn vApplicationStackOverflowHook(
        xTask: TaskHandle_t,
        pcTaskName: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Idle Task TCB.  This function is required when\n configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION\n\n @param ppxIdleTaskTCBBuffer A handle to a statically allocated TCB buffer\n @param ppxIdleTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task\n @param pulIdleTaskStackSize A pointer to the number of elements that will fit in the allocated stack buffer"]
    pub fn vApplicationGetIdleTaskMemory(
        ppxIdleTaskTCBBuffer: *mut *mut StaticTask_t,
        ppxIdleTaskStackBuffer: *mut *mut StackType_t,
        pulIdleTaskStackSize: *mut u32,
    );
}
unsafe extern "C" {
    #[doc = " Calls the hook function associated with xTask.  Passing xTask as NULL has\n the effect of calling the Running tasks (the calling task) hook function.\n\n pvParameter is passed to the hook function for the task to interpret as it\n wants.  The return value is the value returned by the task hook function\n registered by the user."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ::std::os::raw::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " xTaskGetIdleTaskHandle() is only available if\n INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.\n\n Simply returns the handle of the idle task of the current core.  It is not\n valid to call xTaskGetIdleTaskHandle() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for\n uxTaskGetSystemState() to be available.\n\n uxTaskGetSystemState() populates an TaskStatus_t structure for each task in\n the system.  TaskStatus_t structures contain, among other things, members\n for the task handle, task name, task priority, task state, and total amount\n of run time consumed by the task.  See the TaskStatus_t structure\n definition in this file for the full member list.\n\n NOTE:  This function is intended for debugging use only as its use results in\n the scheduler remaining suspended for an extended period.\n\n @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.\n The array must contain at least one TaskStatus_t structure for each task\n that is under the control of the RTOS.  The number of tasks under the control\n of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.\n\n @param uxArraySize The size of the array pointed to by the pxTaskStatusArray\n parameter.  The size is specified as the number of indexes in the array, or\n the number of TaskStatus_t structures contained in the array, not by the\n number of bytes in the array.\n\n @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in\n FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the\n total run time (as defined by the run time stats clock, see\n https://www.FreeRTOS.org/rtos-run-time-stats.html) since the target booted.\n pulTotalRunTime can be set to NULL to omit the total run time information.\n\n @return The number of TaskStatus_t structures that were populated by\n uxTaskGetSystemState().  This should equal the number returned by the\n uxTaskGetNumberOfTasks() API function, but will be zero if the value passed\n in the uxArraySize parameter was too small.\n\n Example usage:\n @code{c}\n  // This example demonstrates how a human readable table of run time stats\n  // information is generated from raw data provided by uxTaskGetSystemState().\n  // The human readable table is written to pcWriteBuffer\n  void vTaskGetRunTimeStats( char *pcWriteBuffer )\n  {\n  TaskStatus_t *pxTaskStatusArray;\n  volatile UBaseType_t uxArraySize, x;\n  configRUN_TIME_COUNTER_TYPE ulTotalRunTime, ulStatsAsPercentage;\n\n      // Make sure the write buffer does not contain a string.\n pcWriteBuffer = 0x00;\n\n      // Take a snapshot of the number of tasks in case it changes while this\n      // function is executing.\n      uxArraySize = uxTaskGetNumberOfTasks();\n\n      // Allocate a TaskStatus_t structure for each task.  An array could be\n      // allocated statically at compile time.\n      pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );\n\n      if( pxTaskStatusArray != NULL )\n      {\n          // Generate raw status information about each task.\n          uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );\n\n          // For percentage calculations.\n          ulTotalRunTime /= 100UL;\n\n          // Avoid divide by zero errors.\n          if( ulTotalRunTime > 0 )\n          {\n              // For each populated position in the pxTaskStatusArray array,\n              // format the raw data as human readable ASCII data\n              for( x = 0; x < uxArraySize; x++ )\n              {\n                  // What percentage of the total run time has the task used?\n                  // This will always be rounded down to the nearest integer.\n                  // ulTotalRunTimeDiv100 has already been divided by 100.\n                  ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;\n\n                  if( ulStatsAsPercentage > 0UL )\n                  {\n                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );\n                  }\n                  else\n                  {\n                      // If the percentage is zero here then the task has\n                      // consumed less than 1% of the total run time.\n                      sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );\n                  }\n\n                  pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );\n              }\n          }\n\n          // The array is no longer needed, free the memory it consumes.\n          vPortFree( pxTaskStatusArray );\n      }\n  }\n  @endcode"]
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must\n both be defined as 1 for this function to be available.  See the\n configuration section of the FreeRTOS.org website for more information.\n\n NOTE 1: This function will disable interrupts for its duration.  It is\n not intended for normal application runtime use but as a debug aid.\n\n Lists all the current tasks, along with their current state and stack\n usage high water mark.\n\n Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or\n suspended ('S').\n\n PLEASE NOTE:\n\n This function is provided for convenience only, and is used by many of the\n demo applications.  Do not consider it to be part of the scheduler.\n\n vTaskList() calls uxTaskGetSystemState(), then formats part of the\n uxTaskGetSystemState() output into a human readable table that displays task:\n names, states, priority, stack usage and task number.\n Stack usage specified as the number of unused StackType_t words stack can hold\n on top of stack - not the number of bytes.\n\n vTaskList() has a dependency on the sprintf() C library function that might\n bloat the code size, use a lot of stack, and provide different results on\n different platforms.  An alternative, tiny, third party, and limited\n functionality implementation of sprintf() is provided in many of the\n FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n printf-stdarg.c does not provide a full snprintf() implementation!).\n\n It is recommended that production systems call uxTaskGetSystemState()\n directly to get access to raw stats data, rather than indirectly through a\n call to vTaskList().\n\n @param pcWriteBuffer A buffer into which the above mentioned details\n will be written, in ASCII form.  This buffer is assumed to be large\n enough to contain the generated report.  Approximately 40 bytes per\n task should be sufficient.\n\n \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS\n must both be defined as 1 for this function to be available.  The application\n must also then provide definitions for\n portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n to configure a peripheral timer/counter and return the timers current count\n value respectively.  The counter should be at least 10 times the frequency of\n the tick count.\n\n NOTE 1: This function will disable interrupts for its duration.  It is\n not intended for normal application runtime use but as a debug aid.\n\n Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n accumulated execution time being stored for each task.  The resolution\n of the accumulated time value depends on the frequency of the timer\n configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n Calling vTaskGetRunTimeStats() writes the total execution time of each\n task into a buffer, both as an absolute count value and as a percentage\n of the total system execution time.\n\n NOTE 2:\n\n This function is provided for convenience only, and is used by many of the\n demo applications.  Do not consider it to be part of the scheduler.\n\n vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the\n uxTaskGetSystemState() output into a human readable table that displays the\n amount of time each task has spent in the Running state in both absolute and\n percentage terms.\n\n vTaskGetRunTimeStats() has a dependency on the sprintf() C library function\n that might bloat the code size, use a lot of stack, and provide different\n results on different platforms.  An alternative, tiny, third party, and\n limited functionality implementation of sprintf() is provided in many of the\n FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note\n printf-stdarg.c does not provide a full snprintf() implementation!).\n\n It is recommended that production systems call uxTaskGetSystemState() directly\n to get access to raw stats data, rather than indirectly through a call to\n vTaskGetRunTimeStats().\n\n @param pcWriteBuffer A buffer into which the execution times will be\n written, in ASCII form.  This buffer is assumed to be large enough to\n contain the generated report.  Approximately 40 bytes per task should\n be sufficient.\n\n \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " configGENERATE_RUN_TIME_STATS, configUSE_STATS_FORMATTING_FUNCTIONS and\n INCLUDE_xTaskGetIdleTaskHandle must all be defined as 1 for these functions\n to be available.  The application must also then provide definitions for\n portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()\n to configure a peripheral timer/counter and return the timers current count\n value respectively.  The counter should be at least 10 times the frequency of\n the tick count.\n\n Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total\n accumulated execution time being stored for each task.  The resolution\n of the accumulated time value depends on the frequency of the timer\n configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.\n While uxTaskGetSystemState() and vTaskGetRunTimeStats() writes the total\n execution time of each task into a buffer, ulTaskGetIdleRunTimeCounter()\n returns the total execution time of just the idle task and\n ulTaskGetIdleRunTimePercent() returns the percentage of the CPU time used by\n just the idle task.\n\n Note the amount of idle time is only a good measure of the slack time in a\n system if there are no other tasks executing at the idle priority, tickless\n idle is not used, and configIDLE_SHOULD_YIELD is set to 0.\n\n @note If configNUMBER_OF_CORES > 1, calling this function will query the idle\n task of the current core.\n\n @return The total run time of the idle task or the percentage of the total\n run time consumed by the idle task.  This is the amount of time the\n idle task has actually been executing.  The unit of time is dependent on the\n frequency configured using the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and\n portGET_RUN_TIME_COUNTER_VALUE() macros.\n\n \\ingroup TaskUtils"]
    pub fn ulTaskGetIdleRunTimeCounter() -> u32;
}
unsafe extern "C" {
    pub fn ulTaskGetIdleRunTimePercent() -> u32;
}
unsafe extern "C" {
    #[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Sends a direct to task notification to a task, with an optional value and\n action.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A task can use xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() to\n [optionally] block to wait for a notification to be pending.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotify() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling xTaskNotify() is equivalent to calling xTaskNotifyIndexed()\n with the uxIndexToNotify parameter set to 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotify() does\n not have this parameter and always sends notifications to index 0.\n\n @param ulValue Data that can be sent with the notification.  How the data is\n used depends on the value of the eAction parameter.\n\n @param eAction Specifies how the notification updates the task's notification\n value, if at all.  Valid values for eAction are as follows:\n\n eSetBits -\n The target notification value is bitwise ORed with ulValue.\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eIncrement -\n The target notification value is incremented.  ulValue is not used and\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eSetValueWithOverwrite -\n The target notification value is set to the value of ulValue, even if the\n task being notified had not yet processed the previous notification at the\n same array index (the task already had a notification pending at that index).\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n eSetValueWithoutOverwrite -\n If the task being notified did not already have a notification pending at the\n same array index then the target notification value is set to ulValue and\n xTaskNotifyIndexed() will return pdPASS.  If the task being notified already\n had a notification pending at the same array index then no action is\n performed and pdFAIL is returned.\n\n eNoAction -\n The task receives a notification at the specified array index without the\n notification value at that index being updated.  ulValue is not used and\n xTaskNotifyIndexed() always returns pdPASS in this case.\n\n pulPreviousNotificationValue -\n Can be used to pass out the subject task's notification value before any\n bits are modified by the notify function.\n\n @return Dependent on the value of eAction.  See the description of the\n eAction parameter.\n\n \\ingroup TaskNotifications\n/\n/** @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n A version of xTaskNotifyIndexed() that can be used from an interrupt service\n routine (ISR).\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyFromISR() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyFromISR() is equivalent to calling\n xTaskNotifyIndexedFromISR() with the uxIndexToNotify parameter set to 0.\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyFromISR()\n does not have this parameter and always sends notifications to index 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param ulValue Data that can be sent with the notification.  How the data is\n used depends on the value of the eAction parameter.\n\n @param eAction Specifies how the notification updates the task's notification\n value, if at all.  Valid values for eAction are as follows:\n\n eSetBits -\n The task's notification value is bitwise ORed with ulValue.  xTaskNotify()\n always returns pdPASS in this case.\n\n eIncrement -\n The task's notification value is incremented.  ulValue is not used and\n xTaskNotify() always returns pdPASS in this case.\n\n eSetValueWithOverwrite -\n The task's notification value is set to the value of ulValue, even if the\n task being notified had not yet processed the previous notification (the\n task already had a notification pending).  xTaskNotify() always returns\n pdPASS in this case.\n\n eSetValueWithoutOverwrite -\n If the task being notified did not already have a notification pending then\n the task's notification value is set to ulValue and xTaskNotify() will\n return pdPASS.  If the task being notified already had a notification\n pending then no action is performed and pdFAIL is returned.\n\n eNoAction -\n The task receives a notification without its notification value being\n updated.  ulValue is not used and xTaskNotify() always returns pdPASS in\n this case.\n\n @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n task to which the notification was sent to leave the Blocked state, and the\n unblocked task has a priority higher than the currently running task.  If\n xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should\n be requested before the interrupt is exited.  How a context switch is\n requested from an ISR is dependent on the port - see the documentation page\n for the port in use.\n\n @return Dependent on the value of eAction.  See the description of the\n eAction parameter.\n\n \\ingroup TaskNotifications\n/\n/** @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Waits for a direct to task notification to be pending at a given index within\n an array of direct to task notifications.\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n function to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n A notification sent to a task will remain pending until it is cleared by the\n task calling xTaskNotifyWaitIndexed() or ulTaskNotifyTakeIndexed() (or their\n un-indexed equivalents).  If the task was already in the Blocked state to\n wait for a notification when the notification arrives then the task will\n automatically be removed from the Blocked state (unblocked) and the\n notification cleared.\n\n A task can use xTaskNotifyWaitIndexed() to [optionally] block to wait for a\n notification to be pending, or ulTaskNotifyTakeIndexed() to [optionally] block\n to wait for a notification value to have a non-zero value.  The task does\n not consume any CPU time while it is in the Blocked state.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyWait() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling xTaskNotifyWait() is equivalent to calling\n xTaskNotifyWaitIndexed() with the uxIndexToWaitOn parameter set to 0.\n\n @param uxIndexToWaitOn The index within the calling task's array of\n notification values on which the calling task will wait for a notification to\n be received.  uxIndexToWaitOn must be less than\n configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyWait() does\n not have this parameter and always waits for notifications on index 0.\n\n @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value\n will be cleared in the calling task's notification value before the task\n checks to see if any notifications are pending, and optionally blocks if no\n notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if\n limits.h is included) or 0xffffffffUL (if limits.h is not included) will have\n the effect of resetting the task's notification value to 0.  Setting\n ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.\n\n @param ulBitsToClearOnExit If a notification is pending or received before\n the calling task exits the xTaskNotifyWait() function then the task's\n notification value (see the xTaskNotify() API function) is passed out using\n the pulNotificationValue parameter.  Then any bits that are set in\n ulBitsToClearOnExit will be cleared in the task's notification value (note\n *pulNotificationValue is set before any bits are cleared).  Setting\n ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL\n (if limits.h is not included) will have the effect of resetting the task's\n notification value to 0 before the function exits.  Setting\n ulBitsToClearOnExit to 0 will leave the task's notification value unchanged\n when the function exits (in which case the value passed out in\n pulNotificationValue will match the task's notification value).\n\n @param pulNotificationValue Used to pass the task's notification value out\n of the function.  Note the value passed out will not be effected by the\n clearing of any bits caused by ulBitsToClearOnExit being non-zero.\n\n @param xTicksToWait The maximum amount of time that the task should wait in\n the Blocked state for a notification to be received, should a notification\n not already be pending when xTaskNotifyWait() was called.  The task\n will not consume any processing time while it is in the Blocked state.  This\n is specified in kernel ticks, the macro pdMS_TO_TICKS( value_in_ms ) can be\n used to convert a time specified in milliseconds to a time specified in\n ticks.\n\n @return If a notification was received (including notifications that were\n already pending when xTaskNotifyWait was called) then pdPASS is\n returned.  Otherwise pdFAIL is returned.\n\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " A version of xTaskNotifyGiveIndexed() that can be called from an interrupt\n service routine (ISR).\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for more details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro\n to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n vTaskNotifyGiveIndexedFromISR() is intended for use when task notifications\n are used as light weight and faster binary or counting semaphore equivalents.\n Actual FreeRTOS semaphores are given from an ISR using the\n xSemaphoreGiveFromISR() API function, the equivalent action that instead uses\n a task notification is vTaskNotifyGiveIndexedFromISR().\n\n When task notifications are being used as a binary or counting semaphore\n equivalent then the task being notified should wait for the notification\n using the ulTaskNotifyTakeIndexed() API function rather than the\n xTaskNotifyWaitIndexed() API function.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyFromISR() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyGiveFromISR() is equivalent to calling\n xTaskNotifyGiveIndexedFromISR() with the uxIndexToNotify parameter set to 0.\n\n @param xTaskToNotify The handle of the task being notified.  The handle to a\n task can be returned from the xTaskCreate() API function used to create the\n task, and the handle of the currently running task can be obtained by calling\n xTaskGetCurrentTaskHandle().\n\n @param uxIndexToNotify The index within the target task's array of\n notification values to which the notification is to be sent.  uxIndexToNotify\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n xTaskNotifyGiveFromISR() does not have this parameter and always sends\n notifications to index 0.\n\n @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the\n task to which the notification was sent to leave the Blocked state, and the\n unblocked task has a priority higher than the currently running task.  If\n vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch\n should be requested before the interrupt is exited.  How a context switch is\n requested from an ISR is dependent on the port - see the documentation page\n for the port in use.\n\n \\ingroup TaskNotifications"]
    pub fn vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
unsafe extern "C" {
    #[doc = " Waits for a direct to task notification on a particular index in the calling\n task's notification array in a manner similar to taking a counting semaphore.\n\n See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this\n function to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n Events can be sent to a task using an intermediary object.  Examples of such\n objects are queues, semaphores, mutexes and event groups.  Task notifications\n are a method of sending an event directly to a task without the need for such\n an intermediary object.\n\n A notification sent to a task can optionally perform an action, such as\n update, overwrite or increment one of the task's notification values.  In\n that way task notifications can be used to send data to a task, or be used as\n light weight and fast binary or counting semaphores.\n\n ulTaskNotifyTakeIndexed() is intended for use when a task notification is\n used as a faster and lighter weight binary or counting semaphore alternative.\n Actual FreeRTOS semaphores are taken using the xSemaphoreTake() API function,\n the equivalent action that instead uses a task notification is\n ulTaskNotifyTakeIndexed().\n\n When a task is using its notification value as a binary or counting semaphore\n other tasks should send notifications to it using the xTaskNotifyGiveIndexed()\n macro, or xTaskNotifyIndex() function with the eAction parameter set to\n eIncrement.\n\n ulTaskNotifyTakeIndexed() can either clear the task's notification value at\n the array index specified by the uxIndexToWaitOn parameter to zero on exit,\n in which case the notification value acts like a binary semaphore, or\n decrement the notification value on exit, in which case the notification\n value acts like a counting semaphore.\n\n A task can use ulTaskNotifyTakeIndexed() to [optionally] block to wait for\n a notification.  The task does not consume any CPU time while it is in the\n Blocked state.\n\n Where as xTaskNotifyWaitIndexed() will return when a notification is pending,\n ulTaskNotifyTakeIndexed() will return when the task's notification value is\n not zero.\n\n **NOTE** Each notification within the array operates independently - a task\n can only block on one notification within the array at a time and will not be\n unblocked by a notification sent to any other array index.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  ulTaskNotifyTake() is the original API function, and remains backward\n compatible by always operating on the notification value at index 0 in the\n array. Calling ulTaskNotifyTake() is equivalent to calling\n ulTaskNotifyTakeIndexed() with the uxIndexToWaitOn parameter set to 0.\n\n @param uxIndexToWaitOn The index within the calling task's array of\n notification values on which the calling task will wait for a notification to\n be non-zero.  uxIndexToWaitOn must be less than\n configTASK_NOTIFICATION_ARRAY_ENTRIES.  xTaskNotifyTake() does\n not have this parameter and always waits for notifications on index 0.\n\n @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's\n notification value is decremented when the function exits.  In this way the\n notification value acts like a counting semaphore.  If xClearCountOnExit is\n not pdFALSE then the task's notification value is cleared to zero when the\n function exits.  In this way the notification value acts like a binary\n semaphore.\n\n @param xTicksToWait The maximum amount of time that the task should wait in\n the Blocked state for the task's notification value to be greater than zero,\n should the count not already be greater than zero when\n ulTaskNotifyTake() was called.  The task will not consume any processing\n time while it is in the Blocked state.  This is specified in kernel ticks,\n the macro pdMS_TO_TICKS( value_in_ms ) can be used to convert a time\n specified in milliseconds to a time specified in ticks.\n\n @return The task's notification count before it is either cleared to zero or\n decremented (see the xClearCountOnExit parameter).\n\n \\ingroup TaskNotifications\n/\n/** @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n If a notification is sent to an index within the array of notifications then\n the notification at that index is said to be 'pending' until it is read or\n explicitly cleared by the receiving task.  xTaskNotifyStateClearIndexed()\n is the function that clears a pending notification without reading the\n notification value.  The notification value at the same array index is not\n altered.  Set xTask to NULL to clear the notification state of the calling\n task.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  xTaskNotifyStateClear() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling xTaskNotifyStateClear() is equivalent to calling\n xTaskNotifyStateClearIndexed() with the uxIndexToNotify parameter set to 0.\n\n @param xTask The handle of the RTOS task that will have a notification state\n cleared.  Set xTask to NULL to clear a notification state in the calling\n task.  To obtain a task's handle create the task using xTaskCreate() and\n make use of the pxCreatedTask parameter, or create the task using\n xTaskCreateStatic() and store the returned value, or use the task's name in\n a call to xTaskGetHandle().\n\n @param uxIndexToClear The index within the target task's array of\n notification values to act upon.  For example, setting uxIndexToClear to 1\n will clear the state of the notification at index 1 within the array.\n uxIndexToClear must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n ulTaskNotifyStateClear() does not have this parameter and always acts on the\n notification at index 0.\n\n @return pdTRUE if the task's notification state was set to\n eNotWaitingNotification, otherwise pdFALSE.\n\n \\ingroup TaskNotifications"]
    pub fn xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " See https://www.FreeRTOS.org/RTOS-task-notifications.html for details.\n\n configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these\n functions to be available.\n\n Each task has a private array of \"notification values\" (or 'notifications'),\n each of which is a 32-bit unsigned integer (uint32_t).  The constant\n configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the\n array, and (for backward compatibility) defaults to 1 if left undefined.\n Prior to FreeRTOS V10.4.0 there was only one notification value per task.\n\n ulTaskNotifyValueClearIndexed() clears the bits specified by the\n ulBitsToClear bit mask in the notification value at array index uxIndexToClear\n of the task referenced by xTask.\n\n Backward compatibility information:\n Prior to FreeRTOS V10.4.0 each task had a single \"notification value\", and\n all task notification API functions operated on that value. Replacing the\n single notification value with an array of notification values necessitated a\n new set of API functions that could address specific notifications within the\n array.  ulTaskNotifyValueClear() is the original API function, and remains\n backward compatible by always operating on the notification value at index 0\n within the array. Calling ulTaskNotifyValueClear() is equivalent to calling\n ulTaskNotifyValueClearIndexed() with the uxIndexToClear parameter set to 0.\n\n @param xTask The handle of the RTOS task that will have bits in one of its\n notification values cleared. Set xTask to NULL to clear bits in a\n notification value of the calling task.  To obtain a task's handle create the\n task using xTaskCreate() and make use of the pxCreatedTask parameter, or\n create the task using xTaskCreateStatic() and store the returned value, or\n use the task's name in a call to xTaskGetHandle().\n\n @param uxIndexToClear The index within the target task's array of\n notification values in which to clear the bits.  uxIndexToClear\n must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.\n ulTaskNotifyValueClear() does not have this parameter and always clears bits\n in the notification value at index 0.\n\n @param ulBitsToClear Bit mask of the bits to clear in the notification value of\n xTask. Set a bit to 1 to clear the corresponding bits in the task's notification\n value. Set ulBitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear\n the notification value to 0.  Set ulBitsToClear to 0 to query the task's\n notification value without clearing any bits.\n\n\n @return The value of the target task's notification value before the bits\n specified by ulBitsToClear were cleared.\n \\ingroup TaskNotifications"]
    pub fn ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: u32,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " Capture the current time for future use with xTaskCheckForTimeOut().\n\n @param pxTimeOut Pointer to a timeout object into which the current time\n is to be captured.  The captured time includes the tick count and the number\n of times the tick count has overflowed since the system first booted.\n \\ingroup TaskCtrl"]
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
unsafe extern "C" {
    #[doc = " Determines if pxTicksToWait ticks has passed since a time was captured\n using a call to vTaskSetTimeOutState().  The captured time includes the tick\n count and the number of times the tick count has overflowed.\n\n @param pxTimeOut The time status as captured previously using\n vTaskSetTimeOutState. If the timeout has not yet occurred, it is updated\n to reflect the current time status.\n @param pxTicksToWait The number of ticks to check for timeout i.e. if\n pxTicksToWait ticks have passed since pxTimeOut was last updated (either by\n vTaskSetTimeOutState() or xTaskCheckForTimeOut()), the timeout has occurred.\n If the timeout has not occurred, pxTicksToWait is updated to reflect the\n number of remaining ticks.\n\n @return If timeout has occurred, pdTRUE is returned. Otherwise pdFALSE is\n returned and pxTicksToWait is updated to reflect the number of remaining\n ticks.\n\n @see https://www.FreeRTOS.org/xTaskCheckForTimeOut.html\n\n Example Usage:\n @code{c}\n  // Driver library function used to receive uxWantedBytes from an Rx buffer\n  // that is filled by a UART interrupt. If there are not enough bytes in the\n  // Rx buffer then the task enters the Blocked state until it is notified that\n  // more data has been placed into the buffer. If there is still not enough\n  // data then the task re-enters the Blocked state, and xTaskCheckForTimeOut()\n  // is used to re-calculate the Block time to ensure the total amount of time\n  // spent in the Blocked state does not exceed MAX_TIME_TO_WAIT. This\n  // continues until either the buffer contains at least uxWantedBytes bytes,\n  // or the total amount of time spent in the Blocked state reaches\n  // MAX_TIME_TO_WAIT - at which point the task reads however many bytes are\n  // available up to a maximum of uxWantedBytes.\n\n  size_t xUART_Receive( uint8_t *pucBuffer, size_t uxWantedBytes )\n  {\n  size_t uxReceived = 0;\n  TickType_t xTicksToWait = MAX_TIME_TO_WAIT;\n  TimeOut_t xTimeOut;\n\n      // Initialize xTimeOut.  This records the time at which this function\n      // was entered.\n      vTaskSetTimeOutState( &xTimeOut );\n\n      // Loop until the buffer contains the wanted number of bytes, or a\n      // timeout occurs.\n      while( UART_bytes_in_rx_buffer( pxUARTInstance ) < uxWantedBytes )\n      {\n          // The buffer didn't contain enough data so this task is going to\n          // enter the Blocked state. Adjusting xTicksToWait to account for\n          // any time that has been spent in the Blocked state within this\n          // function so far to ensure the total amount of time spent in the\n          // Blocked state does not exceed MAX_TIME_TO_WAIT.\n          if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) != pdFALSE )\n          {\n              //Timed out before the wanted number of bytes were available,\n              // exit the loop.\n              break;\n          }\n\n          // Wait for a maximum of xTicksToWait ticks to be notified that the\n          // receive interrupt has placed more data into the buffer.\n          ulTaskNotifyTake( pdTRUE, xTicksToWait );\n      }\n\n      // Attempt to read uxWantedBytes from the receive buffer into pucBuffer.\n      // The actual number of bytes read (which might be less than\n      // uxWantedBytes) is returned.\n      uxReceived = UART_read_from_receive_buffer( pxUARTInstance,\n                                                  pucBuffer,\n                                                  uxWantedBytes );\n\n      return uxReceived;\n  }\n @endcode\n \\ingroup TaskCtrl"]
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " This function corrects the tick count value after the application code has held\n interrupts disabled for an extended period resulting in tick interrupts having\n been missed.\n\n This function is similar to vTaskStepTick(), however, unlike\n vTaskStepTick(), xTaskCatchUpTicks() may move the tick count forward past a\n time at which a task should be removed from the blocked state.  That means\n tasks may have to be removed from the blocked state as the tick count is\n moved.\n\n @param xTicksToCatchUp The number of tick interrupts that have been missed due to\n interrupts being disabled.  Its value is not computed automatically, so must be\n computed by the application writer.\n\n @return pdTRUE if moving the tick count forward resulted in a task leaving the\n blocked state and a context switch being performed.  Otherwise pdFALSE.\n\n \\ingroup TaskCtrl"]
    pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xTaskIncrementTick() -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
unsafe extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
unsafe extern "C" {
    pub fn vTaskSwitchContext();
}
unsafe extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
unsafe extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskMissedYield();
}
unsafe extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
unsafe extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
unsafe extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
unsafe extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
unsafe extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()\n returns an QueueHandle_t variable that can then be used as a parameter to\n xQueueSend(), xQueueReceive(), etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
#[doc = " Type by which queue sets are referenced.  For example, a call to\n xQueueCreateSet() returns an xQueueSet variable that can then be used as a\n parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut QueueDefinition;
#[doc = " Queue sets can contain both queues and semaphores, so the\n QueueSetMemberHandle_t is defined as a type to be used where a parameter or\n return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
unsafe extern "C" {
    #[doc = " It is preferred that the macros xQueueSend(), xQueueSendToFront() and\n xQueueSendToBack() are used in place of calling this function directly.\n\n Post an item on a queue.  The item is queued by copy, not by reference.\n This function must not be called from an interrupt service routine.\n See xQueueSendFromISR () for an alternative which may be used in an ISR.\n\n @param xQueue The handle to the queue on which the item is to be posted.\n\n @param pvItemToQueue A pointer to the item that is to be placed on the\n queue.  The size of the items the queue will hold was defined when the\n queue was created, so this many bytes will be copied from pvItemToQueue\n into the queue storage area.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for space to become available on the queue, should it already\n be full.  The call will return immediately if this is set to 0 and the\n queue is full.  The time is defined in tick periods so the constant\n portTICK_PERIOD_MS should be used to convert to real time if this is required.\n\n @param xCopyPosition Can take the value queueSEND_TO_BACK to place the\n item at the back of the queue, or queueSEND_TO_FRONT to place the item\n at the front of the queue (for high priority messages).\n\n @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n uint32_t ulVar = 10UL;\n\n void vATask( void *pvParameters )\n {\n QueueHandle_t xQueue1, xQueue2;\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 uint32_t values.\n  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );\n\n  // ...\n\n  if( xQueue1 != 0 )\n  {\n      // Send an uint32_t.  Wait for 10 ticks for space to become\n      // available if necessary.\n      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )\n      {\n          // Failed to post the message, even after 10 ticks.\n      }\n  }\n\n  if( xQueue2 != 0 )\n  {\n      // Send a pointer to a struct AMessage object.  Don't block if the\n      // queue is already full.\n      pxMessage = & xMessage;\n      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Receive an item from a queue without removing the item from the queue.\n The item is received by copy so a buffer of adequate size must be\n provided.  The number of bytes copied into the buffer was defined when\n the queue was created.\n\n Successfully received items remain on the queue so will be returned again\n by the next call, or a call to xQueueReceive().\n\n This macro must not be used in an interrupt service routine.  See\n xQueuePeekFromISR() for an alternative that can be called from an interrupt\n service routine.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for an item to receive should the queue be empty at the time\n of the call. The time is defined in tick periods so the constant\n portTICK_PERIOD_MS should be used to convert to real time if this is required.\n xQueuePeek() will return immediately if xTicksToWait is 0 and the queue\n is empty.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n QueueHandle_t xQueue;\n\n // Task to create a queue and post a value.\n void vATask( void *pvParameters )\n {\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Send a pointer to a struct AMessage object.  Don't block if the\n  // queue is already full.\n  pxMessage = & xMessage;\n  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );\n\n  // ... Rest of task code.\n }\n\n // Task to peek the data from the queue.\n void vADifferentTask( void *pvParameters )\n {\n struct AMessage *pxRxedMessage;\n\n  if( xQueue != 0 )\n  {\n      // Peek a message on the created queue.  Block for 10 ticks if a\n      // message is not immediately available.\n      if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )\n      {\n          // pcRxedMessage now points to the struct AMessage variable posted\n          // by vATask, but the item still remains on the queue.\n      }\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n \\ingroup QueueManagement"]
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " A version of xQueuePeek() that can be called from an interrupt service\n routine (ISR).\n\n Receive an item from a queue without removing the item from the queue.\n The item is received by copy so a buffer of adequate size must be\n provided.  The number of bytes copied into the buffer was defined when\n the queue was created.\n\n Successfully received items remain on the queue so will be returned again\n by the next call, or a call to xQueueReceive().\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Receive an item from a queue.  The item is received by copy so a buffer of\n adequate size must be provided.  The number of bytes copied into the buffer\n was defined when the queue was created.\n\n Successfully received items are removed from the queue.\n\n This function must not be used in an interrupt service routine.  See\n xQueueReceiveFromISR for an alternative that can.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param xTicksToWait The maximum amount of time the task should block\n waiting for an item to receive should the queue be empty at the time\n of the call. xQueueReceive() will return immediately if xTicksToWait\n is zero and the queue is empty.  The time is defined in tick periods so the\n constant portTICK_PERIOD_MS should be used to convert to real time if this is\n required.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n Example usage:\n @code{c}\n struct AMessage\n {\n  char ucMessageID;\n  char ucData[ 20 ];\n } xMessage;\n\n QueueHandle_t xQueue;\n\n // Task to create a queue and post a value.\n void vATask( void *pvParameters )\n {\n struct AMessage *pxMessage;\n\n  // Create a queue capable of containing 10 pointers to AMessage structures.\n  // These should be passed by pointer as they contain a lot of data.\n  xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Send a pointer to a struct AMessage object.  Don't block if the\n  // queue is already full.\n  pxMessage = & xMessage;\n  xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );\n\n  // ... Rest of task code.\n }\n\n // Task to receive from the queue.\n void vADifferentTask( void *pvParameters )\n {\n struct AMessage *pxRxedMessage;\n\n  if( xQueue != 0 )\n  {\n      // Receive a message on the created queue.  Block for 10 ticks if a\n      // message is not immediately available.\n      if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )\n      {\n          // pcRxedMessage now points to the struct AMessage variable posted\n          // by vATask.\n      }\n  }\n\n  // ... Rest of task code.\n }\n @endcode\n \\ingroup QueueManagement"]
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Return the number of messages stored in a queue.\n\n @param xQueue A handle to the queue being queried.\n\n @return The number of messages available in the queue.\n\n \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " Return the number of free spaces available in a queue.  This is equal to the\n number of items that can be sent to the queue before the queue becomes full\n if no items are removed.\n\n @param xQueue A handle to the queue being queried.\n\n @return The number of spaces available in the queue.\n\n \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " Delete a queue - freeing all the memory allocated for storing of items\n placed on the queue.\n\n @param xQueue A handle to the queue to be deleted.\n\n \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
unsafe extern "C" {
    #[doc = " It is preferred that the macros xQueueSendFromISR(),\n xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place\n of calling this function directly.  xQueueGiveFromISR() is an\n equivalent for use by semaphores that don't actually copy any data.\n\n Post an item on a queue.  It is safe to use this function from within an\n interrupt service routine.\n\n Items are queued by copy not reference so it is preferable to only\n queue small items, especially when called from an ISR.  In most cases\n it would be preferable to store a pointer to the item being queued.\n\n @param xQueue The handle to the queue on which the item is to be posted.\n\n @param pvItemToQueue A pointer to the item that is to be placed on the\n queue.  The size of the items the queue will hold was defined when the\n queue was created, so this many bytes will be copied from pvItemToQueue\n into the queue storage area.\n\n @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set\n *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task\n to unblock, and the unblocked task has a priority higher than the currently\n running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then\n a context switch should be requested before the interrupt is exited.\n\n @param xCopyPosition Can take the value queueSEND_TO_BACK to place the\n item at the back of the queue, or queueSEND_TO_FRONT to place the item\n at the front of the queue (for high priority messages).\n\n @return pdTRUE if the data was successfully sent to the queue, otherwise\n errQUEUE_FULL.\n\n Example usage for buffered IO (where the ISR can obtain more than one value\n per call):\n @code{c}\n void vBufferISR( void )\n {\n char cIn;\n BaseType_t xHigherPriorityTaskWokenByPost;\n\n  // We have not woken a task at the start of the ISR.\n  xHigherPriorityTaskWokenByPost = pdFALSE;\n\n  // Loop until the buffer is empty.\n  do\n  {\n      // Obtain a byte from the buffer.\n      cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );\n\n      // Post each byte.\n      xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );\n\n  } while( portINPUT_BYTE( BUFFER_COUNT ) );\n\n  // Now the buffer is empty we can switch context if necessary.  Note that the\n  // name of the yield function required is port specific.\n  if( xHigherPriorityTaskWokenByPost )\n  {\n      portYIELD_FROM_ISR();\n  }\n }\n @endcode\n\n \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Receive an item from a queue.  It is safe to use this function from within an\n interrupt service routine.\n\n @param xQueue The handle to the queue from which the item is to be\n received.\n\n @param pvBuffer Pointer to the buffer into which the received item will\n be copied.\n\n @param pxHigherPriorityTaskWoken A task may be blocked waiting for space to\n become available on the queue.  If xQueueReceiveFromISR causes such a task to\n unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will\n remain unchanged.\n\n @return pdTRUE if an item was successfully received from the queue,\n otherwise pdFALSE.\n\n Example usage:\n @code{c}\n\n QueueHandle_t xQueue;\n\n // Function to create a queue and post some values.\n void vAFunction( void *pvParameters )\n {\n char cValueToPost;\n const TickType_t xTicksToWait = ( TickType_t )0xff;\n\n  // Create a queue capable of containing 10 characters.\n  xQueue = xQueueCreate( 10, sizeof( char ) );\n  if( xQueue == 0 )\n  {\n      // Failed to create the queue.\n  }\n\n  // ...\n\n  // Post some characters that will be used within an ISR.  If the queue\n  // is full then this task will block for xTicksToWait ticks.\n  cValueToPost = 'a';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n  cValueToPost = 'b';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n\n  // ... keep posting characters ... this task may block when the queue\n  // becomes full.\n\n  cValueToPost = 'c';\n  xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );\n }\n\n // ISR that outputs all the characters received on the queue.\n void vISR_Routine( void )\n {\n BaseType_t xTaskWokenByReceive = pdFALSE;\n char cRxedChar;\n\n  while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )\n  {\n      // A character was received.  Output the character now.\n      vOutputCharacter( cRxedChar );\n\n      // If removing the character from the queue woke the task that was\n      // posting onto the queue xTaskWokenByReceive will have been set to\n      // pdTRUE.  No matter how many times this loop iterates only one\n      // task will be woken.\n  }\n\n  if( xTaskWokenByReceive != ( char ) pdFALSE;\n  {\n      taskYIELD ();\n  }\n }\n @endcode\n \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Queries a queue to determine if the queue is empty. This function should only be used in an ISR.\n\n @param xQueue The handle of the queue being queried\n @return pdFALSE if the queue is not empty, or pdTRUE if the queue is empty."]
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Queries a queue to determine if the queue is full. This function should only be used in an ISR.\n\n @param xQueue The handle of the queue being queried\n @return pdFALSE if the queue is not full, or pdTRUE if the queue is full."]
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " A version of uxQueueMessagesWaiting() that can be called from an ISR. Return the number of messages stored in a queue.\n\n @param xQueue A handle to the queue being queried.\n @return The number of messages available in the queue."]
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::std::os::raw::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::std::os::raw::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
unsafe extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueGenericCreateStatic(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        pucQueueStorage: *mut u8,
        pxStaticQueue: *mut StaticQueue_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
unsafe extern "C" {
    pub fn xQueueGenericGetStaticBuffers(
        xQueue: QueueHandle_t,
        ppucQueueStorage: *mut *mut u8,
        ppxStaticQueue: *mut *mut StaticQueue_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Queue sets provide a mechanism to allow a task to block (pend) on a read\n operation from multiple queues or semaphores simultaneously.\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n A queue set must be explicitly created using a call to xQueueCreateSet()\n before it can be used.  Once created, standard FreeRTOS queues and semaphores\n can be added to the set using calls to xQueueAddToSet().\n xQueueSelectFromSet() is then used to determine which, if any, of the queues\n or semaphores contained in the set is in a state where a queue read or\n semaphore take operation would be successful.\n\n Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-queue-sets.html\n for reasons why queue sets are very rarely needed in practice as there are\n simpler methods of blocking on multiple objects.\n\n Note 2:  Blocking on a queue set that contains a mutex will not cause the\n mutex holder to inherit the priority of the blocked task.\n\n Note 3:  An additional 4 bytes of RAM is required for each space in a every\n queue added to a queue set.  Therefore counting semaphores that have a high\n maximum count value should not be added to a queue set.\n\n Note 4:  A receive (in the case of a queue) or take (in the case of a\n semaphore) operation must not be performed on a member of a queue set unless\n a call to xQueueSelectFromSet() has first returned a handle to that set member.\n\n @param uxEventQueueLength Queue sets store events that occur on\n the queues and semaphores contained in the set.  uxEventQueueLength specifies\n the maximum number of events that can be queued at once.  To be absolutely\n certain that events are not lost uxEventQueueLength should be set to the\n total sum of the length of the queues added to the set, where binary\n semaphores and mutexes have a length of 1, and counting semaphores have a\n length set by their maximum count value.  Examples:\n  + If a queue set is to hold a queue of length 5, another queue of length 12,\n    and a binary semaphore, then uxEventQueueLength should be set to\n    (5 + 12 + 1), or 18.\n  + If a queue set is to hold three binary semaphores then uxEventQueueLength\n    should be set to (1 + 1 + 1 ), or 3.\n  + If a queue set is to hold a counting semaphore that has a maximum count of\n    5, and a counting semaphore that has a maximum count of 3, then\n    uxEventQueueLength should be set to (5 + 3), or 8.\n\n @return If the queue set is created successfully then a handle to the created\n queue set is returned.  Otherwise NULL is returned."]
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
unsafe extern "C" {
    #[doc = " Adds a queue or semaphore to a queue set that was previously created by a\n call to xQueueCreateSet().\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n Note 1:  A receive (in the case of a queue) or take (in the case of a\n semaphore) operation must not be performed on a member of a queue set unless\n a call to xQueueSelectFromSet() has first returned a handle to that set member.\n\n @param xQueueOrSemaphore The handle of the queue or semaphore being added to\n the queue set (cast to an QueueSetMemberHandle_t type).\n\n @param xQueueSet The handle of the queue set to which the queue or semaphore\n is being added.\n\n @return If the queue or semaphore was successfully added to the queue set\n then pdPASS is returned.  If the queue could not be successfully added to the\n queue set because it is already a member of a different queue set then pdFAIL\n is returned."]
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Removes a queue or semaphore from a queue set.  A queue or semaphore can only\n be removed from a set if the queue or semaphore is empty.\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n @param xQueueOrSemaphore The handle of the queue or semaphore being removed\n from the queue set (cast to an QueueSetMemberHandle_t type).\n\n @param xQueueSet The handle of the queue set in which the queue or semaphore\n is included.\n\n @return If the queue or semaphore was successfully removed from the queue set\n then pdPASS is returned.  If the queue was not in the queue set, or the\n queue (or semaphore) was not empty, then pdFAIL is returned."]
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " xQueueSelectFromSet() selects from the members of a queue set a queue or\n semaphore that either contains data (in the case of a queue) or is available\n to take (in the case of a semaphore).  xQueueSelectFromSet() effectively\n allows a task to block (pend) on a read operation on all the queues and\n semaphores in a queue set simultaneously.\n\n See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this\n function.\n\n Note 1:  See the documentation on https://www.FreeRTOS.org/RTOS-queue-sets.html\n for reasons why queue sets are very rarely needed in practice as there are\n simpler methods of blocking on multiple objects.\n\n Note 2:  Blocking on a queue set that contains a mutex will not cause the\n mutex holder to inherit the priority of the blocked task.\n\n Note 3:  A receive (in the case of a queue) or take (in the case of a\n semaphore) operation must not be performed on a member of a queue set unless\n a call to xQueueSelectFromSet() has first returned a handle to that set member.\n\n @param xQueueSet The queue set on which the task will (potentially) block.\n\n @param xTicksToWait The maximum time, in ticks, that the calling task will\n remain in the Blocked state (with other tasks executing) to wait for a member\n of the queue set to be ready for a successful queue read or semaphore take\n operation.\n\n @return xQueueSelectFromSet() will return the handle of a queue (cast to\n a QueueSetMemberHandle_t type) contained in the queue set that contains data,\n or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained\n in the queue set that is available, or NULL if no such queue or semaphore\n exists before before the specified block time expires."]
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
unsafe extern "C" {
    #[doc = " A version of xQueueSelectFromSet() that can be used from an ISR."]
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
unsafe extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
unsafe extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
unsafe extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
unsafe extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
#[doc = "< Internal 8MHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC_FAST: soc_root_clk_t = 0;
#[doc = "< Internal 150kHz RC oscillator"]
pub const soc_root_clk_t_SOC_ROOT_CLK_INT_RC_SLOW: soc_root_clk_t = 1;
#[doc = "< External 2~40MHz crystal"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_XTAL: soc_root_clk_t = 2;
#[doc = "< External 32kHz crystal/clock signal"]
pub const soc_root_clk_t_SOC_ROOT_CLK_EXT_XTAL32K: soc_root_clk_t = 3;
#[doc = " @brief Root clock"]
pub type soc_root_clk_t = ::std::os::raw::c_uint;
#[doc = "< Select XTAL_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_XTAL: soc_cpu_clk_src_t = 0;
#[doc = "< Select PLL_CLK as CPU_CLK source (PLL_CLK is the output of 40MHz crystal oscillator frequency multiplier, can be 480MHz or 320MHz)"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_PLL: soc_cpu_clk_src_t = 1;
#[doc = "< Select RC_FAST_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_RC_FAST: soc_cpu_clk_src_t = 2;
#[doc = "< Select APLL_CLK as CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_APLL: soc_cpu_clk_src_t = 3;
#[doc = "< Invalid CPU_CLK source"]
pub const soc_cpu_clk_src_t_SOC_CPU_CLK_SRC_INVALID: soc_cpu_clk_src_t = 4;
#[doc = " @brief CPU_CLK mux inputs, which are the supported clock sources for the CPU_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_cpu_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select RC_SLOW_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_RC_SLOW: soc_rtc_slow_clk_src_t = 0;
#[doc = "< Select XTAL32K_CLK as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_XTAL32K: soc_rtc_slow_clk_src_t = 1;
#[doc = "< Select RC_FAST_D256_CLK (referred as FOSC_DIV or 8m_d256/8md256 in TRM and reg. description) as RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_RC_FAST_D256: soc_rtc_slow_clk_src_t = 2;
#[doc = "< Invalid RTC_SLOW_CLK source"]
pub const soc_rtc_slow_clk_src_t_SOC_RTC_SLOW_CLK_SRC_INVALID: soc_rtc_slow_clk_src_t = 3;
#[doc = " @brief RTC_SLOW_CLK mux inputs, which are the supported clock sources for the RTC_SLOW_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_rtc_slow_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select XTAL_D4_CLK (may referred as XTAL_CLK_DIV_4) as RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_XTAL_D4: soc_rtc_fast_clk_src_t = 0;
#[doc = "< Select RC_FAST_CLK as RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_RC_FAST: soc_rtc_fast_clk_src_t = 1;
#[doc = "< Invalid RTC_FAST_CLK source"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_INVALID: soc_rtc_fast_clk_src_t = 2;
#[doc = "< XTAL_D4_CLK is the default clock source for RTC_FAST_CLK"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_DEFAULT: soc_rtc_fast_clk_src_t = 0;
#[doc = "< Alias name for `SOC_RTC_FAST_CLK_SRC_XTAL_D4`"]
pub const soc_rtc_fast_clk_src_t_SOC_RTC_FAST_CLK_SRC_XTAL_DIV: soc_rtc_fast_clk_src_t = 0;
#[doc = " @brief RTC_FAST_CLK mux inputs, which are the supported clock sources for the RTC_FAST_CLK\n @note Enum values are matched with the register field values on purpose"]
pub type soc_rtc_fast_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Automatic XTAL frequency detention"]
pub const soc_xtal_freq_t_SOC_XTAL_FREQ_AUTO: soc_xtal_freq_t = 0;
#[doc = "< 24MHz XTAL"]
pub const soc_xtal_freq_t_SOC_XTAL_FREQ_24M: soc_xtal_freq_t = 24;
#[doc = "< 26MHz XTAL"]
pub const soc_xtal_freq_t_SOC_XTAL_FREQ_26M: soc_xtal_freq_t = 26;
#[doc = "< 40MHz XTAL"]
pub const soc_xtal_freq_t_SOC_XTAL_FREQ_40M: soc_xtal_freq_t = 40;
#[doc = " @brief Possible main XTAL frequency options on the target\n @note Enum values equal to the frequency value in MHz\n @note Not all frequency values listed here are supported in IDF. Please check SOC_XTAL_SUPPORT_XXX in soc_caps.h for\n       the supported ones."]
pub type soc_xtal_freq_t = ::std::os::raw::c_uint;
#[doc = "< CPU_CLK can be sourced from XTAL, PLL, RC_FAST, or APLL by configuring soc_cpu_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_CPU: soc_module_clk_t = 1;
#[doc = "< RTC_FAST_CLK can be sourced from XTAL_D4 or RC_FAST by configuring soc_rtc_fast_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_RTC_FAST: soc_module_clk_t = 2;
#[doc = "< RTC_SLOW_CLK can be sourced from RC_SLOW, XTAL32K, or RC_FAST_D256 by configuring soc_rtc_slow_clk_src_t"]
pub const soc_module_clk_t_SOC_MOD_CLK_RTC_SLOW: soc_module_clk_t = 3;
#[doc = "< APB_CLK is highly dependent on the CPU_CLK source"]
pub const soc_module_clk_t_SOC_MOD_CLK_APB: soc_module_clk_t = 4;
#[doc = "< PLL_D2_CLK is derived from PLL, it has a fixed divider of 2"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_D2: soc_module_clk_t = 5;
#[doc = "< PLL_F160M_CLK is derived from PLL, and has a fixed frequency of 160MHz"]
pub const soc_module_clk_t_SOC_MOD_CLK_PLL_F160M: soc_module_clk_t = 6;
#[doc = "< XTAL32K_CLK comes from the external 32kHz crystal, passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL32K: soc_module_clk_t = 7;
#[doc = "< RC_FAST_CLK comes from the internal 8MHz rc oscillator, passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_RC_FAST: soc_module_clk_t = 8;
#[doc = "< RC_FAST_D256_CLK comes from the internal 8MHz rc oscillator, divided by 256, and passing a clock gating to the peripherals"]
pub const soc_module_clk_t_SOC_MOD_CLK_RC_FAST_D256: soc_module_clk_t = 9;
#[doc = "< XTAL_CLK comes from the external crystal (2~40MHz)"]
pub const soc_module_clk_t_SOC_MOD_CLK_XTAL: soc_module_clk_t = 10;
#[doc = "< REF_TICK is derived from APB, it has a fixed frequency of 1MHz even when APB frequency changes"]
pub const soc_module_clk_t_SOC_MOD_CLK_REF_TICK: soc_module_clk_t = 11;
#[doc = "< APLL is sourced from PLL, and its frequency is configurable through APLL configuration registers"]
pub const soc_module_clk_t_SOC_MOD_CLK_APLL: soc_module_clk_t = 12;
#[doc = "< Indication of the end of the available module clock sources"]
pub const soc_module_clk_t_SOC_MOD_CLK_INVALID: soc_module_clk_t = 13;
#[doc = " @brief Supported clock sources for modules (CPU, peripherals, RTC, etc.)\n\n @note enum starts from 1, to save 0 for special purpose"]
pub type soc_module_clk_t = ::std::os::raw::c_uint;
#[doc = "< SYSTIMER source clock is XTAL"]
pub const soc_periph_systimer_clk_src_t_SYSTIMER_CLK_SRC_XTAL: soc_periph_systimer_clk_src_t = 10;
#[doc = "< SYSTIMER source clock default choice is XTAL"]
pub const soc_periph_systimer_clk_src_t_SYSTIMER_CLK_SRC_DEFAULT: soc_periph_systimer_clk_src_t =
    10;
#[doc = " @brief Type of SYSTIMER clock source"]
pub type soc_periph_systimer_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_APB: soc_periph_gptimer_clk_src_t = 4;
#[doc = "< Select APB as the default choice"]
pub const soc_periph_gptimer_clk_src_t_GPTIMER_CLK_SRC_DEFAULT: soc_periph_gptimer_clk_src_t = 4;
#[doc = " @brief Type of GPTimer clock source"]
pub type soc_periph_gptimer_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Timer group source clock is APB"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_APB: soc_periph_tg_clk_src_legacy_t = 4;
#[doc = "< Timer group source clock default choice is APB"]
pub const soc_periph_tg_clk_src_legacy_t_TIMER_SRC_CLK_DEFAULT: soc_periph_tg_clk_src_legacy_t = 4;
#[doc = " @brief Type of Timer Group clock source, reserved for the legacy timer group driver"]
pub type soc_periph_tg_clk_src_legacy_t = ::std::os::raw::c_uint;
#[doc = "< Select PLL_160M as the source clock"]
pub const soc_periph_lcd_clk_src_t_LCD_CLK_SRC_PLL160M: soc_periph_lcd_clk_src_t = 6;
#[doc = "< Select PLL_160M as the default choice"]
pub const soc_periph_lcd_clk_src_t_LCD_CLK_SRC_DEFAULT: soc_periph_lcd_clk_src_t = 6;
#[doc = " @brief Type of LCD clock source"]
pub type soc_periph_lcd_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_APB: soc_periph_rmt_clk_src_t = 4;
#[doc = "< Select REF_TICK as the source clock"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_REF_TICK: soc_periph_rmt_clk_src_t = 11;
#[doc = "< Select APB as the default choice"]
pub const soc_periph_rmt_clk_src_t_RMT_CLK_SRC_DEFAULT: soc_periph_rmt_clk_src_t = 4;
#[doc = " @brief Type of RMT clock source"]
pub type soc_periph_rmt_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< RMT source clock is APB CLK"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_APB: soc_periph_rmt_clk_src_legacy_t = 4;
#[doc = "< RMT source clock is REF_TICK"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_REF: soc_periph_rmt_clk_src_legacy_t = 11;
#[doc = "< RMT source clock default choice is APB"]
pub const soc_periph_rmt_clk_src_legacy_t_RMT_BASECLK_DEFAULT: soc_periph_rmt_clk_src_legacy_t = 4;
#[doc = " @brief Type of RMT clock source, reserved for the legacy RMT driver"]
pub type soc_periph_rmt_clk_src_legacy_t = ::std::os::raw::c_uint;
#[doc = "< UART source clock is APB CLK"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_APB: soc_periph_uart_clk_src_legacy_t = 4;
#[doc = "< UART source clock is REF_TICK"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_REF_TICK: soc_periph_uart_clk_src_legacy_t =
    11;
#[doc = "< UART source clock default choice is APB"]
pub const soc_periph_uart_clk_src_legacy_t_UART_SCLK_DEFAULT: soc_periph_uart_clk_src_legacy_t = 4;
#[doc = " @brief Type of UART clock source, reserved for the legacy UART driver"]
pub type soc_periph_uart_clk_src_legacy_t = ::std::os::raw::c_uint;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_mcpwm_timer_clk_src_t_MCPWM_TIMER_CLK_SRC_PLL160M:
    soc_periph_mcpwm_timer_clk_src_t = 6;
#[doc = "< Select PLL_F160M as the default clock choice"]
pub const soc_periph_mcpwm_timer_clk_src_t_MCPWM_TIMER_CLK_SRC_DEFAULT:
    soc_periph_mcpwm_timer_clk_src_t = 6;
#[doc = " @brief Type of MCPWM timer clock source"]
pub type soc_periph_mcpwm_timer_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_mcpwm_capture_clk_src_t_MCPWM_CAPTURE_CLK_SRC_APB:
    soc_periph_mcpwm_capture_clk_src_t = 4;
#[doc = "< Select APB as the default clock choice"]
pub const soc_periph_mcpwm_capture_clk_src_t_MCPWM_CAPTURE_CLK_SRC_DEFAULT:
    soc_periph_mcpwm_capture_clk_src_t = 4;
#[doc = " @brief Type of MCPWM capture clock source"]
pub type soc_periph_mcpwm_capture_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_mcpwm_carrier_clk_src_t_MCPWM_CARRIER_CLK_SRC_PLL160M:
    soc_periph_mcpwm_carrier_clk_src_t = 6;
#[doc = "< Select PLL_F160M as the default clock choice"]
pub const soc_periph_mcpwm_carrier_clk_src_t_MCPWM_CARRIER_CLK_SRC_DEFAULT:
    soc_periph_mcpwm_carrier_clk_src_t = 6;
#[doc = " @brief Type of MCPWM carrier clock source"]
pub type soc_periph_mcpwm_carrier_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select PLL_F160M as the default source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_DEFAULT: soc_periph_i2s_clk_src_t = 6;
#[doc = "< Select PLL_F160M as the source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_PLL_160M: soc_periph_i2s_clk_src_t = 6;
#[doc = "< Select APLL as the source clock"]
pub const soc_periph_i2s_clk_src_t_I2S_CLK_SRC_APLL: soc_periph_i2s_clk_src_t = 12;
#[doc = " @brief I2S clock source enum\n"]
pub type soc_periph_i2s_clk_src_t = ::std::os::raw::c_uint;
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_APB: soc_periph_i2c_clk_src_t = 4;
pub const soc_periph_i2c_clk_src_t_I2C_CLK_SRC_DEFAULT: soc_periph_i2c_clk_src_t = 4;
#[doc = " @brief Type of I2C clock source."]
pub type soc_periph_i2c_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as SPI source clock"]
pub const soc_periph_spi_clk_src_t_SPI_CLK_SRC_DEFAULT: soc_periph_spi_clk_src_t = 4;
#[doc = "< Select APB as SPI source clock"]
pub const soc_periph_spi_clk_src_t_SPI_CLK_SRC_APB: soc_periph_spi_clk_src_t = 4;
#[doc = " @brief Type of SPI clock source."]
pub type soc_periph_spi_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_APB: soc_periph_sdm_clk_src_t = 4;
#[doc = "< Select APB as the default clock choice"]
pub const soc_periph_sdm_clk_src_t_SDM_CLK_SRC_DEFAULT: soc_periph_sdm_clk_src_t = 4;
#[doc = " @brief Sigma Delta Modulator clock source"]
pub type soc_periph_sdm_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select PLL_D2 as the source clock"]
pub const soc_periph_dac_digi_clk_src_t_DAC_DIGI_CLK_SRC_PLLD2: soc_periph_dac_digi_clk_src_t = 5;
#[doc = "< Select APLL as the source clock"]
pub const soc_periph_dac_digi_clk_src_t_DAC_DIGI_CLK_SRC_APLL: soc_periph_dac_digi_clk_src_t = 12;
#[doc = "< Select PLL_D2 as the default source clock"]
pub const soc_periph_dac_digi_clk_src_t_DAC_DIGI_CLK_SRC_DEFAULT: soc_periph_dac_digi_clk_src_t = 5;
#[doc = " @brief DAC digital controller clock source\n"]
pub type soc_periph_dac_digi_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select RTC FAST as the source clock"]
pub const soc_periph_dac_cosine_clk_src_t_DAC_COSINE_CLK_SRC_RTC_FAST:
    soc_periph_dac_cosine_clk_src_t = 2;
#[doc = "< Select RTC FAST as the default source clock"]
pub const soc_periph_dac_cosine_clk_src_t_DAC_COSINE_CLK_SRC_DEFAULT:
    soc_periph_dac_cosine_clk_src_t = 2;
#[doc = " @brief DAC cosine wave generator clock source\n"]
pub type soc_periph_dac_cosine_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_twai_clk_src_t_TWAI_CLK_SRC_APB: soc_periph_twai_clk_src_t = 4;
#[doc = "< Select APB as the default clock choice"]
pub const soc_periph_twai_clk_src_t_TWAI_CLK_SRC_DEFAULT: soc_periph_twai_clk_src_t = 4;
#[doc = " @brief TWAI clock source"]
pub type soc_periph_twai_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select F160M as the source clock"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_PLL_F160M: soc_periph_adc_digi_clk_src_t =
    6;
#[doc = "< Select APLL as the source clock"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_APLL: soc_periph_adc_digi_clk_src_t = 12;
#[doc = "< Select F160M as the default clock choice"]
pub const soc_periph_adc_digi_clk_src_t_ADC_DIGI_CLK_SRC_DEFAULT: soc_periph_adc_digi_clk_src_t = 6;
#[doc = " @brief ADC digital controller clock source\n @note  ADC DMA mode is clocked from I2S on ESP32, using `ADC_DIGI_` here for compatibility\n        Its clock source is same as I2S"]
pub type soc_periph_adc_digi_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_adc_rtc_clk_src_t_ADC_RTC_CLK_SRC_RC_FAST: soc_periph_adc_rtc_clk_src_t = 8;
#[doc = "< Select RC_FAST as the default clock choice"]
pub const soc_periph_adc_rtc_clk_src_t_ADC_RTC_CLK_SRC_DEFAULT: soc_periph_adc_rtc_clk_src_t = 8;
#[doc = " @brief ADC RTC controller clock source"]
pub type soc_periph_adc_rtc_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_mwdt_clk_src_t_MWDT_CLK_SRC_APB: soc_periph_mwdt_clk_src_t = 4;
#[doc = "< Select APB as the default clock choice"]
pub const soc_periph_mwdt_clk_src_t_MWDT_CLK_SRC_DEFAULT: soc_periph_mwdt_clk_src_t = 4;
#[doc = " @brief MWDT clock source"]
pub type soc_periph_mwdt_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< LEDC source clock will be automatically selected based on the giving resolution and duty parameter when init the timer"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_AUTO_CLK: soc_periph_ledc_clk_src_legacy_t = 0;
#[doc = "< Select APB as the source clock"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_APB_CLK: soc_periph_ledc_clk_src_legacy_t = 4;
#[doc = "< Select RC_FAST as the source clock"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_RC_FAST_CLK: soc_periph_ledc_clk_src_legacy_t =
    8;
#[doc = "< Select REF_TICK as the source clock"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_REF_TICK: soc_periph_ledc_clk_src_legacy_t = 11;
#[doc = "< Alias of 'LEDC_USE_RC_FAST_CLK'"]
pub const soc_periph_ledc_clk_src_legacy_t_LEDC_USE_RTC8M_CLK: soc_periph_ledc_clk_src_legacy_t = 8;
#[doc = " @brief Type of LEDC clock source, reserved for the legacy LEDC driver"]
pub type soc_periph_ledc_clk_src_legacy_t = ::std::os::raw::c_uint;
#[doc = "< Select PLL_160M as the default choice"]
pub const soc_periph_sdmmc_clk_src_t_SDMMC_CLK_SRC_DEFAULT: soc_periph_sdmmc_clk_src_t = 6;
#[doc = "< Select PLL_160M as the source clock"]
pub const soc_periph_sdmmc_clk_src_t_SDMMC_CLK_SRC_PLL160M: soc_periph_sdmmc_clk_src_t = 6;
#[doc = " @brief Type of SDMMC clock source"]
pub type soc_periph_sdmmc_clk_src_t = ::std::os::raw::c_uint;
#[doc = "< I2S0 clock, depends on the i2s driver configuration"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_I2S0: soc_clkout_sig_id_t = 0;
#[doc = "< PLL_CLK is the output of crystal oscillator frequency multiplier"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_PLL: soc_clkout_sig_id_t = 1;
#[doc = "< RC slow clock, depends on the RTC_CLK_SRC configuration"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_RC_SLOW: soc_clkout_sig_id_t = 4;
#[doc = "< Main crystal oscillator clock"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_XTAL: soc_clkout_sig_id_t = 5;
#[doc = "< Divided by PLL, frequency is configurable"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_APLL: soc_clkout_sig_id_t = 6;
#[doc = "< Divided by APB clock, usually be 1MHz"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_REF_TICK: soc_clkout_sig_id_t = 12;
#[doc = "< From PLL, usually be 80MHz"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_PLL_F80M: soc_clkout_sig_id_t = 13;
#[doc = "< RC fast clock, about 8MHz"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_RC_FAST: soc_clkout_sig_id_t = 14;
#[doc = "< I2S1 clock, depends on the i2s driver configuration"]
pub const soc_clkout_sig_id_t_CLKOUT_SIG_I2S1: soc_clkout_sig_id_t = 15;
pub const soc_clkout_sig_id_t_CLKOUT_SIG_INVALID: soc_clkout_sig_id_t = 255;
#[doc = "CLOCK OUTPUT///////////////////////////////////////////////////////////"]
pub type soc_clkout_sig_id_t = ::std::os::raw::c_uint;
#[doc = "< UART port 0"]
pub const uart_port_t_UART_NUM_0: uart_port_t = 0;
#[doc = "< UART port 1"]
pub const uart_port_t_UART_NUM_1: uart_port_t = 1;
#[doc = "< UART port 2"]
pub const uart_port_t_UART_NUM_2: uart_port_t = 2;
#[doc = "< UART port max"]
pub const uart_port_t_UART_NUM_MAX: uart_port_t = 3;
#[doc = " @brief UART port number, can be UART_NUM_0 ~ (UART_NUM_MAX -1)."]
pub type uart_port_t = ::std::os::raw::c_uint;
#[doc = "< mode: regular UART mode"]
pub const uart_mode_t_UART_MODE_UART: uart_mode_t = 0;
#[doc = "< mode: half duplex RS485 UART mode control by RTS pin"]
pub const uart_mode_t_UART_MODE_RS485_HALF_DUPLEX: uart_mode_t = 1;
#[doc = "< mode: IRDA  UART mode"]
pub const uart_mode_t_UART_MODE_IRDA: uart_mode_t = 2;
#[doc = "< mode: RS485 collision detection UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_COLLISION_DETECT: uart_mode_t = 3;
#[doc = "< mode: application control RS485 UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_APP_CTRL: uart_mode_t = 4;
#[doc = " @brief UART mode selection"]
pub type uart_mode_t = ::std::os::raw::c_uint;
#[doc = "< word length: 5bits"]
pub const uart_word_length_t_UART_DATA_5_BITS: uart_word_length_t = 0;
#[doc = "< word length: 6bits"]
pub const uart_word_length_t_UART_DATA_6_BITS: uart_word_length_t = 1;
#[doc = "< word length: 7bits"]
pub const uart_word_length_t_UART_DATA_7_BITS: uart_word_length_t = 2;
#[doc = "< word length: 8bits"]
pub const uart_word_length_t_UART_DATA_8_BITS: uart_word_length_t = 3;
pub const uart_word_length_t_UART_DATA_BITS_MAX: uart_word_length_t = 4;
#[doc = " @brief UART word length constants"]
pub type uart_word_length_t = ::std::os::raw::c_uint;
#[doc = "< stop bit: 1bit"]
pub const uart_stop_bits_t_UART_STOP_BITS_1: uart_stop_bits_t = 1;
#[doc = "< stop bit: 1.5bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_1_5: uart_stop_bits_t = 2;
#[doc = "< stop bit: 2bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_2: uart_stop_bits_t = 3;
pub const uart_stop_bits_t_UART_STOP_BITS_MAX: uart_stop_bits_t = 4;
#[doc = " @brief UART stop bits number"]
pub type uart_stop_bits_t = ::std::os::raw::c_uint;
#[doc = "< Disable UART parity"]
pub const uart_parity_t_UART_PARITY_DISABLE: uart_parity_t = 0;
#[doc = "< Enable UART even parity"]
pub const uart_parity_t_UART_PARITY_EVEN: uart_parity_t = 2;
#[doc = "< Enable UART odd parity"]
pub const uart_parity_t_UART_PARITY_ODD: uart_parity_t = 3;
#[doc = " @brief UART parity constants"]
pub type uart_parity_t = ::std::os::raw::c_uint;
#[doc = "< disable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_DISABLE: uart_hw_flowcontrol_t = 0;
#[doc = "< enable RX hardware flow control (rts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_RTS: uart_hw_flowcontrol_t = 1;
#[doc = "< enable TX hardware flow control (cts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS: uart_hw_flowcontrol_t = 2;
#[doc = "< enable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS_RTS: uart_hw_flowcontrol_t = 3;
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_MAX: uart_hw_flowcontrol_t = 4;
#[doc = " @brief UART hardware flow control modes"]
pub type uart_hw_flowcontrol_t = ::std::os::raw::c_uint;
#[doc = "< Disable UART signal inverse"]
pub const uart_signal_inv_t_UART_SIGNAL_INV_DISABLE: uart_signal_inv_t = 0;
#[doc = "< inverse the UART irda_tx signal"]
pub const uart_signal_inv_t_UART_SIGNAL_IRDA_TX_INV: uart_signal_inv_t = 1;
#[doc = "< inverse the UART irda_rx signal"]
pub const uart_signal_inv_t_UART_SIGNAL_IRDA_RX_INV: uart_signal_inv_t = 2;
#[doc = "< inverse the UART rxd signal"]
pub const uart_signal_inv_t_UART_SIGNAL_RXD_INV: uart_signal_inv_t = 4;
#[doc = "< inverse the UART cts signal"]
pub const uart_signal_inv_t_UART_SIGNAL_CTS_INV: uart_signal_inv_t = 8;
#[doc = "< inverse the UART dsr signal"]
pub const uart_signal_inv_t_UART_SIGNAL_DSR_INV: uart_signal_inv_t = 16;
#[doc = "< inverse the UART txd signal"]
pub const uart_signal_inv_t_UART_SIGNAL_TXD_INV: uart_signal_inv_t = 32;
#[doc = "< inverse the UART rts signal"]
pub const uart_signal_inv_t_UART_SIGNAL_RTS_INV: uart_signal_inv_t = 64;
#[doc = "< inverse the UART dtr signal"]
pub const uart_signal_inv_t_UART_SIGNAL_DTR_INV: uart_signal_inv_t = 128;
#[doc = " @brief UART signal bit map"]
pub type uart_signal_inv_t = ::std::os::raw::c_uint;
#[doc = " @brief UART source clock"]
pub use self::soc_periph_uart_clk_src_legacy_t as uart_sclk_t;
#[doc = " @brief UART AT cmd char configuration parameters\n        Note that this function may different on different chip. Please refer to the TRM at confirguration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_at_cmd_t {
    #[doc = "< UART AT cmd char"]
    pub cmd_char: u8,
    #[doc = "< AT cmd char repeat number"]
    pub char_num: u8,
    #[doc = "< gap time(in baud-rate) between AT cmd char"]
    pub gap_tout: u32,
    #[doc = "< the idle time(in baud-rate) between the non AT char and first AT char"]
    pub pre_idle: u32,
    #[doc = "< the idle time(in baud-rate) between the last AT char and the none AT char"]
    pub post_idle: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_at_cmd_t"][::std::mem::size_of::<uart_at_cmd_t>() - 16usize];
    ["Alignment of uart_at_cmd_t"][::std::mem::align_of::<uart_at_cmd_t>() - 4usize];
    ["Offset of field: uart_at_cmd_t::cmd_char"]
        [::std::mem::offset_of!(uart_at_cmd_t, cmd_char) - 0usize];
    ["Offset of field: uart_at_cmd_t::char_num"]
        [::std::mem::offset_of!(uart_at_cmd_t, char_num) - 1usize];
    ["Offset of field: uart_at_cmd_t::gap_tout"]
        [::std::mem::offset_of!(uart_at_cmd_t, gap_tout) - 4usize];
    ["Offset of field: uart_at_cmd_t::pre_idle"]
        [::std::mem::offset_of!(uart_at_cmd_t, pre_idle) - 8usize];
    ["Offset of field: uart_at_cmd_t::post_idle"]
        [::std::mem::offset_of!(uart_at_cmd_t, post_idle) - 12usize];
};
#[doc = " @brief UART software flow control configuration parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_sw_flowctrl_t {
    #[doc = "< Xon flow control char"]
    pub xon_char: u8,
    #[doc = "< Xoff flow control char"]
    pub xoff_char: u8,
    #[doc = "< If the software flow control is enabled and the data amount in rxfifo is less than xon_thrd, an xon_char will be sent"]
    pub xon_thrd: u8,
    #[doc = "< If the software flow control is enabled and the data amount in rxfifo is more than xoff_thrd, an xoff_char will be sent"]
    pub xoff_thrd: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_sw_flowctrl_t"][::std::mem::size_of::<uart_sw_flowctrl_t>() - 4usize];
    ["Alignment of uart_sw_flowctrl_t"][::std::mem::align_of::<uart_sw_flowctrl_t>() - 1usize];
    ["Offset of field: uart_sw_flowctrl_t::xon_char"]
        [::std::mem::offset_of!(uart_sw_flowctrl_t, xon_char) - 0usize];
    ["Offset of field: uart_sw_flowctrl_t::xoff_char"]
        [::std::mem::offset_of!(uart_sw_flowctrl_t, xoff_char) - 1usize];
    ["Offset of field: uart_sw_flowctrl_t::xon_thrd"]
        [::std::mem::offset_of!(uart_sw_flowctrl_t, xon_thrd) - 2usize];
    ["Offset of field: uart_sw_flowctrl_t::xoff_thrd"]
        [::std::mem::offset_of!(uart_sw_flowctrl_t, xoff_thrd) - 3usize];
};
#[doc = "< Wake-up triggered by active edge threshold"]
pub const uart_wakeup_mode_t_UART_WK_MODE_ACTIVE_THRESH: uart_wakeup_mode_t = 0;
#[doc = " @brief Enumeration of UART wake-up modes."]
pub type uart_wakeup_mode_t = ::std::os::raw::c_uint;
#[doc = " @brief UART configuration parameters for uart_param_config function"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uart_config_t {
    #[doc = "< UART baud rate\nNote that the actual baud rate set could have a slight deviation from the user-configured value due to rounding error"]
    pub baud_rate: ::std::os::raw::c_int,
    #[doc = "< UART byte size"]
    pub data_bits: uart_word_length_t,
    #[doc = "< UART parity mode"]
    pub parity: uart_parity_t,
    #[doc = "< UART stop bits"]
    pub stop_bits: uart_stop_bits_t,
    #[doc = "< UART HW flow control mode (cts/rts)"]
    pub flow_ctrl: uart_hw_flowcontrol_t,
    #[doc = "< UART HW RTS threshold"]
    pub rx_flow_ctrl_thresh: u8,
    pub __bindgen_anon_1: uart_config_t__bindgen_ty_1,
    #[doc = "< Configuration flags"]
    pub flags: uart_config_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_config_t__bindgen_ty_1 {
    #[doc = "< UART source clock selection"]
    pub source_clk: uart_sclk_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_config_t__bindgen_ty_1"]
        [::std::mem::size_of::<uart_config_t__bindgen_ty_1>() - 4usize];
    ["Alignment of uart_config_t__bindgen_ty_1"]
        [::std::mem::align_of::<uart_config_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: uart_config_t__bindgen_ty_1::source_clk"]
        [::std::mem::offset_of!(uart_config_t__bindgen_ty_1, source_clk) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_config_t__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_config_t__bindgen_ty_2"]
        [::std::mem::size_of::<uart_config_t__bindgen_ty_2>() - 4usize];
    ["Alignment of uart_config_t__bindgen_ty_2"]
        [::std::mem::align_of::<uart_config_t__bindgen_ty_2>() - 4usize];
};
impl uart_config_t__bindgen_ty_2 {
    #[inline]
    pub fn allow_pd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn allow_pd_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_allow_pd_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn backup_before_sleep(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_backup_before_sleep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn backup_before_sleep_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_backup_before_sleep_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        allow_pd: u32,
        backup_before_sleep: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allow_pd: u32 = unsafe { ::std::mem::transmute(allow_pd) };
            allow_pd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let backup_before_sleep: u32 = unsafe { ::std::mem::transmute(backup_before_sleep) };
            backup_before_sleep as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_config_t"][::std::mem::size_of::<uart_config_t>() - 32usize];
    ["Alignment of uart_config_t"][::std::mem::align_of::<uart_config_t>() - 4usize];
    ["Offset of field: uart_config_t::baud_rate"]
        [::std::mem::offset_of!(uart_config_t, baud_rate) - 0usize];
    ["Offset of field: uart_config_t::data_bits"]
        [::std::mem::offset_of!(uart_config_t, data_bits) - 4usize];
    ["Offset of field: uart_config_t::parity"]
        [::std::mem::offset_of!(uart_config_t, parity) - 8usize];
    ["Offset of field: uart_config_t::stop_bits"]
        [::std::mem::offset_of!(uart_config_t, stop_bits) - 12usize];
    ["Offset of field: uart_config_t::flow_ctrl"]
        [::std::mem::offset_of!(uart_config_t, flow_ctrl) - 16usize];
    ["Offset of field: uart_config_t::rx_flow_ctrl_thresh"]
        [::std::mem::offset_of!(uart_config_t, rx_flow_ctrl_thresh) - 20usize];
    ["Offset of field: uart_config_t::flags"]
        [::std::mem::offset_of!(uart_config_t, flags) - 28usize];
};
#[doc = " @brief UART interrupt configuration parameters for uart_intr_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_intr_config_t {
    #[doc = "< UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator"]
    pub intr_enable_mask: u32,
    #[doc = "< UART timeout interrupt threshold (unit: time of sending one byte)"]
    pub rx_timeout_thresh: u8,
    #[doc = "< UART TX empty interrupt threshold."]
    pub txfifo_empty_intr_thresh: u8,
    #[doc = "< UART RX full interrupt threshold."]
    pub rxfifo_full_thresh: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_intr_config_t"][::std::mem::size_of::<uart_intr_config_t>() - 8usize];
    ["Alignment of uart_intr_config_t"][::std::mem::align_of::<uart_intr_config_t>() - 4usize];
    ["Offset of field: uart_intr_config_t::intr_enable_mask"]
        [::std::mem::offset_of!(uart_intr_config_t, intr_enable_mask) - 0usize];
    ["Offset of field: uart_intr_config_t::rx_timeout_thresh"]
        [::std::mem::offset_of!(uart_intr_config_t, rx_timeout_thresh) - 4usize];
    ["Offset of field: uart_intr_config_t::txfifo_empty_intr_thresh"]
        [::std::mem::offset_of!(uart_intr_config_t, txfifo_empty_intr_thresh) - 5usize];
    ["Offset of field: uart_intr_config_t::rxfifo_full_thresh"]
        [::std::mem::offset_of!(uart_intr_config_t, rxfifo_full_thresh) - 6usize];
};
#[doc = "< Triggered when the receiver either takes longer than rx_timeout_thresh\nto receive a byte, or when more data is received than what rxfifo_full_thresh\nspecifies"]
pub const uart_event_type_t_UART_DATA: uart_event_type_t = 0;
#[doc = "< Triggered when the receiver detects a NULL character"]
pub const uart_event_type_t_UART_BREAK: uart_event_type_t = 1;
#[doc = "< Triggered when RX ring buffer is full"]
pub const uart_event_type_t_UART_BUFFER_FULL: uart_event_type_t = 2;
#[doc = "< Triggered when the received data exceeds the capacity of the RX FIFO"]
pub const uart_event_type_t_UART_FIFO_OVF: uart_event_type_t = 3;
#[doc = "< Triggered when the receiver detects a data frame error"]
pub const uart_event_type_t_UART_FRAME_ERR: uart_event_type_t = 4;
#[doc = "< Triggered when a parity error is detected in the received data"]
pub const uart_event_type_t_UART_PARITY_ERR: uart_event_type_t = 5;
#[doc = "< Internal event triggered to signal a break afte data transmission"]
pub const uart_event_type_t_UART_DATA_BREAK: uart_event_type_t = 6;
#[doc = "< Triggered when a specified pattern  is detected in the incoming data"]
pub const uart_event_type_t_UART_PATTERN_DET: uart_event_type_t = 7;
#[doc = "< Maximum index for UART events"]
pub const uart_event_type_t_UART_EVENT_MAX: uart_event_type_t = 8;
#[doc = " @brief UART event types used in the ring buffer"]
pub type uart_event_type_t = ::std::os::raw::c_uint;
#[doc = " @brief Event structure used in UART event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_event_t {
    #[doc = "< UART event type"]
    pub type_: uart_event_type_t,
    #[doc = "< UART data size for UART_DATA event"]
    pub size: usize,
    #[doc = "< UART data read timeout flag for UART_DATA event (no new data received during configured RX TOUT)*/\n/*!< If the event is caused by FIFO-full interrupt, then there will be no event with the timeout flag before the next byte coming."]
    pub timeout_flag: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_event_t"][::std::mem::size_of::<uart_event_t>() - 24usize];
    ["Alignment of uart_event_t"][::std::mem::align_of::<uart_event_t>() - 8usize];
    ["Offset of field: uart_event_t::type_"][::std::mem::offset_of!(uart_event_t, type_) - 0usize];
    ["Offset of field: uart_event_t::size"][::std::mem::offset_of!(uart_event_t, size) - 8usize];
    ["Offset of field: uart_event_t::timeout_flag"]
        [::std::mem::offset_of!(uart_event_t, timeout_flag) - 16usize];
};
pub type uart_isr_handle_t = intr_handle_t;
unsafe extern "C" {
    #[doc = " @brief Install UART driver and set the UART to the default configuration.\n\n UART ISR handler will be attached to the same CPU core that this function is running on.\n\n @note  Rx_buffer_size should be greater than UART_HW_FIFO_LEN(uart_num). Tx_buffer_size should be either zero or greater than UART_HW_FIFO_LEN(uart_num).\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param rx_buffer_size UART RX ring buffer size.\n @param tx_buffer_size UART TX ring buffer size.\n        If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out.\n @param queue_size UART event queue size/depth.\n @param uart_queue UART event queue handle (out param). On success, a new queue handle is written here to provide\n        access to UART events. If set to NULL, driver will not use an event queue.\n @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)\n        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here\n        (the driver's ISR handler is not located in IRAM)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_driver_install(
        uart_num: uart_port_t,
        rx_buffer_size: ::std::os::raw::c_int,
        tx_buffer_size: ::std::os::raw::c_int,
        queue_size: ::std::os::raw::c_int,
        uart_queue: *mut QueueHandle_t,
        intr_alloc_flags: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Uninstall UART driver.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_driver_delete(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Checks whether the driver is installed or not\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - true  driver is installed\n     - false driver is not installed"]
    pub fn uart_is_driver_installed(uart_num: uart_port_t) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Set UART data bits.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param data_bit UART data bits\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_word_length(uart_num: uart_port_t, data_bit: uart_word_length_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the UART data bit configuration.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param data_bit Pointer to accept value of UART data bits.\n\n @return\n     - ESP_FAIL  Parameter error\n     - ESP_OK    Success, result will be put in (*data_bit)"]
    pub fn uart_get_word_length(
        uart_num: uart_port_t,
        data_bit: *mut uart_word_length_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set UART stop bits.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param stop_bits  UART stop bits\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Fail"]
    pub fn uart_set_stop_bits(uart_num: uart_port_t, stop_bits: uart_stop_bits_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the UART stop bit configuration.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param stop_bits  Pointer to accept value of UART stop bits.\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success, result will be put in (*stop_bit)"]
    pub fn uart_get_stop_bits(uart_num: uart_port_t, stop_bits: *mut uart_stop_bits_t)
        -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set UART parity mode.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param parity_mode the enum of uart parity configuration\n\n @return\n     - ESP_FAIL  Parameter error\n     - ESP_OK    Success"]
    pub fn uart_set_parity(uart_num: uart_port_t, parity_mode: uart_parity_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the UART parity mode configuration.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param parity_mode Pointer to accept value of UART parity mode.\n\n @return\n     - ESP_FAIL  Parameter error\n     - ESP_OK    Success, result will be put in (*parity_mode)\n"]
    pub fn uart_get_parity(uart_num: uart_port_t, parity_mode: *mut uart_parity_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the frequency of a clock source for the HP UART port\n\n @param sclk Clock source\n @param[out] out_freq_hz Output of frequency, in Hz\n\n @return\n  - ESP_ERR_INVALID_ARG: if the clock source is not supported\n  - otherwise ESP_OK"]
    pub fn uart_get_sclk_freq(sclk: uart_sclk_t, out_freq_hz: *mut u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set desired UART baud rate.\n\n Note that the actual baud rate set could have a slight deviation from the user-configured value due to rounding error.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param baudrate UART baud rate.\n\n @return\n     - ESP_FAIL Parameter error, such as baud rate unachievable\n     - ESP_OK   Success"]
    pub fn uart_set_baudrate(uart_num: uart_port_t, baudrate: u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the actual UART baud rate.\n\n It returns the real UART rate set in the hardware. It could have a slight deviation from the user-configured baud rate.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param baudrate Pointer to accept value of UART baud rate\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success, result will be put in (*baudrate)\n"]
    pub fn uart_get_baudrate(uart_num: uart_port_t, baudrate: *mut u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set UART line inverse mode\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param inverse_mask Choose the wires that need to be inverted. Using the ORred mask of `uart_signal_inv_t`\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_line_inverse(uart_num: uart_port_t, inverse_mask: u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set hardware flow control.\n\n @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1).\n @param flow_ctrl Hardware flow control mode\n @param rx_thresh Threshold of Hardware RX flow control (0 ~ UART_HW_FIFO_LEN(uart_num)).\n        Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: uart_hw_flowcontrol_t,
        rx_thresh: u8,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set software flow control.\n\n @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1)\n @param enable     switch on or off\n @param rx_thresh_xon  low water mark\n @param rx_thresh_xoff high water mark\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_sw_flow_ctrl(
        uart_num: uart_port_t,
        enable: bool,
        rx_thresh_xon: u8,
        rx_thresh_xoff: u8,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the UART hardware flow control configuration.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param flow_ctrl Option for different flow control mode.\n\n @return\n     - ESP_FAIL Parameter error\n     - ESP_OK   Success, result will be put in (*flow_ctrl)"]
    pub fn uart_get_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: *mut uart_hw_flowcontrol_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Clear UART interrupt status\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param clr_mask  Bit mask of the interrupt status to be cleared.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_clear_intr_status(uart_num: uart_port_t, clr_mask: u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set UART interrupt enable\n\n @param uart_num     UART port number, the max port number is (UART_NUM_MAX -1).\n @param enable_mask  Bit mask of the enable bits.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_intr_mask(uart_num: uart_port_t, enable_mask: u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Clear UART interrupt enable bits\n\n @param uart_num      UART port number, the max port number is (UART_NUM_MAX -1).\n @param disable_mask  Bit mask of the disable bits.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_intr_mask(uart_num: uart_port_t, disable_mask: u32) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Enable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Disable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Disable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)\n\n @param uart_num  UART port number\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_tx_intr(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Enable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param enable  1: enable; 0: disable\n @param thresh  Threshold of TX interrupt, 0 ~ UART_HW_FIFO_LEN(uart_num)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_tx_intr(
        uart_num: uart_port_t,
        enable: ::std::os::raw::c_int,
        thresh: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Assign signals of a UART peripheral to GPIO pins\n\n @note If the GPIO number configured for a UART signal matches one of the\n       IOMUX signals for that GPIO, the signal will be connected directly\n       via the IOMUX. Otherwise the GPIO and signal will be connected via\n       the GPIO Matrix. For example, if on an ESP32 the call\n       `uart_set_pin(0, 1, 3, -1, -1)` is performed, as GPIO1 is UART0's\n       default TX pin and GPIO3 is UART0's default RX pin, both will be\n       connected to respectively U0TXD and U0RXD through the IOMUX, totally\n       bypassing the GPIO matrix.\n       The check is performed on a per-pin basis. Thus, it is possible to have\n       RX pin binded to a GPIO through the GPIO matrix, whereas TX is binded\n       to its GPIO through the IOMUX.\n\n @note It is possible to configure TX and RX to share the same IO (single wire mode),\n       but please be aware of output conflict, which could damage the pad.\n       Apply open-drain and pull-up to the pad ahead of time as a protection,\n       or the upper layer protocol must guarantee no output from two ends at the same time.\n\n @param uart_num   UART port number, the max port number is (UART_NUM_MAX -1).\n @param tx_io_num  UART TX pin GPIO number.\n @param rx_io_num  UART RX pin GPIO number.\n @param rts_io_num UART RTS pin GPIO number.\n @param cts_io_num UART CTS pin GPIO number.\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_pin(
        uart_num: uart_port_t,
        tx_io_num: ::std::os::raw::c_int,
        rx_io_num: ::std::os::raw::c_int,
        rts_io_num: ::std::os::raw::c_int,
        cts_io_num: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Manually set the UART RTS pin level.\n @note  UART must be configured with hardware flow control disabled.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param level    1: RTS output low (active); 0: RTS output high (block)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_rts(uart_num: uart_port_t, level: ::std::os::raw::c_int) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Manually set the UART DTR pin level.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param level    1: DTR output low; 0: DTR output high\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_dtr(uart_num: uart_port_t, level: ::std::os::raw::c_int) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set UART idle interval after tx FIFO is empty\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param idle_num idle interval after tx FIFO is empty(unit: the time it takes to send one bit\n        under current baudrate)\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_set_tx_idle_num(uart_num: uart_port_t, idle_num: u16) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set UART configuration parameters.\n\n @param uart_num    UART port number, the max port number is (UART_NUM_MAX -1).\n @param uart_config UART parameter settings\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error, such as baud rate unachievable"]
    pub fn uart_param_config(uart_num: uart_port_t, uart_config: *const uart_config_t)
        -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Configure UART interrupts.\n\n @param uart_num  UART port number, the max port number is (UART_NUM_MAX -1).\n @param intr_conf UART interrupt settings\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_intr_config(
        uart_num: uart_port_t,
        intr_conf: *const uart_intr_config_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Wait until UART TX FIFO is empty.\n\n @param uart_num      UART port number, the max port number is (UART_NUM_MAX -1).\n @param ticks_to_wait Timeout, count in RTOS ticks\n\n @return\n     - ESP_OK   Success\n     - ESP_FAIL Parameter error\n     - ESP_ERR_TIMEOUT  Timeout"]
    pub fn uart_wait_tx_done(uart_num: uart_port_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length.\n\n This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full.\n @note This function should only be used when UART TX buffer is not enabled.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param buffer data buffer address\n @param len    data length to send\n\n @return\n     - (-1)  Parameter error\n     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_tx_chars(
        uart_num: uart_port_t,
        buffer: *const ::std::os::raw::c_char,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,\n\n If the UART driver's parameter 'tx_buffer_size' is set to zero:\n This function will not return until all the data have been sent out, or at least pushed into TX FIFO.\n\n Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,\n UART ISR will then move data from the ring buffer to TX FIFO gradually.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param src   data buffer address\n @param size  data length to send\n\n @return\n     - (-1) Parameter error\n     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes(
        uart_num: uart_port_t,
        src: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,\n\n If the UART driver's parameter 'tx_buffer_size' is set to zero:\n This function will not return until all the data and the break signal have been sent out.\n After all data is sent out, send a break signal.\n\n Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,\n UART ISR will then move data from the ring buffer to TX FIFO gradually.\n After all data sent out, send a break signal.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param src   data buffer address\n @param size  data length to send\n @param brk_len break signal duration(unit: the time it takes to send one bit at current baudrate)\n\n @return\n     - (-1) Parameter error\n     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes_with_break(
        uart_num: uart_port_t,
        src: *const ::std::os::raw::c_void,
        size: usize,
        brk_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief UART read bytes from UART buffer\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param buf     pointer to the buffer.\n @param length  data length\n @param ticks_to_wait sTimeout, count in RTOS ticks\n\n @return\n     - (-1) Error\n     - OTHERS (>=0) The number of bytes read from UART buffer"]
    pub fn uart_read_bytes(
        uart_num: uart_port_t,
        buf: *mut ::std::os::raw::c_void,
        length: u32,
        ticks_to_wait: TickType_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Alias of uart_flush_input.\n        UART ring buffer flush. This will discard all data in the UART RX buffer.\n @note  Instead of waiting the data sent out, this function will clear UART rx buffer.\n        In order to send all the data in tx FIFO, we can use uart_wait_tx_done function.\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_flush(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Clear input buffer, discard all the data is in the ring-buffer.\n @note  In order to send all the data in tx FIFO, we can use uart_wait_tx_done function.\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_flush_input(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief   UART get RX ring buffer cached data length\n\n @param   uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param   size Pointer of size_t to accept cached data length\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_get_buffered_data_len(uart_num: uart_port_t, size: *mut usize) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief   UART get TX ring buffer free space size\n\n @param   uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param   size Pointer of size_t to accept the free space size\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_tx_buffer_free_size(uart_num: uart_port_t, size: *mut usize) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief   UART disable pattern detect function.\n          Designed for applications like 'AT commands'.\n          When the hardware detects a series of one same character, the interrupt will be triggered.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_disable_pattern_det_intr(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief UART enable pattern detect function.\n        Designed for applications like 'AT commands'.\n        When the hardware detect a series of one same character, the interrupt will be triggered.\n\n @param uart_num UART port number.\n @param pattern_chr character of the pattern.\n @param chr_num number of the character, 8bit value.\n @param chr_tout timeout of the interval between each pattern characters, 16bit value, unit is the baud-rate cycle you configured.\n        When the duration is more than this value, it will not take this data as at_cmd char.\n @param post_idle idle time after the last pattern character, 16bit value, unit is the baud-rate cycle you configured.\n        When the duration is less than this value, it will not take the previous data as the last at_cmd char\n @param pre_idle idle time before the first pattern character, 16bit value, unit is the baud-rate cycle you configured.\n        When the duration is less than this value, it will not take this data as the first at_cmd char.\n\n @return\n     - ESP_OK Success\n     - ESP_FAIL Parameter error"]
    pub fn uart_enable_pattern_det_baud_intr(
        uart_num: uart_port_t,
        pattern_chr: ::std::os::raw::c_char,
        chr_num: u8,
        chr_tout: ::std::os::raw::c_int,
        post_idle: ::std::os::raw::c_int,
        pre_idle: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer.\n        The positions of the detected pattern are saved in a queue,\n        this function will dequeue the first pattern position and move the pointer to next pattern position.\n @note  If the RX buffer is full and flow control is not enabled,\n        the detected pattern may not be found in the rx buffer due to overflow.\n\n        The following APIs will modify the pattern position info:\n        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos\n        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer\n        when using pattern detect feature.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @return\n     - (-1) No pattern found for current index or parameter error\n     - others the pattern position in rx buffer."]
    pub fn uart_pattern_pop_pos(uart_num: uart_port_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer.\n        The positions of the detected pattern are saved in a queue,\n        This function do nothing to the queue.\n @note  If the RX buffer is full and flow control is not enabled,\n        the detected pattern may not be found in the rx buffer due to overflow.\n\n        The following APIs will modify the pattern position info:\n        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos\n        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer\n        when using pattern detect feature.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @return\n     - (-1) No pattern found for current index or parameter error\n     - others the pattern position in rx buffer."]
    pub fn uart_pattern_get_pos(uart_num: uart_port_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Allocate a new memory with the given length to save record the detected pattern position in rx buffer.\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1).\n @param queue_length Max queue length for the detected pattern.\n        If the queue length is not large enough, some pattern positions might be lost.\n        Set this value to the maximum number of patterns that could be saved in data buffer at the same time.\n @return\n     - ESP_ERR_NO_MEM No enough memory\n     - ESP_ERR_INVALID_STATE Driver not installed\n     - ESP_FAIL Parameter error\n     - ESP_OK Success"]
    pub fn uart_pattern_queue_reset(
        uart_num: uart_port_t,
        queue_length: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief UART set communication mode\n\n @note  This function must be executed after uart_driver_install(), when the driver object is initialized.\n @param uart_num     Uart number to configure, the max port number is (UART_NUM_MAX -1).\n @param mode UART    UART mode to set\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_mode(uart_num: uart_port_t, mode: uart_mode_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set uart threshold value for RX fifo full\n @note If application is using higher baudrate and it is observed that bytes\n       in hardware RX fifo are overwritten then this threshold can be reduced\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)\n @param threshold Threshold value above which RX fifo full interrupt is generated\n\n @return\n     - ESP_OK   Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_full_threshold(
        uart_num: uart_port_t,
        threshold: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set uart threshold values for TX fifo empty\n\n @param uart_num UART port number, the max port number is (UART_NUM_MAX -1)\n @param threshold Threshold value below which TX fifo empty interrupt is generated\n\n @return\n     - ESP_OK   Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_tx_empty_threshold(
        uart_num: uart_port_t,
        threshold: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief UART set threshold timeout for TOUT feature\n\n @param uart_num     Uart number to configure, the max port number is (UART_NUM_MAX -1).\n @param tout_thresh  This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126.\n        tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate.\n        If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0,\n        the TOUT feature is disabled.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error\n     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_timeout(uart_num: uart_port_t, tout_thresh: u8) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Returns collision detection flag for RS485 mode\n        Function returns the collision detection flag into variable pointed by collision_flag.\n        *collision_flag = true, if collision detected else it is equal to false.\n        This function should be executed when actual transmission is completed (after uart_write_bytes()).\n\n @param uart_num  Uart number to configure the max port number is (UART_NUM_MAX -1).\n @param collision_flag Pointer to variable of type bool to return collision flag.\n\n @return\n     - ESP_OK Success\n     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_collision_flag(uart_num: uart_port_t, collision_flag: *mut bool) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Set the number of RX pin signal edges for light sleep wakeup\n\n UART can be used to wake up the system from light sleep. This feature works\n by counting the number of positive edges on RX pin and comparing the count to\n the threshold. When the count exceeds the threshold, system is woken up from\n light sleep. This function allows setting the threshold value.\n\n Stop bit and parity bits (if enabled) also contribute to the number of edges.\n For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire\n (with 8n1 configuration), start and stop bits included. This sequence has 3\n positive edges (transitions from 0 to 1). Therefore, to wake up the system\n when 'a' is sent, set wakeup_threshold=3.\n\n The character that triggers wakeup is not received by UART (i.e. it can not\n be obtained from UART FIFO). Depending on the baud rate, a few characters\n after that will also not be received. Note that when the chip enters and exits\n light sleep mode, APB frequency will be changing. To ensure that UART has\n correct Baud rate all the time, it is necessary to select a source clock which has\n a fixed frequency and remains active during sleep. For the supported clock sources\n of the chips, please refer to `uart_sclk_t` or `soc_periph_uart_clk_src_legacy_t`\n\n @note in ESP32, the wakeup signal can only be input via IO_MUX (i.e.\n       GPIO3 should be configured as function_1 to wake up UART0,\n       GPIO9 should be configured as function_5 to wake up UART1), UART2\n       does not support light sleep wakeup feature.\n\n @param uart_num  UART number, the max port number is (UART_NUM_MAX -1).\n @param wakeup_threshold  number of RX edges for light sleep wakeup, value is 3 .. 0x3ff.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is\n        outside of [3, 0x3ff] range."]
    pub fn uart_set_wakeup_threshold(
        uart_num: uart_port_t,
        wakeup_threshold: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Get the number of RX pin signal edges for light sleep wakeup.\n\n See description of uart_set_wakeup_threshold for the explanation of UART\n wakeup feature.\n\n @param uart_num  UART number, the max port number is (UART_NUM_MAX -1).\n @param[out] out_wakeup_threshold  output, set to the current value of wakeup\n                                   threshold for the given UART.\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL"]
    pub fn uart_get_wakeup_threshold(
        uart_num: uart_port_t,
        out_wakeup_threshold: *mut ::std::os::raw::c_int,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Wait until UART tx memory empty and the last char send ok (polling mode).\n\n @param uart_num UART number\n\n * @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_FAIL Driver not installed"]
    pub fn uart_wait_tx_idle_polling(uart_num: uart_port_t) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Configure TX signal loop back to RX module, just for the test usage.\n\n @param uart_num UART number\n @param loop_back_en Set true to enable the loop back function, else set it false.\n\n * @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_FAIL Driver not installed"]
    pub fn uart_set_loop_back(uart_num: uart_port_t, loop_back_en: bool) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Configure behavior of UART RX timeout interrupt.\n\n When always_rx_timeout is true, timeout interrupt is triggered even if FIFO is full.\n This function can cause extra timeout interrupts triggered only to send the timeout event.\n Call this function only if you want to ensure timeout interrupt will always happen after a byte stream.\n\n @param uart_num UART number\n @param always_rx_timeout_en Set to false enable the default behavior of timeout interrupt,\n                             set it to true to always trigger timeout interrupt.\n"]
    pub fn uart_set_always_rx_timeout(uart_num: uart_port_t, always_rx_timeout_en: bool);
}
#[doc = " AUTO BAUD RATE DETECTION *****************************/\n/**\n @brief UART bitrate detection configuration parameters for `uart_detect_bitrate_start` function to acquire a new uart handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_bitrate_detect_config_t {
    #[doc = "< GPIO pin number for the incoming signal"]
    pub rx_io_num: ::std::os::raw::c_int,
    #[doc = "< The higher the frequency of the clock source, the more accurate the detected bitrate value;\nThe slower the frequency of the clock source, the slower the bitrate can be measured"]
    pub source_clk: uart_sclk_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_bitrate_detect_config_t"]
        [::std::mem::size_of::<uart_bitrate_detect_config_t>() - 8usize];
    ["Alignment of uart_bitrate_detect_config_t"]
        [::std::mem::align_of::<uart_bitrate_detect_config_t>() - 4usize];
    ["Offset of field: uart_bitrate_detect_config_t::rx_io_num"]
        [::std::mem::offset_of!(uart_bitrate_detect_config_t, rx_io_num) - 0usize];
    ["Offset of field: uart_bitrate_detect_config_t::source_clk"]
        [::std::mem::offset_of!(uart_bitrate_detect_config_t, source_clk) - 4usize];
};
#[doc = " @brief Structure to store the measurement results for UART bitrate detection within the measurement period\n\n Formula to calculate the bitrate:\n If the signal is ideal,\n      bitrate = clk_freq_hz * 2 / (low_period + high_period)\n If the signal is weak along falling edges, then you may use\n      bitrate = clk_freq_hz * 2 / pos_period\n If the signal is weak along rising edges, then you may use\n      bitrate = clk_freq_hz * 2 / neg_period"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_bitrate_res_t {
    #[doc = "< Stores the minimum tick count of a low-level pulse"]
    pub low_period: u32,
    #[doc = "< Stores the minimum tick count of a high-level pulse"]
    pub high_period: u32,
    #[doc = "< Stores the minimum tick count between two positive edges"]
    pub pos_period: u32,
    #[doc = "< Stores the minimum tick count between two negative edges"]
    pub neg_period: u32,
    #[doc = "< Stores the count of RX edge changes (10-bit counter, be careful, it could overflow)"]
    pub edge_cnt: u32,
    #[doc = "< The frequency of the tick being used to count the measurement results, in Hz"]
    pub clk_freq_hz: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of uart_bitrate_res_t"][::std::mem::size_of::<uart_bitrate_res_t>() - 24usize];
    ["Alignment of uart_bitrate_res_t"][::std::mem::align_of::<uart_bitrate_res_t>() - 4usize];
    ["Offset of field: uart_bitrate_res_t::low_period"]
        [::std::mem::offset_of!(uart_bitrate_res_t, low_period) - 0usize];
    ["Offset of field: uart_bitrate_res_t::high_period"]
        [::std::mem::offset_of!(uart_bitrate_res_t, high_period) - 4usize];
    ["Offset of field: uart_bitrate_res_t::pos_period"]
        [::std::mem::offset_of!(uart_bitrate_res_t, pos_period) - 8usize];
    ["Offset of field: uart_bitrate_res_t::neg_period"]
        [::std::mem::offset_of!(uart_bitrate_res_t, neg_period) - 12usize];
    ["Offset of field: uart_bitrate_res_t::edge_cnt"]
        [::std::mem::offset_of!(uart_bitrate_res_t, edge_cnt) - 16usize];
    ["Offset of field: uart_bitrate_res_t::clk_freq_hz"]
        [::std::mem::offset_of!(uart_bitrate_res_t, clk_freq_hz) - 20usize];
};
unsafe extern "C" {
    #[doc = " @brief Start to do a bitrate detection for an incoming data signal (auto baud rate detection)\n\n This function can act as a standalone API. No need to install UART driver before calling this function.\n\n It is recommended that the incoming data line contains alternating bit sequence, data bytes such as `0x55` or `0xAA`. Characters `NULL', `0xCC` are not good for the measurement.\n\n @param uart_num The ID of the UART port to be used to do the measurement. Note that only HP UART ports have the capability.\n @param config Pointer to the configuration structure for the UART port. If the port has already been acquired, this parameter is ignored.\n\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_FAIL No free uart port or source_clk invalid"]
    pub fn uart_detect_bitrate_start(
        uart_num: uart_port_t,
        config: *const uart_bitrate_detect_config_t,
    ) -> esp_err_t;
}
unsafe extern "C" {
    #[doc = " @brief Stop the bitrate detection\n\n The measurement period should last for at least one-byte long if detecting UART baud rate, then call this function to stop and get the measurement result.\n\n @param uart_num The ID of the UART port\n @param deinit Whether to release the UART port after finishing the measurement\n @param[out] ret_res Structure to store the measurement results\n @return\n      - ESP_OK on success\n      - ESP_ERR_INVALID_ARG Parameter error\n      - ESP_FAIL Unknown tick frequency"]
    pub fn uart_detect_bitrate_stop(
        uart_num: uart_port_t,
        deinit: bool,
        ret_res: *mut uart_bitrate_res_t,
    ) -> esp_err_t;
}
#[doc = " Type by which software timers are referenced.  For example, a call to\n xTimerCreate() returns an TimerHandle_t variable that can then be used to\n reference the subject timer in calls to other software timer API functions\n (for example, xTimerStart(), xTimerReset(), etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmrTimerControl {
    _unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
#[doc = " Defines the prototype to which timer callback functions must conform."]
pub type TimerCallbackFunction_t =
    ::std::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
#[doc = " Defines the prototype to which functions used with the\n xTimerPendFunctionCallFromISR() function must conform."]
pub type PendedFunction_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: u32)>;
unsafe extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const ::std::os::raw::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::std::os::raw::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    pub fn xTimerCreateStatic(
        pcTimerName: *const ::std::os::raw::c_char,
        xTimerPeriodInTicks: TickType_t,
        xAutoReload: BaseType_t,
        pvTimerID: *mut ::std::os::raw::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
        pxTimerBuffer: *mut StaticTimer_t,
    ) -> TimerHandle_t;
}
unsafe extern "C" {
    #[doc = " Returns the ID assigned to the timer.\n\n IDs are assigned to timers using the pvTimerID parameter of the call to\n xTimerCreated() that was used to create the timer, and by calling the\n vTimerSetTimerID() API function.\n\n If the same callback function is assigned to multiple timers then the timer\n ID can be used as time specific (timer local) storage.\n\n @param xTimer The timer being queried.\n\n @return The ID assigned to the timer being queried.\n\n Example usage:\n\n See the xTimerCreate() API function example usage scenario."]
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Sets the ID assigned to the timer.\n\n IDs are assigned to timers using the pvTimerID parameter of the call to\n xTimerCreated() that was used to create the timer.\n\n If the same callback function is assigned to multiple timers then the timer\n ID can be used as time specific (timer local) storage.\n\n @param xTimer The timer being updated.\n\n @param pvNewID The ID to assign to the timer.\n\n Example usage:\n\n See the xTimerCreate() API function example usage scenario."]
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Queries a timer to see if it is active or dormant.\n\n A timer will be dormant if:\n     1) It has been created but not started, or\n     2) It is an expired one-shot timer that has not been restarted.\n\n Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),\n xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and\n xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the\n active state.\n\n @param xTimer The timer being queried.\n\n @return pdFALSE will be returned if the timer is dormant.  A value other than\n pdFALSE will be returned if the timer is active.\n\n Example usage:\n @verbatim\n // This function assumes xTimer has already been created.\n void vAFunction( TimerHandle_t xTimer )\n {\n     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\"\n     {\n         // xTimer is active, do something.\n     }\n     else\n     {\n         // xTimer is not active, do something else.\n     }\n }\n @endverbatim"]
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Simply returns the handle of the timer service/daemon task.  It it not valid\n to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
unsafe extern "C" {
    #[doc = " Used from application interrupt service routines to defer the execution of a\n function to the RTOS daemon task (the timer service task, hence this function\n is implemented in timers.c and is prefixed with 'Timer').\n\n Ideally an interrupt service routine (ISR) is kept as short as possible, but\n sometimes an ISR either has a lot of processing to do, or needs to perform\n processing that is not deterministic.  In these cases\n xTimerPendFunctionCallFromISR() can be used to defer processing of a function\n to the RTOS daemon task.\n\n A mechanism is provided that allows the interrupt to return directly to the\n task that will subsequently execute the pended callback function.  This\n allows the callback function to execute contiguously in time with the\n interrupt - just as if the callback had executed in the interrupt itself.\n\n @param xFunctionToPend The function to execute from the timer service/\n daemon task.  The function must conform to the PendedFunction_t\n prototype.\n\n @param pvParameter1 The value of the callback function's first parameter.\n The parameter has a void * type to allow it to be used to pass any type.\n For example, unsigned longs can be cast to a void *, or the void * can be\n used to point to a structure.\n\n @param ulParameter2 The value of the callback function's second parameter.\n\n @param pxHigherPriorityTaskWoken As mentioned above, calling this function\n will result in a message being sent to the timer daemon task.  If the\n priority of the timer daemon task (which is set using\n configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of\n the currently running task (the task the interrupt interrupted) then\n *pxHigherPriorityTaskWoken will be set to pdTRUE within\n xTimerPendFunctionCallFromISR(), indicating that a context switch should be\n requested before the interrupt exits.  For that reason\n *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the\n example code below.\n\n @return pdPASS is returned if the message was successfully sent to the\n timer daemon task, otherwise pdFALSE is returned.\n\n Example usage:\n @verbatim\n\n  // The callback function that will execute in the context of the daemon task.\n  // Note callback functions must all use this same prototype.\n  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )\n  {\n      BaseType_t xInterfaceToService;\n\n      // The interface that requires servicing is passed in the second\n      // parameter.  The first parameter is not used in this case.\n      xInterfaceToService = ( BaseType_t ) ulParameter2;\n\n      // ...Perform the processing here...\n  }\n\n  // An ISR that receives data packets from multiple interfaces\n  void vAnISR( void )\n  {\n      BaseType_t xInterfaceToService, xHigherPriorityTaskWoken;\n\n      // Query the hardware to determine which interface needs processing.\n      xInterfaceToService = prvCheckInterfaces();\n\n      // The actual processing is to be deferred to a task.  Request the\n      // vProcessInterface() callback function is executed, passing in the\n      // number of the interface that needs processing.  The interface to\n      // service is passed in the second parameter.  The first parameter is\n      // not used in this case.\n      xHigherPriorityTaskWoken = pdFALSE;\n      xTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );\n\n      // If xHigherPriorityTaskWoken is now set to pdTRUE then a context\n      // switch should be requested.  The macro used is port specific and will\n      // be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to\n      // the documentation page for the port being used.\n      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );\n\n  }\n @endverbatim"]
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::std::os::raw::c_void,
        ulParameter2: u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Used to defer the execution of a function to the RTOS daemon task (the timer\n service task, hence this function is implemented in timers.c and is prefixed\n with 'Timer').\n\n @param xFunctionToPend The function to execute from the timer service/\n daemon task.  The function must conform to the PendedFunction_t\n prototype.\n\n @param pvParameter1 The value of the callback function's first parameter.\n The parameter has a void * type to allow it to be used to pass any type.\n For example, unsigned longs can be cast to a void *, or the void * can be\n used to point to a structure.\n\n @param ulParameter2 The value of the callback function's second parameter.\n\n @param xTicksToWait Calling this function will result in a message being\n sent to the timer daemon task on a queue.  xTicksToWait is the amount of\n time the calling task should remain in the Blocked state (so not using any\n processing time) for space to become available on the timer queue if the\n queue is found to be full.\n\n @return pdPASS is returned if the message was successfully sent to the\n timer daemon task, otherwise pdFALSE is returned.\n"]
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::std::os::raw::c_void,
        ulParameter2: u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Returns the name that was assigned to a timer when the timer was created.\n\n @param xTimer The handle of the timer being queried.\n\n @return The name assigned to the timer specified by the xTimer parameter."]
    pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Updates a timer to be either an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being updated.\n\n @param xAutoReload If xAutoReload is set to pdTRUE then the timer will\n expire repeatedly with a frequency set by the timer's period (see the\n xTimerPeriodInTicks parameter of the xTimerCreate() API function).  If\n xAutoReload is set to pdFALSE then the timer will be a one-shot timer and\n enter the dormant state after it expires."]
    pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, xAutoReload: BaseType_t);
}
unsafe extern "C" {
    #[doc = " Queries a timer to determine if it is an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise\n pdFALSE is returned."]
    pub fn xTimerGetReloadMode(xTimer: TimerHandle_t) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " Queries a timer to determine if it is an auto-reload timer, in which case the timer\n automatically resets itself each time it expires, or a one-shot timer, in\n which case the timer will only expire once unless it is manually restarted.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is an auto-reload timer then pdTRUE is returned, otherwise\n pdFALSE is returned."]
    pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
unsafe extern "C" {
    #[doc = " Returns the period of a timer.\n\n @param xTimer The handle of the timer being queried.\n\n @return The period of the timer in ticks."]
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    #[doc = " Returns the time in ticks at which the timer will expire.  If this is less\n than the current tick count then the expiry time has overflowed from the\n current time.\n\n @param xTimer The handle of the timer being queried.\n\n @return If the timer is running then the time in ticks at which the timer\n will next expire is returned.  If the timer is not running then the return\n value is undefined."]
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
unsafe extern "C" {
    pub fn xTimerGetStaticBuffer(
        xTimer: TimerHandle_t,
        ppxTimerBuffer: *mut *mut StaticTimer_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
unsafe extern "C" {
    pub fn xTimerGenericCommand(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " This function is used to provide a statically allocated block of memory to FreeRTOS to hold the Timer Task TCB.  This function is required when\n configSUPPORT_STATIC_ALLOCATION is set.  For more information see this URI: https://www.FreeRTOS.org/a00110.html#configSUPPORT_STATIC_ALLOCATION\n\n @param ppxTimerTaskTCBBuffer   A handle to a statically allocated TCB buffer\n @param ppxTimerTaskStackBuffer A handle to a statically allocated Stack buffer for the idle task\n @param pulTimerTaskStackSize   A pointer to the number of elements that will fit in the allocated stack buffer"]
    pub fn vApplicationGetTimerTaskMemory(
        ppxTimerTaskTCBBuffer: *mut *mut StaticTask_t,
        ppxTimerTaskStackBuffer: *mut *mut StackType_t,
        pulTimerTaskStackSize: *mut u32,
    );
}
#[doc = " Type by which event groups are referenced.  For example, a call to\n xEventGroupCreate() returns an EventGroupHandle_t variable that can then\n be used as a parameter to other event group functions.\n\n \\ingroup EventGroup"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventGroupDef_t {
    _unused: [u8; 0],
}
pub type EventGroupHandle_t = *mut EventGroupDef_t;
pub type EventBits_t = TickType_t;
unsafe extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
unsafe extern "C" {
    pub fn xEventGroupCreateStatic(
        pxEventGroupBuffer: *mut StaticEventGroup_t,
    ) -> EventGroupHandle_t;
}
unsafe extern "C" {
    #[doc = " [Potentially] block to wait for one or more bits to be set within a\n previously created event group.\n\n This function cannot be called from an interrupt.\n\n @param xEventGroup The event group in which the bits are being tested.  The\n event group must have previously been created using a call to\n xEventGroupCreate().\n\n @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test\n inside the event group.  For example, to wait for bit 0 and/or bit 2 set\n uxBitsToWaitFor to 0x05.  To wait for bits 0 and/or bit 1 and/or bit 2 set\n uxBitsToWaitFor to 0x07.  Etc.\n\n @param xClearOnExit If xClearOnExit is set to pdTRUE then any bits within\n uxBitsToWaitFor that are set within the event group will be cleared before\n xEventGroupWaitBits() returns if the wait condition was met (if the function\n returns for a reason other than a timeout).  If xClearOnExit is set to\n pdFALSE then the bits set in the event group are not altered when the call to\n xEventGroupWaitBits() returns.\n\n @param xWaitForAllBits If xWaitForAllBits is set to pdTRUE then\n xEventGroupWaitBits() will return when either all the bits in uxBitsToWaitFor\n are set or the specified block time expires.  If xWaitForAllBits is set to\n pdFALSE then xEventGroupWaitBits() will return when any one of the bits set\n in uxBitsToWaitFor is set or the specified block time expires.  The block\n time is specified by the xTicksToWait parameter.\n\n @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait\n for one/all (depending on the xWaitForAllBits value) of the bits specified by\n uxBitsToWaitFor to become set. A value of portMAX_DELAY can be used to block\n indefinitely (provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h).\n\n @return The value of the event group at the time either the bits being waited\n for became set, or the block time expired.  Test the return value to know\n which bits were set.  If xEventGroupWaitBits() returned because its timeout\n expired then not all the bits being waited for will be set.  If\n xEventGroupWaitBits() returned because the bits it was waiting for were set\n then the returned value is the event group value before any bits were\n automatically cleared in the case that xClearOnExit parameter was set to\n pdTRUE.\n\n Example usage:\n @code{c}\n #define BIT_0 ( 1 << 0 )\n #define BIT_4 ( 1 << 4 )\n\n void aFunction( EventGroupHandle_t xEventGroup )\n {\n EventBits_t uxBits;\n const TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;\n\n      // Wait a maximum of 100ms for either bit 0 or bit 4 to be set within\n      // the event group.  Clear the bits before exiting.\n      uxBits = xEventGroupWaitBits(\n                  xEventGroup,    // The event group being tested.\n                  BIT_0 | BIT_4,  // The bits within the event group to wait for.\n                  pdTRUE,         // BIT_0 and BIT_4 should be cleared before returning.\n                  pdFALSE,        // Don't wait for both bits, either bit will do.\n                  xTicksToWait ); // Wait a maximum of 100ms for either bit to be set.\n\n      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )\n      {\n          // xEventGroupWaitBits() returned because both bits were set.\n      }\n      else if( ( uxBits & BIT_0 ) != 0 )\n      {\n          // xEventGroupWaitBits() returned because just BIT_0 was set.\n      }\n      else if( ( uxBits & BIT_4 ) != 0 )\n      {\n          // xEventGroupWaitBits() returned because just BIT_4 was set.\n      }\n      else\n      {\n          // xEventGroupWaitBits() returned because xTicksToWait ticks passed\n          // without either BIT_0 or BIT_4 becoming set.\n      }\n }\n @endcode\n \\ingroup EventGroup"]
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    #[doc = " Clear bits within an event group.  This function cannot be called from an\n interrupt.\n\n @param xEventGroup The event group in which the bits are to be cleared.\n\n @param uxBitsToClear A bitwise value that indicates the bit or bits to clear\n in the event group.  For example, to clear bit 3 only, set uxBitsToClear to\n 0x08.  To clear bit 3 and bit 0 set uxBitsToClear to 0x09.\n\n @return The value of the event group before the specified bits were cleared.\n\n Example usage:\n @code{c}\n #define BIT_0 ( 1 << 0 )\n #define BIT_4 ( 1 << 4 )\n\n void aFunction( EventGroupHandle_t xEventGroup )\n {\n EventBits_t uxBits;\n\n      // Clear bit 0 and bit 4 in xEventGroup.\n      uxBits = xEventGroupClearBits(\n                              xEventGroup,    // The event group being updated.\n                              BIT_0 | BIT_4 );// The bits being cleared.\n\n      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )\n      {\n          // Both bit 0 and bit 4 were set before xEventGroupClearBits() was\n          // called.  Both will now be clear (not set).\n      }\n      else if( ( uxBits & BIT_0 ) != 0 )\n      {\n          // Bit 0 was set before xEventGroupClearBits() was called.  It will\n          // now be clear.\n      }\n      else if( ( uxBits & BIT_4 ) != 0 )\n      {\n          // Bit 4 was set before xEventGroupClearBits() was called.  It will\n          // now be clear.\n      }\n      else\n      {\n          // Neither bit 0 nor bit 4 were set in the first place.\n      }\n }\n @endcode\n \\ingroup EventGroup"]
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    #[doc = " Set bits within an event group.\n This function cannot be called from an interrupt.  xEventGroupSetBitsFromISR()\n is a version that can be called from an interrupt.\n\n Setting bits in an event group will automatically unblock tasks that are\n blocked waiting for the bits.\n\n @param xEventGroup The event group in which the bits are to be set.\n\n @param uxBitsToSet A bitwise value that indicates the bit or bits to set.\n For example, to set bit 3 only, set uxBitsToSet to 0x08.  To set bit 3\n and bit 0 set uxBitsToSet to 0x09.\n\n @return The value of the event group at the time the call to\n xEventGroupSetBits() returns.  There are two reasons why the returned value\n might have the bits specified by the uxBitsToSet parameter cleared.  First,\n if setting a bit results in a task that was waiting for the bit leaving the\n blocked state then it is possible the bit will be cleared automatically\n (see the xClearBitOnExit parameter of xEventGroupWaitBits()).  Second, any\n unblocked (or otherwise Ready state) task that has a priority above that of\n the task that called xEventGroupSetBits() will execute and may change the\n event group value before the call to xEventGroupSetBits() returns.\n\n Example usage:\n @code{c}\n #define BIT_0 ( 1 << 0 )\n #define BIT_4 ( 1 << 4 )\n\n void aFunction( EventGroupHandle_t xEventGroup )\n {\n EventBits_t uxBits;\n\n      // Set bit 0 and bit 4 in xEventGroup.\n      uxBits = xEventGroupSetBits(\n                          xEventGroup,    // The event group being updated.\n                          BIT_0 | BIT_4 );// The bits being set.\n\n      if( ( uxBits & ( BIT_0 | BIT_4 ) ) == ( BIT_0 | BIT_4 ) )\n      {\n          // Both bit 0 and bit 4 remained set when the function returned.\n      }\n      else if( ( uxBits & BIT_0 ) != 0 )\n      {\n          // Bit 0 remained set when the function returned, but bit 4 was\n          // cleared.  It might be that bit 4 was cleared automatically as a\n          // task that was waiting for bit 4 was removed from the Blocked\n          // state.\n      }\n      else if( ( uxBits & BIT_4 ) != 0 )\n      {\n          // Bit 4 remained set when the function returned, but bit 0 was\n          // cleared.  It might be that bit 0 was cleared automatically as a\n          // task that was waiting for bit 0 was removed from the Blocked\n          // state.\n      }\n      else\n      {\n          // Neither bit 0 nor bit 4 remained set.  It might be that a task\n          // was waiting for both of the bits to be set, and the bits were\n          // cleared as the task left the Blocked state.\n      }\n }\n @endcode\n \\ingroup EventGroup"]
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    #[doc = " Atomically set bits within an event group, then wait for a combination of\n bits to be set within the same event group.  This functionality is typically\n used to synchronise multiple tasks, where each task has to wait for the other\n tasks to reach a synchronisation point before proceeding.\n\n This function cannot be used from an interrupt.\n\n The function will return before its block time expires if the bits specified\n by the uxBitsToWait parameter are set, or become set within that time.  In\n this case all the bits specified by uxBitsToWait will be automatically\n cleared before the function returns.\n\n @param xEventGroup The event group in which the bits are being tested.  The\n event group must have previously been created using a call to\n xEventGroupCreate().\n\n @param uxBitsToSet The bits to set in the event group before determining\n if, and possibly waiting for, all the bits specified by the uxBitsToWait\n parameter are set.\n\n @param uxBitsToWaitFor A bitwise value that indicates the bit or bits to test\n inside the event group.  For example, to wait for bit 0 and bit 2 set\n uxBitsToWaitFor to 0x05.  To wait for bits 0 and bit 1 and bit 2 set\n uxBitsToWaitFor to 0x07.  Etc.\n\n @param xTicksToWait The maximum amount of time (specified in 'ticks') to wait\n for all of the bits specified by uxBitsToWaitFor to become set.\n\n @return The value of the event group at the time either the bits being waited\n for became set, or the block time expired.  Test the return value to know\n which bits were set.  If xEventGroupSync() returned because its timeout\n expired then not all the bits being waited for will be set.  If\n xEventGroupSync() returned because all the bits it was waiting for were\n set then the returned value is the event group value before any bits were\n automatically cleared.\n\n Example usage:\n @code{c}\n // Bits used by the three tasks.\n #define TASK_0_BIT     ( 1 << 0 )\n #define TASK_1_BIT     ( 1 << 1 )\n #define TASK_2_BIT     ( 1 << 2 )\n\n #define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )\n\n // Use an event group to synchronise three tasks.  It is assumed this event\n // group has already been created elsewhere.\n EventGroupHandle_t xEventBits;\n\n void vTask0( void *pvParameters )\n {\n EventBits_t uxReturn;\n TickType_t xTicksToWait = 100 / portTICK_PERIOD_MS;\n\n   for( ;; )\n   {\n      // Perform task functionality here.\n\n      // Set bit 0 in the event flag to note this task has reached the\n      // sync point.  The other two tasks will set the other two bits defined\n      // by ALL_SYNC_BITS.  All three tasks have reached the synchronisation\n      // point when all the ALL_SYNC_BITS are set.  Wait a maximum of 100ms\n      // for this to happen.\n      uxReturn = xEventGroupSync( xEventBits, TASK_0_BIT, ALL_SYNC_BITS, xTicksToWait );\n\n      if( ( uxReturn & ALL_SYNC_BITS ) == ALL_SYNC_BITS )\n      {\n          // All three tasks reached the synchronisation point before the call\n          // to xEventGroupSync() timed out.\n      }\n  }\n }\n\n void vTask1( void *pvParameters )\n {\n   for( ;; )\n   {\n      // Perform task functionality here.\n\n      // Set bit 1 in the event flag to note this task has reached the\n      // synchronisation point.  The other two tasks will set the other two\n      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the\n      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait\n      // indefinitely for this to happen.\n      xEventGroupSync( xEventBits, TASK_1_BIT, ALL_SYNC_BITS, portMAX_DELAY );\n\n      // xEventGroupSync() was called with an indefinite block time, so\n      // this task will only reach here if the synchronisation was made by all\n      // three tasks, so there is no need to test the return value.\n   }\n }\n\n void vTask2( void *pvParameters )\n {\n   for( ;; )\n   {\n      // Perform task functionality here.\n\n      // Set bit 2 in the event flag to note this task has reached the\n      // synchronisation point.  The other two tasks will set the other two\n      // bits defined by ALL_SYNC_BITS.  All three tasks have reached the\n      // synchronisation point when all the ALL_SYNC_BITS are set.  Wait\n      // indefinitely for this to happen.\n      xEventGroupSync( xEventBits, TASK_2_BIT, ALL_SYNC_BITS, portMAX_DELAY );\n\n      // xEventGroupSync() was called with an indefinite block time, so\n      // this task will only reach here if the synchronisation was made by all\n      // three tasks, so there is no need to test the return value.\n  }\n }\n\n @endcode\n \\ingroup EventGroup"]
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
unsafe extern "C" {
    #[doc = " A version of xEventGroupGetBits() that can be called from an ISR.\n\n @param xEventGroup The event group being queried.\n\n @return The event group bits at the time xEventGroupGetBitsFromISR() was called.\n\n \\ingroup EventGroup"]
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
unsafe extern "C" {
    #[doc = " Delete an event group that was previously created by a call to\n xEventGroupCreate().  Tasks that are blocked on the event group will be\n unblocked and obtain 0 as the event group's value.\n\n @param xEventGroup The event group being deleted."]
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
unsafe extern "C" {
    pub fn xEventGroupGetStaticBuffer(
        xEventGroup: EventGroupHandle_t,
        ppxEventGroupBuffer: *mut *mut StaticEventGroup_t,
    ) -> BaseType_t;
}
unsafe extern "C" {
    #[doc = " @cond !DOC_EXCLUDE_HEADER_SECTION"]
    pub fn vEventGroupSetBitsCallback(pvEventGroup: *mut ::std::os::raw::c_void, ulBitsToSet: u32);
}
unsafe extern "C" {
    pub fn vEventGroupClearBitsCallback(
        pvEventGroup: *mut ::std::os::raw::c_void,
        ulBitsToClear: u32,
    );
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = ::std::os::raw::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 8usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
unsafe extern "C" {
    pub fn select(
        __n: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __n: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::std::os::raw::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub stackaddr: *mut ::std::os::raw::c_void,
    pub stacksize: ::std::os::raw::c_int,
    pub contentionscope: ::std::os::raw::c_int,
    pub inheritsched: ::std::os::raw::c_int,
    pub schedpolicy: ::std::os::raw::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 40usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::is_initialized"]
        [::std::mem::offset_of!(pthread_attr_t, is_initialized) - 0usize];
    ["Offset of field: pthread_attr_t::stackaddr"]
        [::std::mem::offset_of!(pthread_attr_t, stackaddr) - 8usize];
    ["Offset of field: pthread_attr_t::stacksize"]
        [::std::mem::offset_of!(pthread_attr_t, stacksize) - 16usize];
    ["Offset of field: pthread_attr_t::contentionscope"]
        [::std::mem::offset_of!(pthread_attr_t, contentionscope) - 20usize];
    ["Offset of field: pthread_attr_t::inheritsched"]
        [::std::mem::offset_of!(pthread_attr_t, inheritsched) - 24usize];
    ["Offset of field: pthread_attr_t::schedpolicy"]
        [::std::mem::offset_of!(pthread_attr_t, schedpolicy) - 28usize];
    ["Offset of field: pthread_attr_t::schedparam"]
        [::std::mem::offset_of!(pthread_attr_t, schedparam) - 32usize];
    ["Offset of field: pthread_attr_t::detachstate"]
        [::std::mem::offset_of!(pthread_attr_t, detachstate) - 36usize];
};
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub recursive: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 12usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::is_initialized"]
        [::std::mem::offset_of!(pthread_mutexattr_t, is_initialized) - 0usize];
    ["Offset of field: pthread_mutexattr_t::type_"]
        [::std::mem::offset_of!(pthread_mutexattr_t, type_) - 4usize];
    ["Offset of field: pthread_mutexattr_t::recursive"]
        [::std::mem::offset_of!(pthread_mutexattr_t, recursive) - 8usize];
};
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub clock: clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 16usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 8usize];
    ["Offset of field: pthread_condattr_t::is_initialized"]
        [::std::mem::offset_of!(pthread_condattr_t, is_initialized) - 0usize];
    ["Offset of field: pthread_condattr_t::clock"]
        [::std::mem::offset_of!(pthread_condattr_t, clock) - 8usize];
};
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub init_executed: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_once_t"][::std::mem::size_of::<pthread_once_t>() - 8usize];
    ["Alignment of pthread_once_t"][::std::mem::align_of::<pthread_once_t>() - 4usize];
    ["Offset of field: pthread_once_t::is_initialized"]
        [::std::mem::offset_of!(pthread_once_t, is_initialized) - 0usize];
    ["Offset of field: pthread_once_t::init_executed"]
        [::std::mem::offset_of!(pthread_once_t, init_executed) - 4usize];
};
pub type pthread_rwlock_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr_t {
    pub is_initialized: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 4usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 4usize];
    ["Offset of field: pthread_rwlockattr_t::is_initialized"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, is_initialized) - 0usize];
};
unsafe extern "C" {
    pub static mut environ: *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn access(
        __path: *const ::std::os::raw::c_char,
        __amode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alarm(__secs: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chmod(__path: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn close(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn daemon(
        nochdir: ::std::os::raw::c_int,
        noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup2(
        __fildes: ::std::os::raw::c_int,
        __fildes2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn endusershell();
}
unsafe extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlpe(
        __file: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faccessat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchdir(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmod(__fildes: ::std::os::raw::c_int, __mode: mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchown(
        __fildes: ::std::os::raw::c_int,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchownat(
        __dirfd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fork() -> pid_t;
}
unsafe extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdatasync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getentropy(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getegid() -> gid_t;
}
unsafe extern "C" {
    pub fn geteuid() -> uid_t;
}
unsafe extern "C" {
    pub fn getgid() -> gid_t;
}
unsafe extern "C" {
    pub fn getgroups(
        __gidsetsize: ::std::os::raw::c_int,
        __grouplist: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
unsafe extern "C" {
    pub fn getpgrp() -> pid_t;
}
unsafe extern "C" {
    pub fn getpid() -> pid_t;
}
unsafe extern "C" {
    pub fn getppid() -> pid_t;
}
unsafe extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
unsafe extern "C" {
    pub fn getuid() -> uid_t;
}
unsafe extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn iruserok(
        raddr: ::std::os::raw::c_ulong,
        superuser: ::std::os::raw::c_int,
        ruser: *const ::std::os::raw::c_char,
        luser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isatty(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchown(
        __path: *const ::std::os::raw::c_char,
        __owner: uid_t,
        __group: gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn link(
        __path1: *const ::std::os::raw::c_char,
        __path2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkat(
        __dirfd1: ::std::os::raw::c_int,
        __path1: *const ::std::os::raw::c_char,
        __dirfd2: ::std::os::raw::c_int,
        __path2: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nice(__nice_value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lseek(
        __fildes: ::std::os::raw::c_int,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> off_t;
}
unsafe extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pipe(__fildes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn revoke(__path: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ruserok(
        rhost: *const ::std::os::raw::c_char,
        superuser: ::std::os::raw::c_int,
        ruser: *const ::std::os::raw::c_char,
        luser: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sbrk(__incr: isize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn setegid(__gid: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seteuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgid(__gid: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgroups(
        ngroups: ::std::os::raw::c_int,
        grouplist: *const gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostname(arg1: *const ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgid(__pid: pid_t, __pgid: pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setregid(__rgid: gid_t, __egid: gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setreuid(__ruid: uid_t, __euid: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsid() -> pid_t;
}
unsafe extern "C" {
    pub fn setuid(__uid: uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setusershell();
}
unsafe extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn tcgetpgrp(__fildes: ::std::os::raw::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn tcsetpgrp(__fildes: ::std::os::raw::c_int, __pgrp_id: pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyname(__fildes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlink(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn usleep(__useconds: useconds_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, __length: off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ualarm(__useconds: useconds_t, __interval: useconds_t) -> useconds_t;
}
unsafe extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setdtablesize(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sync();
}
unsafe extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlink(
        __name1: *const ::std::os::raw::c_char,
        __name2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkat(
        __dirfd1: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 36usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 4usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
};
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn strftime(
        _s: *mut ::std::os::raw::c_char,
        _maxsize: usize,
        _fmt: *const ::std::os::raw::c_char,
        _t: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        _s: *mut ::std::os::raw::c_char,
        _maxsize: usize,
        _fmt: *const ::std::os::raw::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
unsafe extern "C" {
    pub static mut _timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut _daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut _tzname: [*mut ::std::os::raw::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 32usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 4usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 8usize];
    ["Offset of field: sigevent::sigev_notify_function"]
        [::std::mem::offset_of!(sigevent, sigev_notify_function) - 16usize];
    ["Offset of field: sigevent::sigev_notify_attributes"]
        [::std::mem::offset_of!(sigevent, sigev_notify_attributes) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_value: sigval,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t"][::std::mem::size_of::<siginfo_t>() - 16usize];
    ["Alignment of siginfo_t"][::std::mem::align_of::<siginfo_t>() - 8usize];
    ["Offset of field: siginfo_t::si_signo"][::std::mem::offset_of!(siginfo_t, si_signo) - 0usize];
    ["Offset of field: siginfo_t::si_code"][::std::mem::offset_of!(siginfo_t, si_code) - 4usize];
    ["Offset of field: siginfo_t::si_value"][::std::mem::offset_of!(siginfo_t, si_value) - 8usize];
};
pub type _sig_func_ptr = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 24usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::sa_handler"]
        [::std::mem::offset_of!(sigaction, sa_handler) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"][::std::mem::offset_of!(sigaction, sa_flags) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaltstack"][::std::mem::size_of::<sigaltstack>() - 24usize];
    ["Alignment of sigaltstack"][::std::mem::align_of::<sigaltstack>() - 8usize];
    ["Offset of field: sigaltstack::ss_sp"][::std::mem::offset_of!(sigaltstack, ss_sp) - 0usize];
    ["Offset of field: sigaltstack::ss_flags"]
        [::std::mem::offset_of!(sigaltstack, ss_flags) - 8usize];
    ["Offset of field: sigaltstack::ss_size"]
        [::std::mem::offset_of!(sigaltstack, ss_size) - 16usize];
};
pub type stack_t = sigaltstack;
unsafe extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigqueue(
        arg1: pid_t,
        arg2: ::std::os::raw::c_int,
        arg3: sigval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sig2str(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn str2sig(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type sig_t = _sig_func_ptr;
unsafe extern "C" {
    pub fn _signal_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: _sig_func_ptr,
    ) -> _sig_func_ptr;
}
unsafe extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn signal(arg1: ::std::os::raw::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
unsafe extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::std::os::raw::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        clock_id: clockid_t,
        flags: ::std::os::raw::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_context {
    pub _routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub _arg: *mut ::std::os::raw::c_void,
    pub _canceltype: ::std::os::raw::c_int,
    pub _previous: *mut _pthread_cleanup_context,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_context"]
        [::std::mem::size_of::<_pthread_cleanup_context>() - 32usize];
    ["Alignment of _pthread_cleanup_context"]
        [::std::mem::align_of::<_pthread_cleanup_context>() - 8usize];
    ["Offset of field: _pthread_cleanup_context::_routine"]
        [::std::mem::offset_of!(_pthread_cleanup_context, _routine) - 0usize];
    ["Offset of field: _pthread_cleanup_context::_arg"]
        [::std::mem::offset_of!(_pthread_cleanup_context, _arg) - 8usize];
    ["Offset of field: _pthread_cleanup_context::_canceltype"]
        [::std::mem::offset_of!(_pthread_cleanup_context, _canceltype) - 16usize];
    ["Offset of field: _pthread_cleanup_context::_previous"]
        [::std::mem::offset_of!(_pthread_cleanup_context, _previous) - 24usize];
};
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __attr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__mutex: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_create(
        __pthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_join(
        __pthread: pthread_t,
        __value_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__pthread: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__value_ptr: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__t1: pthread_t, __t2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        thread: pthread_t,
        clock_id: *mut clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setconcurrency(new_level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_yield();
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destructor: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__pthread: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
unsafe extern "C" {
    pub fn _pthread_cleanup_push(
        _context: *mut _pthread_cleanup_context,
        _routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        _arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn _pthread_cleanup_pop(
        _context: *mut _pthread_cleanup_context,
        _execute: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_task_attr_t {
    pub name: *const ::std::os::raw::c_char,
    pub priority: UBaseType_t,
    pub stack_depth: usize,
    pub static_allocation: bool,
    pub stack_buffer: *mut StackType_t,
    pub task_buffer: *mut StaticTask_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_task_attr_t"][::std::mem::size_of::<z_task_attr_t>() - 48usize];
    ["Alignment of z_task_attr_t"][::std::mem::align_of::<z_task_attr_t>() - 8usize];
    ["Offset of field: z_task_attr_t::name"][::std::mem::offset_of!(z_task_attr_t, name) - 0usize];
    ["Offset of field: z_task_attr_t::priority"]
        [::std::mem::offset_of!(z_task_attr_t, priority) - 8usize];
    ["Offset of field: z_task_attr_t::stack_depth"]
        [::std::mem::offset_of!(z_task_attr_t, stack_depth) - 16usize];
    ["Offset of field: z_task_attr_t::static_allocation"]
        [::std::mem::offset_of!(z_task_attr_t, static_allocation) - 24usize];
    ["Offset of field: z_task_attr_t::stack_buffer"]
        [::std::mem::offset_of!(z_task_attr_t, stack_buffer) - 32usize];
    ["Offset of field: z_task_attr_t::task_buffer"]
        [::std::mem::offset_of!(z_task_attr_t, task_buffer) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_task_t {
    pub handle: TaskHandle_t,
    pub join_event: EventGroupHandle_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_task_t"][::std::mem::size_of::<_z_task_t>() - 16usize];
    ["Alignment of _z_task_t"][::std::mem::align_of::<_z_task_t>() - 8usize];
    ["Offset of field: _z_task_t::handle"][::std::mem::offset_of!(_z_task_t, handle) - 0usize];
    ["Offset of field: _z_task_t::join_event"]
        [::std::mem::offset_of!(_z_task_t, join_event) - 8usize];
};
pub type _z_mutex_t = pthread_mutex_t;
pub type _z_mutex_rec_t = pthread_mutex_t;
pub type _z_condvar_t = pthread_cond_t;
pub type z_clock_t = timespec;
pub type z_time_t = timeval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_sys_net_socket_t {
    pub __bindgen_anon_1: _z_sys_net_socket_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_sys_net_socket_t__bindgen_ty_1 {
    pub _fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_socket_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_sys_net_socket_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _z_sys_net_socket_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_sys_net_socket_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _z_sys_net_socket_t__bindgen_ty_1::_fd"]
        [::std::mem::offset_of!(_z_sys_net_socket_t__bindgen_ty_1, _fd) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_socket_t"][::std::mem::size_of::<_z_sys_net_socket_t>() - 4usize];
    ["Alignment of _z_sys_net_socket_t"][::std::mem::align_of::<_z_sys_net_socket_t>() - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_sys_net_endpoint_t {
    pub __bindgen_anon_1: _z_sys_net_endpoint_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_sys_net_endpoint_t__bindgen_ty_1 {
    pub _iptcp: *mut addrinfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_endpoint_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_sys_net_endpoint_t__bindgen_ty_1>() - 8usize];
    ["Alignment of _z_sys_net_endpoint_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_sys_net_endpoint_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_sys_net_endpoint_t__bindgen_ty_1::_iptcp"]
        [::std::mem::offset_of!(_z_sys_net_endpoint_t__bindgen_ty_1, _iptcp) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_endpoint_t"][::std::mem::size_of::<_z_sys_net_endpoint_t>() - 8usize];
    ["Alignment of _z_sys_net_endpoint_t"]
        [::std::mem::align_of::<_z_sys_net_endpoint_t>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Generates a random unsigned 8-bit integer."]
    pub fn z_random_u8() -> u8;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 16-bit integer."]
    pub fn z_random_u16() -> u16;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 32-bit integer."]
    pub fn z_random_u32() -> u32;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 64-bit integer."]
    pub fn z_random_u64() -> u64;
}
unsafe extern "C" {
    #[doc = " Fills buffer with random data.\n\n Parameters:\n   buf: Pointer to the buffer that will be filled with random data.\n   len: Number of bytes to fill in the buffer."]
    pub fn z_random_fill(buf: *mut ::std::os::raw::c_void, len: usize);
}
unsafe extern "C" {
    #[doc = " Allocates memory of the specified size.\n\n Parameters:\n   size: The number of bytes to allocate.\n\n Returns:\n   A pointer to the allocated memory, or NULL if the allocation fails."]
    pub fn z_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Reallocates the given memory block to a new size.\n\n Parameters:\n   ptr: Pointer to the previously allocated memory. Can be NULL, in which case it behaves like z_malloc().\n   size: The new size for the memory block in bytes.\n\n Returns:\n   A pointer to the reallocated memory, or NULL if the reallocation fails."]
    pub fn z_realloc(ptr: *mut ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Frees the memory previously allocated by z_malloc or z_realloc.\n\n Parameters:\n   ptr: Pointer to the memory to be freed. If NULL, no action is taken."]
    pub fn z_free(ptr: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_task_t {
    pub _val: _z_task_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_task_t"][::std::mem::size_of::<z_owned_task_t>() - 16usize];
    ["Alignment of z_owned_task_t"][::std::mem::align_of::<z_owned_task_t>() - 8usize];
    ["Offset of field: z_owned_task_t::_val"]
        [::std::mem::offset_of!(z_owned_task_t, _val) - 0usize];
};
pub type z_loaned_task_t = _z_task_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_task_t {
    pub _this: z_owned_task_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_task_t"][::std::mem::size_of::<z_moved_task_t>() - 16usize];
    ["Alignment of z_moved_task_t"][::std::mem::align_of::<z_moved_task_t>() - 8usize];
    ["Offset of field: z_moved_task_t::_this"]
        [::std::mem::offset_of!(z_moved_task_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_task_null(obj: *mut z_owned_task_t);
}
unsafe extern "C" {
    pub fn z_task_take(obj: *mut z_owned_task_t, src: *mut z_moved_task_t);
}
unsafe extern "C" {
    pub fn z_task_loan(obj: *const z_owned_task_t) -> *const z_loaned_task_t;
}
unsafe extern "C" {
    pub fn z_task_loan_mut(obj: *mut z_owned_task_t) -> *mut z_loaned_task_t;
}
unsafe extern "C" {
    pub fn z_task_move(obj: *mut z_owned_task_t) -> *mut z_moved_task_t;
}
unsafe extern "C" {
    pub fn _z_task_init(
        task: *mut _z_task_t,
        attr: *mut z_task_attr_t,
        fun: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_join(task: *mut _z_task_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_detach(task: *mut _z_task_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_cancel(task: *mut _z_task_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_exit();
}
unsafe extern "C" {
    pub fn _z_task_free(task: *mut *mut _z_task_t);
}
unsafe extern "C" {
    #[doc = " Constructs a new task.\n\n Parameters:\n   task: An uninitialized memory location where task will be constructed.\n   attr: Attributes of the task.\n   fun: Function to be executed by the task.\n   arg: Argument that will be passed to the function `fun`.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_init(
        task: *mut z_owned_task_t,
        attr: *mut z_task_attr_t,
        fun: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Joins the task and releases all allocated resources.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be joined.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_join(task: *mut z_moved_task_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Detaches the task and releases all allocated resources.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be detached.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_detach(task: *mut z_moved_task_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Drops the task. Same as :c:func:`z_task_detach`. Use :c:func:`z_task_join` to wait for the task completion.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be dropped.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_drop(task: *mut z_moved_task_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_mutex_t {
    pub _val: _z_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_mutex_t"][::std::mem::size_of::<z_owned_mutex_t>() - 4usize];
    ["Alignment of z_owned_mutex_t"][::std::mem::align_of::<z_owned_mutex_t>() - 4usize];
    ["Offset of field: z_owned_mutex_t::_val"]
        [::std::mem::offset_of!(z_owned_mutex_t, _val) - 0usize];
};
pub type z_loaned_mutex_t = _z_mutex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_mutex_t {
    pub _this: z_owned_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_mutex_t"][::std::mem::size_of::<z_moved_mutex_t>() - 4usize];
    ["Alignment of z_moved_mutex_t"][::std::mem::align_of::<z_moved_mutex_t>() - 4usize];
    ["Offset of field: z_moved_mutex_t::_this"]
        [::std::mem::offset_of!(z_moved_mutex_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_mutex_null(obj: *mut z_owned_mutex_t);
}
unsafe extern "C" {
    pub fn z_mutex_take(obj: *mut z_owned_mutex_t, src: *mut z_moved_mutex_t);
}
unsafe extern "C" {
    pub fn z_mutex_loan(obj: *const z_owned_mutex_t) -> *const z_loaned_mutex_t;
}
unsafe extern "C" {
    pub fn z_mutex_loan_mut(obj: *mut z_owned_mutex_t) -> *mut z_loaned_mutex_t;
}
unsafe extern "C" {
    pub fn z_mutex_move(obj: *mut z_owned_mutex_t) -> *mut z_moved_mutex_t;
}
unsafe extern "C" {
    pub fn _z_mutex_init(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_drop(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_lock(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_try_lock(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_unlock(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_init(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_drop(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_lock(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_try_lock(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_unlock(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs a mutex.\n\n Parameters:\n   m: Pointer to an uninitialized :c:type:`z_owned_mutex_t` that will be constructed.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_init(m: *mut z_owned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Drops a mutex and resets it to its gravestone state.\n\n Parameters:\n   m: Pointer to a :c:type:`z_moved_mutex_t` that will be dropped.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_drop(m: *mut z_moved_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Locks a mutex. If the mutex is already locked, blocks the thread until it acquires the lock.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be locked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_lock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Tries to lock a mutex. If the mutex is already locked, the function returns immediately.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be locked if not already locked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_try_lock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Unlocks a previously locked mutex. If the mutex was not locked by the current thread, the behavior is undefined.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_unlock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_condvar_t {
    pub _val: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_condvar_t"][::std::mem::size_of::<z_owned_condvar_t>() - 4usize];
    ["Alignment of z_owned_condvar_t"][::std::mem::align_of::<z_owned_condvar_t>() - 4usize];
    ["Offset of field: z_owned_condvar_t::_val"]
        [::std::mem::offset_of!(z_owned_condvar_t, _val) - 0usize];
};
pub type z_loaned_condvar_t = _z_condvar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_condvar_t {
    pub _this: z_owned_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_condvar_t"][::std::mem::size_of::<z_moved_condvar_t>() - 4usize];
    ["Alignment of z_moved_condvar_t"][::std::mem::align_of::<z_moved_condvar_t>() - 4usize];
    ["Offset of field: z_moved_condvar_t::_this"]
        [::std::mem::offset_of!(z_moved_condvar_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_condvar_null(obj: *mut z_owned_condvar_t);
}
unsafe extern "C" {
    pub fn z_condvar_take(obj: *mut z_owned_condvar_t, src: *mut z_moved_condvar_t);
}
unsafe extern "C" {
    pub fn z_condvar_loan(obj: *const z_owned_condvar_t) -> *const z_loaned_condvar_t;
}
unsafe extern "C" {
    pub fn z_condvar_loan_mut(obj: *mut z_owned_condvar_t) -> *mut z_loaned_condvar_t;
}
unsafe extern "C" {
    pub fn z_condvar_move(obj: *mut z_owned_condvar_t) -> *mut z_moved_condvar_t;
}
unsafe extern "C" {
    pub fn _z_condvar_init(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_drop(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_signal(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_signal_all(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_wait(cv: *mut _z_condvar_t, m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_wait_until(
        cv: *mut _z_condvar_t,
        m: *mut _z_mutex_t,
        abstime: *const z_clock_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Initializes a condition variable.\n\n Parameters:\n   cv: Pointer to an uninitialized :c:type:`z_owned_condvar_t` that will be initialized.\n\n Returns:\n   ``0`` if the initialization is successful, a negative value otherwise."]
    pub fn z_condvar_init(cv: *mut z_owned_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Destroys a condition variable and releases its resources.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_moved_condvar_t` that will be destroyed.\n\n Returns:\n   ``0`` if the destruction is successful, a negative value otherwise."]
    pub fn z_condvar_drop(cv: *mut z_moved_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Signals (wakes up) one thread waiting on the condition variable.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` that will be signaled.\n\n Returns:\n   ``0`` if the signal is successful, a negative value otherwise."]
    pub fn z_condvar_signal(cv: *mut z_loaned_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Waits for a signal on the condition variable while holding a mutex.\n\n The calling thread is blocked until the condition variable is signaled.\n The associated mutex must be locked by the calling thread, and it will be automatically unlocked while waiting.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` on which to wait.\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked during the wait.\n\n Returns:\n   ``0`` if the wait is successful, a negative value otherwise."]
    pub fn z_condvar_wait(cv: *mut z_loaned_condvar_t, m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Waits for a signal on the condition variable while holding a mutex until a specified time.\n\n The calling thread is blocked until the condition variable is signaled or the timeout occurs.\n The associated mutex must be locked by the calling thread, and it will be automatically unlocked while waiting.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` on which to wait.\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked during the wait.\n   abstime: Absolute end time.\n\n Returns:\n   ``0`` if the wait is successful, ``Z_ETIMEDOUT`` if a timeout occurred, other negative value otherwise."]
    pub fn z_condvar_wait_until(
        cv: *mut z_loaned_condvar_t,
        m: *mut z_loaned_mutex_t,
        abstime: *const z_clock_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in microseconds.\n\n Parameters:\n   time: The amount of time to sleep, in microseconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_us(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in milliseconds.\n\n Parameters:\n   time: The amount of time to sleep, in milliseconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_ms(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in seconds.\n\n Parameters:\n   time: The amount of time to sleep, in seconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_s(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns monotonic clock time point corresponding to the current time instant."]
    pub fn z_clock_now() -> z_clock_t;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in microseconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in microseconds."]
    pub fn z_clock_elapsed_us(time: *mut z_clock_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in milliseconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in milliseconds."]
    pub fn z_clock_elapsed_ms(time: *mut z_clock_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in seconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in seconds."]
    pub fn z_clock_elapsed_s(time: *mut z_clock_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in microseconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in microseconds."]
    pub fn z_clock_advance_us(clock: *mut z_clock_t, duration: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in milliseconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in milliseconds."]
    pub fn z_clock_advance_ms(clock: *mut z_clock_t, duration: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in seconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in seconds."]
    pub fn z_clock_advance_s(clock: *mut z_clock_t, duration: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    #[doc = " Returns system clock time point corresponding to the current time instant."]
    pub fn z_time_now() -> z_time_t;
}
unsafe extern "C" {
    #[doc = " Gets the current time as a string.\n\n Parameters:\n   buf: Pointer to a buffer where the time string will be written.\n   buflen: The length of the buffer.\n\n Returns:\n   A pointer to the buffer containing the time string."]
    pub fn z_time_now_as_str(
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_ulong,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in microseconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in microseconds."]
    pub fn z_time_elapsed_us(time: *mut z_time_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in milliseconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in milliseconds."]
    pub fn z_time_elapsed_ms(time: *mut z_time_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in seconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in seconds."]
    pub fn z_time_elapsed_s(time: *mut z_time_t) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_time_since_epoch {
    pub secs: u32,
    pub nanos: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_time_since_epoch"][::std::mem::size_of::<_z_time_since_epoch>() - 8usize];
    ["Alignment of _z_time_since_epoch"][::std::mem::align_of::<_z_time_since_epoch>() - 4usize];
    ["Offset of field: _z_time_since_epoch::secs"]
        [::std::mem::offset_of!(_z_time_since_epoch, secs) - 0usize];
    ["Offset of field: _z_time_since_epoch::nanos"]
        [::std::mem::offset_of!(_z_time_since_epoch, nanos) - 4usize];
};
unsafe extern "C" {
    pub fn _z_get_time_since_epoch(t: *mut _z_time_since_epoch) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_socket_set_non_blocking(sock: *const _z_sys_net_socket_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_socket_accept(
        sock_in: *const _z_sys_net_socket_t,
        sock_out: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_socket_close(sock: *mut _z_sys_net_socket_t);
}
unsafe extern "C" {
    pub fn _z_socket_wait_event(
        peers: *mut ::std::os::raw::c_void,
        mutex: *mut _z_mutex_rec_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_init(cnt: *mut *mut ::std::os::raw::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_increase_strong(cnt: *mut ::std::os::raw::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_increase_weak(cnt: *mut ::std::os::raw::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_decrease_strong(cnt: *mut *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    pub fn _z_rc_decrease_weak(cnt: *mut *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    pub fn _z_rc_weak_upgrade(cnt: *mut ::std::os::raw::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_weak_count(cnt: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    pub fn _z_rc_strong_count(cnt: *mut ::std::os::raw::c_void) -> usize;
}
unsafe extern "C" {
    pub fn _z_simple_rc_value(rc: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_simple_rc_init(
        rc: *mut *mut ::std::os::raw::c_void,
        val: *const ::std::os::raw::c_void,
        val_size: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_simple_rc_increase(rc: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _z_simple_rc_decrease(rc: *mut ::std::os::raw::c_void) -> bool;
}
unsafe extern "C" {
    pub fn _z_simple_rc_strong_count(rc: *mut ::std::os::raw::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_delete_context_t {
    pub deleter: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    pub context: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_delete_context_t"][::std::mem::size_of::<_z_delete_context_t>() - 16usize];
    ["Alignment of _z_delete_context_t"][::std::mem::align_of::<_z_delete_context_t>() - 8usize];
    ["Offset of field: _z_delete_context_t::deleter"]
        [::std::mem::offset_of!(_z_delete_context_t, deleter) - 0usize];
    ["Offset of field: _z_delete_context_t::context"]
        [::std::mem::offset_of!(_z_delete_context_t, context) - 8usize];
};
unsafe extern "C" {
    pub fn _z_delete_context_default() -> _z_delete_context_t;
}
unsafe extern "C" {
    pub fn _z_delete_context_static() -> _z_delete_context_t;
}
#[doc = " An array of bytes.\n\n Members:\n   size_t len: The length of the bytes array.\n   uint8_t *start: A pointer to the bytes array.\n   _z_delete_context_t delete_context - context used to delete the data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_slice_t {
    pub len: usize,
    pub start: *const u8,
    pub _delete_context: _z_delete_context_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_slice_t"][::std::mem::size_of::<_z_slice_t>() - 32usize];
    ["Alignment of _z_slice_t"][::std::mem::align_of::<_z_slice_t>() - 8usize];
    ["Offset of field: _z_slice_t::len"][::std::mem::offset_of!(_z_slice_t, len) - 0usize];
    ["Offset of field: _z_slice_t::start"][::std::mem::offset_of!(_z_slice_t, start) - 8usize];
    ["Offset of field: _z_slice_t::_delete_context"]
        [::std::mem::offset_of!(_z_slice_t, _delete_context) - 16usize];
};
unsafe extern "C" {
    pub fn _z_slice_init(bs: *mut _z_slice_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_make(capacity: usize) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_copy_from_buf(bs: *const u8, len: usize) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_steal(b: *mut _z_slice_t) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_copy(dst: *mut _z_slice_t, src: *const _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_n_copy(
        dst: *mut _z_slice_t,
        src: *const _z_slice_t,
        offset: usize,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_duplicate(src: *const _z_slice_t) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_move(dst: *mut _z_slice_t, src: *mut _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_eq(left: *const _z_slice_t, right: *const _z_slice_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_slice_free(bs: *mut *mut _z_slice_t);
}
unsafe extern "C" {
    pub fn _z_slice_is_alloced(s: *const _z_slice_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_slice_simple_rc_t {
    pub _val: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_slice_simple_rc_t"][::std::mem::size_of::<_z_slice_simple_rc_t>() - 8usize];
    ["Alignment of _z_slice_simple_rc_t"][::std::mem::align_of::<_z_slice_simple_rc_t>() - 8usize];
    ["Offset of field: _z_slice_simple_rc_t::_val"]
        [::std::mem::offset_of!(_z_slice_simple_rc_t, _val) - 0usize];
};
#[doc = " An atomically reference counted subslice.\n\n Members:\n   _z_slice_simple_rc_t len: Rc counted slice.\n   size_t start: Offset to the subslice start.\n   size_t len: Length of the subslice."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_arc_slice_t {
    pub slice: _z_slice_simple_rc_t,
    pub start: usize,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_arc_slice_t"][::std::mem::size_of::<_z_arc_slice_t>() - 24usize];
    ["Alignment of _z_arc_slice_t"][::std::mem::align_of::<_z_arc_slice_t>() - 8usize];
    ["Offset of field: _z_arc_slice_t::slice"]
        [::std::mem::offset_of!(_z_arc_slice_t, slice) - 0usize];
    ["Offset of field: _z_arc_slice_t::start"]
        [::std::mem::offset_of!(_z_arc_slice_t, start) - 8usize];
    ["Offset of field: _z_arc_slice_t::len"][::std::mem::offset_of!(_z_arc_slice_t, len) - 16usize];
};
unsafe extern "C" {
    pub fn _z_arc_slice_wrap(s: *mut _z_slice_t, offset: usize, len: usize) -> _z_arc_slice_t;
}
unsafe extern "C" {
    pub fn _z_arc_slice_get_subslice(
        s: *const _z_arc_slice_t,
        offset: usize,
        len: usize,
    ) -> _z_arc_slice_t;
}
unsafe extern "C" {
    pub fn _z_arc_slice_copy(dst: *mut _z_arc_slice_t, src: *const _z_arc_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_arc_slice_move(dst: *mut _z_arc_slice_t, src: *mut _z_arc_slice_t) -> z_result_t;
}
pub type z_element_size_f =
    ::std::option::Option<unsafe extern "C" fn(e: *mut ::std::os::raw::c_void) -> usize>;
pub type z_element_clear_f =
    ::std::option::Option<unsafe extern "C" fn(e: *mut ::std::os::raw::c_void)>;
pub type z_element_free_f =
    ::std::option::Option<unsafe extern "C" fn(e: *mut *mut ::std::os::raw::c_void)>;
pub type z_element_copy_f = ::std::option::Option<
    unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, src: *const ::std::os::raw::c_void),
>;
pub type z_element_move_f = ::std::option::Option<
    unsafe extern "C" fn(dst: *mut ::std::os::raw::c_void, src: *mut ::std::os::raw::c_void),
>;
pub type z_element_clone_f = ::std::option::Option<
    unsafe extern "C" fn(e: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type z_element_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const ::std::os::raw::c_void,
        right: *const ::std::os::raw::c_void,
    ) -> bool,
>;
pub type z_element_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const ::std::os::raw::c_void,
        right: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type z_element_hash_f =
    ::std::option::Option<unsafe extern "C" fn(e: *const ::std::os::raw::c_void) -> usize>;
pub type _z_noop_t = ::std::os::raw::c_void;
pub type _z_noop_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_noop_t, right: *const _z_noop_t) -> bool,
>;
pub type _z_noop_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_noop_t, right: *const _z_noop_t) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored as pointers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_vec_t {
    pub _capacity: usize,
    pub _len: usize,
    pub _val: *mut *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_vec_t"][::std::mem::size_of::<_z_vec_t>() - 24usize];
    ["Alignment of _z_vec_t"][::std::mem::align_of::<_z_vec_t>() - 8usize];
    ["Offset of field: _z_vec_t::_capacity"][::std::mem::offset_of!(_z_vec_t, _capacity) - 0usize];
    ["Offset of field: _z_vec_t::_len"][::std::mem::offset_of!(_z_vec_t, _len) - 8usize];
    ["Offset of field: _z_vec_t::_val"][::std::mem::offset_of!(_z_vec_t, _val) - 16usize];
};
unsafe extern "C" {
    pub fn _z_vec_make(capacity: usize) -> _z_vec_t;
}
unsafe extern "C" {
    pub fn _z_vec_copy(dst: *mut _z_vec_t, src: *const _z_vec_t, f: z_element_clone_f);
}
unsafe extern "C" {
    pub fn _z_vec_move(dst: *mut _z_vec_t, src: *mut _z_vec_t);
}
unsafe extern "C" {
    pub fn _z_vec_append(v: *mut _z_vec_t, e: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn _z_vec_set(
        sv: *mut _z_vec_t,
        pos: usize,
        e: *mut ::std::os::raw::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_vec_remove(sv: *mut _z_vec_t, pos: usize, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_reset(v: *mut _z_vec_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_clear(v: *mut _z_vec_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_free(v: *mut *mut _z_vec_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_release(v: *mut _z_vec_t);
}
#[doc = " A dynamically allocated vector. Elements are stored by value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_svec_t {
    pub _capacity: usize,
    pub _len: usize,
    pub _val: *mut ::std::os::raw::c_void,
    pub _aliased: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_svec_t"][::std::mem::size_of::<_z_svec_t>() - 32usize];
    ["Alignment of _z_svec_t"][::std::mem::align_of::<_z_svec_t>() - 8usize];
    ["Offset of field: _z_svec_t::_capacity"]
        [::std::mem::offset_of!(_z_svec_t, _capacity) - 0usize];
    ["Offset of field: _z_svec_t::_len"][::std::mem::offset_of!(_z_svec_t, _len) - 8usize];
    ["Offset of field: _z_svec_t::_val"][::std::mem::offset_of!(_z_svec_t, _val) - 16usize];
    ["Offset of field: _z_svec_t::_aliased"][::std::mem::offset_of!(_z_svec_t, _aliased) - 24usize];
};
unsafe extern "C" {
    pub fn _z_svec_init(v: *mut _z_svec_t, offset: usize, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_make(capacity: usize, element_size: usize) -> _z_svec_t;
}
unsafe extern "C" {
    pub fn _z_svec_copy(
        dst: *mut _z_svec_t,
        src: *const _z_svec_t,
        copy: z_element_copy_f,
        element_size: usize,
        use_elem_f: bool,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_svec_move(dst: *mut _z_svec_t, src: *mut _z_svec_t);
}
unsafe extern "C" {
    pub fn _z_svec_expand(
        v: *mut _z_svec_t,
        move_: z_element_move_f,
        element_size: usize,
        use_elem_f: bool,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_svec_append(
        v: *mut _z_svec_t,
        e: *const ::std::os::raw::c_void,
        m: z_element_move_f,
        element_size: usize,
        use_elem_f: bool,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_svec_set(
        sv: *mut _z_svec_t,
        pos: usize,
        e: *mut ::std::os::raw::c_void,
        f: z_element_clear_f,
        element_size: usize,
    );
}
unsafe extern "C" {
    pub fn _z_svec_remove(
        sv: *mut _z_svec_t,
        pos: usize,
        f: z_element_clear_f,
        m: z_element_move_f,
        element_size: usize,
        use_elem_f: bool,
    );
}
unsafe extern "C" {
    pub fn _z_svec_reset(v: *mut _z_svec_t, f: z_element_clear_f, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_clear(v: *mut _z_svec_t, f: z_element_clear_f, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_free(v: *mut *mut _z_svec_t, f: z_element_clear_f, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_release(v: *mut _z_svec_t);
}
unsafe extern "C" {
    #[doc = " Offsets a ``uint8_t`` pointer by a given distance. Offsets can be both positive and negative values.\n\n Parameters:\n   ptr: The pointer to offset.\n   off: The offset distance to be applied.\n\n Returns:\n   Returns a ``const uint8_t`` pointer, pointing to the offset position."]
    pub fn _z_cptr_u8_offset(ptr: *const u8, off: isize) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Offsets a ``char`` pointer by a given distance. Offsets can be both positive and negative values.\n\n Parameters:\n   ptr: The pointer to offset.\n   off: The offset distance to be applied.\n\n Returns:\n   Returns a ``const char`` pointer, pointing to the offset position."]
    pub fn _z_cptr_char_offset(
        ptr: *const ::std::os::raw::c_char,
        off: isize,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_iosli_t {
    pub _r_pos: usize,
    pub _w_pos: usize,
    pub _capacity: usize,
    pub _buf: *mut u8,
    pub _is_alloc: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_iosli_t"][::std::mem::size_of::<_z_iosli_t>() - 40usize];
    ["Alignment of _z_iosli_t"][::std::mem::align_of::<_z_iosli_t>() - 8usize];
    ["Offset of field: _z_iosli_t::_r_pos"][::std::mem::offset_of!(_z_iosli_t, _r_pos) - 0usize];
    ["Offset of field: _z_iosli_t::_w_pos"][::std::mem::offset_of!(_z_iosli_t, _w_pos) - 8usize];
    ["Offset of field: _z_iosli_t::_capacity"]
        [::std::mem::offset_of!(_z_iosli_t, _capacity) - 16usize];
    ["Offset of field: _z_iosli_t::_buf"][::std::mem::offset_of!(_z_iosli_t, _buf) - 24usize];
    ["Offset of field: _z_iosli_t::_is_alloc"]
        [::std::mem::offset_of!(_z_iosli_t, _is_alloc) - 32usize];
};
unsafe extern "C" {
    pub fn _z_iosli_make(capacity: usize) -> _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_new(capacity: usize) -> *mut _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_wrap(buf: *const u8, length: usize, r_pos: usize, w_pos: usize) -> _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_steal(ios: *mut _z_iosli_t) -> _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_to_bytes(ios: *const _z_iosli_t) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_iosli_clear(ios: *mut _z_iosli_t);
}
unsafe extern "C" {
    pub fn _z_iosli_free(ios: *mut *mut _z_iosli_t);
}
unsafe extern "C" {
    pub fn _z_iosli_copy(dst: *mut _z_iosli_t, src: *const _z_iosli_t);
}
unsafe extern "C" {
    pub fn _z_iosli_clone(src: *const _z_iosli_t) -> *mut _z_iosli_t;
}
pub type _z_iosli_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_iosli_t, right: *const _z_iosli_t) -> bool,
>;
pub type _z_iosli_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_iosli_t,
        right: *const _z_iosli_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_iosli_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_zbuf_t {
    pub _ios: _z_iosli_t,
    pub _slice: _z_slice_simple_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_zbuf_t"][::std::mem::size_of::<_z_zbuf_t>() - 48usize];
    ["Alignment of _z_zbuf_t"][::std::mem::align_of::<_z_zbuf_t>() - 8usize];
    ["Offset of field: _z_zbuf_t::_ios"][::std::mem::offset_of!(_z_zbuf_t, _ios) - 0usize];
    ["Offset of field: _z_zbuf_t::_slice"][::std::mem::offset_of!(_z_zbuf_t, _slice) - 40usize];
};
unsafe extern "C" {
    pub fn _z_zbuf_make(capacity: usize) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_zbuf_view(zbf: *mut _z_zbuf_t, length: usize) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_slice_as_zbuf(slice: _z_slice_t) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_zbuf_copy_bytes(dst: *mut _z_zbuf_t, src: *const _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_copy(dst: *mut _z_zbuf_t, src: *const _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_read_bytes(zbf: *mut _z_zbuf_t, dest: *mut u8, offset: usize, length: usize);
}
unsafe extern "C" {
    pub fn _z_zbuf_compact(zbf: *mut _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_clear(zbf: *mut _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_free(zbf: *mut *mut _z_zbuf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_wbuf_t {
    pub _ioss: _z_iosli_svec_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
    pub _expansion_step: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_wbuf_t"][::std::mem::size_of::<_z_wbuf_t>() - 56usize];
    ["Alignment of _z_wbuf_t"][::std::mem::align_of::<_z_wbuf_t>() - 8usize];
    ["Offset of field: _z_wbuf_t::_ioss"][::std::mem::offset_of!(_z_wbuf_t, _ioss) - 0usize];
    ["Offset of field: _z_wbuf_t::_r_idx"][::std::mem::offset_of!(_z_wbuf_t, _r_idx) - 32usize];
    ["Offset of field: _z_wbuf_t::_w_idx"][::std::mem::offset_of!(_z_wbuf_t, _w_idx) - 40usize];
    ["Offset of field: _z_wbuf_t::_expansion_step"]
        [::std::mem::offset_of!(_z_wbuf_t, _expansion_step) - 48usize];
};
unsafe extern "C" {
    pub fn _z_wbuf_make(capacity: usize, is_expandable: bool) -> _z_wbuf_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_capacity(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_len(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_space_left(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_write(wbf: *mut _z_wbuf_t, b: u8) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_write_bytes(
        wbf: *mut _z_wbuf_t,
        bs: *const u8,
        offset: usize,
        length: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_wrap_bytes(
        wbf: *mut _z_wbuf_t,
        bs: *const u8,
        offset: usize,
        length: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_put(wbf: *mut _z_wbuf_t, b: u8, pos: usize);
}
unsafe extern "C" {
    pub fn _z_wbuf_get_rpos(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_get_wpos(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_set_rpos(wbf: *mut _z_wbuf_t, r_pos: usize);
}
unsafe extern "C" {
    pub fn _z_wbuf_set_wpos(wbf: *mut _z_wbuf_t, w_pos: usize);
}
unsafe extern "C" {
    pub fn _z_wbuf_len_iosli(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_to_zbuf(wbf: *const _z_wbuf_t) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_moved_as_zbuf(wbf: *mut _z_wbuf_t) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_siphon(dst: *mut _z_wbuf_t, src: *mut _z_wbuf_t, length: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_copy(dst: *mut _z_wbuf_t, src: *const _z_wbuf_t);
}
unsafe extern "C" {
    pub fn _z_wbuf_reset(wbf: *mut _z_wbuf_t);
}
unsafe extern "C" {
    pub fn _z_wbuf_clear(wbf: *mut _z_wbuf_t);
}
unsafe extern "C" {
    pub fn _z_wbuf_free(wbf: *mut *mut _z_wbuf_t);
}
pub type _z_arc_slice_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_arc_slice_t, right: *const _z_arc_slice_t) -> bool,
>;
pub type _z_arc_slice_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_arc_slice_t,
        right: *const _z_arc_slice_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_arc_slice_svec_t = _z_svec_t;
#[doc = " A container for slices.\n\n Members:\n   _z_slice_vec_t _slices: contents of the container."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_t {
    pub _slices: _z_arc_slice_svec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_t"][::std::mem::size_of::<_z_bytes_t>() - 32usize];
    ["Alignment of _z_bytes_t"][::std::mem::align_of::<_z_bytes_t>() - 8usize];
    ["Offset of field: _z_bytes_t::_slices"][::std::mem::offset_of!(_z_bytes_t, _slices) - 0usize];
};
unsafe extern "C" {
    pub fn _z_bytes_check(bytes: *const _z_bytes_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_append_bytes(dst: *mut _z_bytes_t, src: *mut _z_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_append_slice(dst: *mut _z_bytes_t, s: *mut _z_arc_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_copy(dst: *mut _z_bytes_t, src: *const _z_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_duplicate(src: *const _z_bytes_t) -> _z_bytes_t;
}
unsafe extern "C" {
    pub fn _z_bytes_move(dst: *mut _z_bytes_t, src: *mut _z_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_free(bs: *mut *mut _z_bytes_t);
}
unsafe extern "C" {
    pub fn _z_bytes_len(bs: *const _z_bytes_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_bytes_is_empty(bs: *const _z_bytes_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_to_slice(bytes: *const _z_bytes_t, s: *mut _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_from_slice(b: *mut _z_bytes_t, s: *mut _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_to_buf(bytes: *const _z_bytes_t, dst: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_bytes_from_buf(b: *mut _z_bytes_t, src: *const u8, len: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_try_get_contiguous(bs: *const _z_bytes_t) -> _z_slice_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_reader_t {
    pub slice_idx: usize,
    pub in_slice_idx: usize,
    pub byte_idx: usize,
    pub bytes: *const _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_reader_t"][::std::mem::size_of::<_z_bytes_reader_t>() - 32usize];
    ["Alignment of _z_bytes_reader_t"][::std::mem::align_of::<_z_bytes_reader_t>() - 8usize];
    ["Offset of field: _z_bytes_reader_t::slice_idx"]
        [::std::mem::offset_of!(_z_bytes_reader_t, slice_idx) - 0usize];
    ["Offset of field: _z_bytes_reader_t::in_slice_idx"]
        [::std::mem::offset_of!(_z_bytes_reader_t, in_slice_idx) - 8usize];
    ["Offset of field: _z_bytes_reader_t::byte_idx"]
        [::std::mem::offset_of!(_z_bytes_reader_t, byte_idx) - 16usize];
    ["Offset of field: _z_bytes_reader_t::bytes"]
        [::std::mem::offset_of!(_z_bytes_reader_t, bytes) - 24usize];
};
unsafe extern "C" {
    pub fn _z_bytes_get_reader(bytes: *const _z_bytes_t) -> _z_bytes_reader_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_seek(
        reader: *mut _z_bytes_reader_t,
        offset: i64,
        origin: ::std::os::raw::c_int,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_tell(reader: *const _z_bytes_reader_t) -> i64;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_read_slices(
        reader: *mut _z_bytes_reader_t,
        len: usize,
        out: *mut _z_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_read(reader: *mut _z_bytes_reader_t, buf: *mut u8, len: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_writer_t {
    pub cache: *mut _z_arc_slice_t,
    pub bytes: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_writer_t"][::std::mem::size_of::<_z_bytes_writer_t>() - 40usize];
    ["Alignment of _z_bytes_writer_t"][::std::mem::align_of::<_z_bytes_writer_t>() - 8usize];
    ["Offset of field: _z_bytes_writer_t::cache"]
        [::std::mem::offset_of!(_z_bytes_writer_t, cache) - 0usize];
    ["Offset of field: _z_bytes_writer_t::bytes"]
        [::std::mem::offset_of!(_z_bytes_writer_t, bytes) - 8usize];
};
unsafe extern "C" {
    pub fn _z_bytes_writer_is_empty(writer: *const _z_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_check(writer: *const _z_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_from_bytes(bytes: *mut _z_bytes_t) -> _z_bytes_writer_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_empty() -> _z_bytes_writer_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_write_all(
        writer: *mut _z_bytes_writer_t,
        src: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_append_z_bytes(
        writer: *mut _z_bytes_writer_t,
        bytes: *mut _z_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_append_slice(
        writer: *mut _z_bytes_writer_t,
        bytes: *mut _z_arc_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_finish(writer: *mut _z_bytes_writer_t) -> _z_bytes_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_clear(writer: *mut _z_bytes_writer_t);
}
unsafe extern "C" {
    pub fn _z_bytes_writer_move(
        dst: *mut _z_bytes_writer_t,
        src: *mut _z_bytes_writer_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_remaining(reader: *const _z_bytes_reader_t) -> usize;
}
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_l_t {
    pub _val: *mut ::std::os::raw::c_void,
    pub _next: *mut _z_l_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_l_t"][::std::mem::size_of::<_z_l_t>() - 16usize];
    ["Alignment of _z_l_t"][::std::mem::align_of::<_z_l_t>() - 8usize];
    ["Offset of field: _z_l_t::_val"][::std::mem::offset_of!(_z_l_t, _val) - 0usize];
    ["Offset of field: _z_l_t::_next"][::std::mem::offset_of!(_z_l_t, _next) - 8usize];
};
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_list_t = _z_l_t;
unsafe extern "C" {
    pub fn _z_list_len(xs: *const _z_list_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_list_push(xs: *mut _z_list_t, x: *mut ::std::os::raw::c_void) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_push_after(xs: *mut _z_list_t, x: *mut ::std::os::raw::c_void)
        -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_push_back(xs: *mut _z_list_t, x: *mut ::std::os::raw::c_void) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_push_sorted(
        xs: *mut _z_list_t,
        c_f: z_element_cmp_f,
        x: *mut ::std::os::raw::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_pop(
        xs: *mut _z_list_t,
        f_f: z_element_free_f,
        x: *mut *mut ::std::os::raw::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_find(
        xs: *const _z_list_t,
        f_f: z_element_eq_f,
        e: *const ::std::os::raw::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_drop_element(
        list: *mut _z_list_t,
        prev: *mut _z_list_t,
        f_f: z_element_free_f,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_drop_filter(
        xs: *mut _z_list_t,
        f_f: z_element_free_f,
        c_f: z_element_eq_f,
        left: *const ::std::os::raw::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_clone(xs: *const _z_list_t, d_f: z_element_clone_f) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_free(xs: *mut *mut _z_list_t, f_f: z_element_free_f);
}
pub type _z_slist_t = ::std::os::raw::c_void;
unsafe extern "C" {
    pub fn _z_slist_push_empty(node: *mut _z_slist_t, value_size: usize) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_push(
        node: *mut _z_slist_t,
        value: *const ::std::os::raw::c_void,
        value_size: usize,
        d_f: z_element_copy_f,
        use_elem_f: bool,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_push_back(
        node: *mut _z_slist_t,
        value: *const ::std::os::raw::c_void,
        value_size: usize,
        d_f: z_element_copy_f,
        use_elem_f: bool,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_value(node: *const _z_slist_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_slist_next(node: *const _z_slist_t) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_len(node: *const _z_slist_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_slist_pop(node: *mut _z_slist_t, f_f: z_element_clear_f) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_find(
        node: *const _z_slist_t,
        c_f: z_element_eq_f,
        target_val: *const ::std::os::raw::c_void,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_drop_element(
        list: *mut _z_slist_t,
        prev: *mut _z_slist_t,
        f_f: z_element_clear_f,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_drop_filter(
        head: *mut _z_slist_t,
        f_f: z_element_clear_f,
        c_f: z_element_eq_f,
        target_val: *const ::std::os::raw::c_void,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_clone(
        node: *const _z_slist_t,
        value_size: usize,
        d_f: z_element_copy_f,
        use_elem_f: bool,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_free(node: *mut *mut _z_slist_t, f: z_element_clear_f);
}
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_entry_t {
    pub _key: *mut ::std::os::raw::c_void,
    pub _val: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_entry_t"][::std::mem::size_of::<_z_hashmap_entry_t>() - 16usize];
    ["Alignment of _z_hashmap_entry_t"][::std::mem::align_of::<_z_hashmap_entry_t>() - 8usize];
    ["Offset of field: _z_hashmap_entry_t::_key"]
        [::std::mem::offset_of!(_z_hashmap_entry_t, _key) - 0usize];
    ["Offset of field: _z_hashmap_entry_t::_val"]
        [::std::mem::offset_of!(_z_hashmap_entry_t, _val) - 8usize];
};
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_t {
    pub _capacity: usize,
    pub _vals: *mut *mut _z_list_t,
    pub _f_hash: z_element_hash_f,
    pub _f_equals: z_element_eq_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_t"][::std::mem::size_of::<_z_hashmap_t>() - 32usize];
    ["Alignment of _z_hashmap_t"][::std::mem::align_of::<_z_hashmap_t>() - 8usize];
    ["Offset of field: _z_hashmap_t::_capacity"]
        [::std::mem::offset_of!(_z_hashmap_t, _capacity) - 0usize];
    ["Offset of field: _z_hashmap_t::_vals"][::std::mem::offset_of!(_z_hashmap_t, _vals) - 8usize];
    ["Offset of field: _z_hashmap_t::_f_hash"]
        [::std::mem::offset_of!(_z_hashmap_t, _f_hash) - 16usize];
    ["Offset of field: _z_hashmap_t::_f_equals"]
        [::std::mem::offset_of!(_z_hashmap_t, _f_equals) - 24usize];
};
#[doc = " Iterator for a generic key-value hashmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_iterator_t {
    pub _entry: *mut _z_hashmap_entry_t,
    pub _map: *const _z_hashmap_t,
    pub _idx: usize,
    pub _list_ptr: *mut _z_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_iterator_t"][::std::mem::size_of::<_z_hashmap_iterator_t>() - 32usize];
    ["Alignment of _z_hashmap_iterator_t"]
        [::std::mem::align_of::<_z_hashmap_iterator_t>() - 8usize];
    ["Offset of field: _z_hashmap_iterator_t::_entry"]
        [::std::mem::offset_of!(_z_hashmap_iterator_t, _entry) - 0usize];
    ["Offset of field: _z_hashmap_iterator_t::_map"]
        [::std::mem::offset_of!(_z_hashmap_iterator_t, _map) - 8usize];
    ["Offset of field: _z_hashmap_iterator_t::_idx"]
        [::std::mem::offset_of!(_z_hashmap_iterator_t, _idx) - 16usize];
    ["Offset of field: _z_hashmap_iterator_t::_list_ptr"]
        [::std::mem::offset_of!(_z_hashmap_iterator_t, _list_ptr) - 24usize];
};
unsafe extern "C" {
    pub fn _z_hashmap_init(
        map: *mut _z_hashmap_t,
        capacity: usize,
        f_hash: z_element_hash_f,
        f_equals: z_element_eq_f,
    );
}
unsafe extern "C" {
    pub fn _z_hashmap_make(
        capacity: usize,
        f_hash: z_element_hash_f,
        f_equals: z_element_eq_f,
    ) -> _z_hashmap_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_insert(
        map: *mut _z_hashmap_t,
        key: *mut ::std::os::raw::c_void,
        val: *mut ::std::os::raw::c_void,
        f: z_element_free_f,
        replace: bool,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_hashmap_get(
        map: *const _z_hashmap_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_hashmap_get_all(
        map: *const _z_hashmap_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_remove(
        map: *mut _z_hashmap_t,
        key: *const ::std::os::raw::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_hashmap_capacity(map: *const _z_hashmap_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_hashmap_len(map: *const _z_hashmap_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_hashmap_is_empty(map: *const _z_hashmap_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_hashmap_copy(
        dst: *mut _z_hashmap_t,
        src: *const _z_hashmap_t,
        f_c: z_element_clone_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_clone(
        src: *const _z_hashmap_t,
        f_c: z_element_clone_f,
        f_f: z_element_free_f,
    ) -> _z_hashmap_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_clear(map: *mut _z_hashmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_hashmap_free(map: *mut *mut _z_hashmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_make(map: *const _z_hashmap_t) -> _z_hashmap_iterator_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_next(iter: *mut _z_hashmap_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_key(
        iter: *const _z_hashmap_iterator_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_value(
        iter: *const _z_hashmap_iterator_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_int_void_map_t = _z_hashmap_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_int_void_map_entry_t = _z_hashmap_entry_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_int_void_map_iterator_t = _z_hashmap_iterator_t;
pub type _z_str_t = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn _z_str_clone(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_str_n_clone(
        src: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_str_clear(src: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _z_str_free(src: *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _z_str_eq(
        left: *const ::std::os::raw::c_char,
        right: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_str_cmp(
        left: *const ::std::os::raw::c_char,
        right: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_str_size(src: *const ::std::os::raw::c_char) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_copy(dst: *mut ::std::os::raw::c_char, src: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _z_str_n_copy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        size: usize,
    );
}
pub type _z_str_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const ::std::os::raw::c_char,
        right: *const ::std::os::raw::c_char,
    ) -> bool,
>;
pub type _z_str_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const ::std::os::raw::c_char,
        right: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored as pointers."]
pub type _z_str_vec_t = _z_vec_t;
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_str_list_t = _z_list_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_str_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_str_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_str_intmap_iterator_t = _z_int_void_map_iterator_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_str_intmapping_t {
    pub _str: *mut ::std::os::raw::c_char,
    pub _key: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_str_intmapping_t"][::std::mem::size_of::<_z_str_intmapping_t>() - 16usize];
    ["Alignment of _z_str_intmapping_t"][::std::mem::align_of::<_z_str_intmapping_t>() - 8usize];
    ["Offset of field: _z_str_intmapping_t::_str"]
        [::std::mem::offset_of!(_z_str_intmapping_t, _str) - 0usize];
    ["Offset of field: _z_str_intmapping_t::_key"]
        [::std::mem::offset_of!(_z_str_intmapping_t, _key) - 8usize];
};
unsafe extern "C" {
    pub fn _z_str_intmap_strlen(
        s: *const _z_str_intmap_t,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_intmap_onto_str(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        s: *const _z_str_intmap_t,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    );
}
unsafe extern "C" {
    pub fn _z_str_intmap_to_str(
        s: *const _z_str_intmap_t,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_str_intmap_from_str(
        strint: *mut _z_str_intmap_t,
        s: *const ::std::os::raw::c_char,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_str_intmap_from_strn(
        strint: *mut _z_str_intmap_t,
        s: *const ::std::os::raw::c_char,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
        n: usize,
    ) -> z_result_t;
}
#[doc = " A string with no terminator.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_string_t {
    pub _slice: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_string_t"][::std::mem::size_of::<_z_string_t>() - 32usize];
    ["Alignment of _z_string_t"][::std::mem::align_of::<_z_string_t>() - 8usize];
    ["Offset of field: _z_string_t::_slice"][::std::mem::offset_of!(_z_string_t, _slice) - 0usize];
};
unsafe extern "C" {
    pub fn _z_string_copy_from_str(value: *const ::std::os::raw::c_char) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_copy_from_substr(
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_copy_from_str_as_ptr(value: *const ::std::os::raw::c_char)
        -> *mut _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_rchr(
        str_: *mut _z_string_t,
        filter: ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_string_pbrk(
        str_: *mut _z_string_t,
        filter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_string_copy(dst: *mut _z_string_t, src: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_string_copy_substring(
        dst: *mut _z_string_t,
        src: *const _z_string_t,
        offset: usize,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_string_move(dst: *mut _z_string_t, src: *mut _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_string_steal(str_: *mut _z_string_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_move_str(dst: *mut _z_string_t, src: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn _z_string_free(s: *mut *mut _z_string_t);
}
unsafe extern "C" {
    pub fn _z_string_compare(
        left: *const _z_string_t,
        right: *const _z_string_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_string_equals(left: *const _z_string_t, right: *const _z_string_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_string_convert_bytes_le(bs: *const _z_slice_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_preallocate(len: usize) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_str_from_string_clone(str_: *const _z_string_t) -> *mut ::std::os::raw::c_char;
}
pub type _z_string_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_string_t, right: *const _z_string_t) -> bool,
>;
pub type _z_string_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_string_t,
        right: *const _z_string_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_string_svec_t = _z_svec_t;
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_string_list_t = _z_list_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_string_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_string_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_string_intmap_iterator_t = _z_int_void_map_iterator_t;
pub const z_what_t_Z_WHAT_ROUTER: z_what_t = 1;
pub const z_what_t_Z_WHAT_PEER: z_what_t = 2;
pub const z_what_t_Z_WHAT_CLIENT: z_what_t = 4;
pub const z_what_t_Z_WHAT_ROUTER_PEER: z_what_t = 3;
pub const z_what_t_Z_WHAT_ROUTER_CLIENT: z_what_t = 5;
pub const z_what_t_Z_WHAT_PEER_CLIENT: z_what_t = 6;
pub const z_what_t_Z_WHAT_ROUTER_PEER_CLIENT: z_what_t = 7;
#[doc = " What bitmask for scouting.\n\n Enumerators:\n   Z_WHAT_ROUTER: Router.\n   Z_WHAT_PEER: Peer.\n   Z_WHAT_CLIENT: Client."]
pub type z_what_t = ::std::os::raw::c_uint;
pub const z_whatami_t_Z_WHATAMI_ROUTER: z_whatami_t = 1;
pub const z_whatami_t_Z_WHATAMI_PEER: z_whatami_t = 2;
pub const z_whatami_t_Z_WHATAMI_CLIENT: z_whatami_t = 4;
#[doc = " Whatami values, defined as a bitmask.\n\n Enumerators:\n   Z_WHATAMI_ROUTER: Bitmask to filter Zenoh routers.\n   Z_WHATAMI_PEER: Bitmask to filter for Zenoh peers.\n   Z_WHATAMI_CLIENT: Bitmask to filter for Zenoh clients."]
pub type z_whatami_t = ::std::os::raw::c_uint;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_SUCCESS: zp_keyexpr_canon_status_t = 0;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_LONE_DOLLAR_STAR: zp_keyexpr_canon_status_t =
    -1;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_SINGLE_STAR_AFTER_DOUBLE_STAR:
    zp_keyexpr_canon_status_t = -2;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_DOUBLE_STAR_AFTER_DOUBLE_STAR:
    zp_keyexpr_canon_status_t = -3;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_EMPTY_CHUNK: zp_keyexpr_canon_status_t = -4;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_STARS_IN_CHUNK: zp_keyexpr_canon_status_t = -5;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_DOLLAR_AFTER_DOLLAR_OR_STAR:
    zp_keyexpr_canon_status_t = -6;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_CONTAINS_SHARP_OR_QMARK:
    zp_keyexpr_canon_status_t = -7;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_CONTAINS_UNBOUND_DOLLAR:
    zp_keyexpr_canon_status_t = -8;
#[doc = " Status values for keyexpr canonization operation.\n Used as return value of canonization-related functions,\n like :c:func:`z_keyexpr_is_canon` or :c:func:`z_keyexpr_canonize`.\n\n Enumerators:\n   Z_KEYEXPR_CANON_SUCCESS: The key expression is canon.\n   Z_KEYEXPR_CANON_LONE_DOLLAR_STAR: The key contains a ``$*`` chunk, which must be replaced by ``*``.\n   Z_KEYEXPR_CANON_SINGLE_STAR_AFTER_DOUBLE_STAR: The key contains ``** / *``, which must be replaced by ``* / **``.\n   Z_KEYEXPR_CANON_DOUBLE_STAR_AFTER_DOUBLE_STAR: The key contains ``** / **``, which must be replaced by ``**``.\n   Z_KEYEXPR_CANON_EMPTY_CHUNK: The key contains empty chunks.\n   Z_KEYEXPR_CANON_STARS_IN_CHUNK: The key contains a ``*`` in a chunk without being escaped by a DSL, which is\n     forbidden.\n   Z_KEYEXPR_CANON_DOLLAR_AFTER_DOLLAR_OR_STAR: The key contains ``$*$`` or ``$$``, which is forbidden.\n   Z_KEYEXPR_CANON_CONTAINS_SHARP_OR_QMARK: The key contains ``#`` or ``?``, which is forbidden.\n   Z_KEYEXPR_CANON_CONTAINS_UNBOUND_DOLLAR: The key contains a ``$`` which is not bound to a DSL."]
pub type zp_keyexpr_canon_status_t = ::std::os::raw::c_int;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_DISJOINT:
    z_keyexpr_intersection_level_t = 0;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_INTERSECTS:
    z_keyexpr_intersection_level_t = 1;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_INCLUDES:
    z_keyexpr_intersection_level_t = 2;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_EQUALS:
    z_keyexpr_intersection_level_t = 3;
#[doc = " Intersection level of two key expressions.\n\n Enumerators:\n   Z_KEYEXPR_INTERSECTION_LEVEL_DISJOINT: The two key expressions do not intersect.\n   Z_KEYEXPR_INTERSECTION_LEVEL_INTERSECTS: The two key expressions intersect, i.e. there exists at least one key\n     expression that is included by both.\n   Z_KEYEXPR_INTERSECTION_LEVEL_INCLUDES: The first key expression is the superset of the second one.\n   Z_KEYEXPR_INTERSECTION_LEVEL_EQUALS: The two key expressions are equal."]
pub type z_keyexpr_intersection_level_t = ::std::os::raw::c_uint;
pub const z_sample_kind_t_Z_SAMPLE_KIND_PUT: z_sample_kind_t = 0;
pub const z_sample_kind_t_Z_SAMPLE_KIND_DELETE: z_sample_kind_t = 1;
#[doc = " Sample kind values.\n\n Enumerators:\n   Z_SAMPLE_KIND_PUT: The Sample was issued by a ``put`` operation.\n   Z_SAMPLE_KIND_DELETE: The Sample was issued by a ``delete`` operation."]
pub type z_sample_kind_t = ::std::os::raw::c_uint;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_AUTO: z_consolidation_mode_t = -1;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_NONE: z_consolidation_mode_t = 0;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_MONOTONIC: z_consolidation_mode_t = 1;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_LATEST: z_consolidation_mode_t = 2;
#[doc = " Consolidation mode values.\n\n Enumerators:\n   Z_CONSOLIDATION_MODE_AUTO: Let Zenoh decide the best consolidation mode depending on the query selector.\n   Z_CONSOLIDATION_MODE_NONE: No consolidation is applied. Replies may come in any order and any number.\n   Z_CONSOLIDATION_MODE_MONOTONIC: It guarantees that any reply for a given key expression will be monotonic in time\n     w.r.t. the previous received replies for the same key expression. I.e., for the same key expression multiple\n     replies may be received. It is guaranteed that two replies received at t1 and t2 will have timestamp\n     ts2 > ts1. It optimizes latency.\n   Z_CONSOLIDATION_MODE_LATEST: It guarantees unicity of replies for the same key expression.\n     It optimizes bandwidth."]
pub type z_consolidation_mode_t = ::std::os::raw::c_int;
pub const z_reliability_t_Z_RELIABILITY_BEST_EFFORT: z_reliability_t = 1;
pub const z_reliability_t_Z_RELIABILITY_RELIABLE: z_reliability_t = 0;
#[doc = " Reliability values.\n\n Enumerators:\n   Z_RELIABILITY_BEST_EFFORT: Defines reliability as ``BEST_EFFORT``\n   Z_RELIABILITY_RELIABLE: Defines reliability as ``RELIABLE``\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
pub type z_reliability_t = ::std::os::raw::c_uint;
pub const z_congestion_control_t_Z_CONGESTION_CONTROL_BLOCK: z_congestion_control_t = 1;
pub const z_congestion_control_t_Z_CONGESTION_CONTROL_DROP: z_congestion_control_t = 0;
#[doc = " Congestion control values.\n\n Enumerators:\n   Z_CONGESTION_CONTROL_BLOCK: Defines congestion control as ``BLOCK``. Messages are not dropped in case of\n     congestion control.\n   Z_CONGESTION_CONTROL_DROP: Defines congestion control as ``DROP``. Messages are dropped in case\n     of congestion control."]
pub type z_congestion_control_t = ::std::os::raw::c_uint;
pub const z_priority_t__Z_PRIORITY_CONTROL: z_priority_t = 0;
pub const z_priority_t_Z_PRIORITY_REAL_TIME: z_priority_t = 1;
pub const z_priority_t_Z_PRIORITY_INTERACTIVE_HIGH: z_priority_t = 2;
pub const z_priority_t_Z_PRIORITY_INTERACTIVE_LOW: z_priority_t = 3;
pub const z_priority_t_Z_PRIORITY_DATA_HIGH: z_priority_t = 4;
pub const z_priority_t_Z_PRIORITY_DATA: z_priority_t = 5;
pub const z_priority_t_Z_PRIORITY_DATA_LOW: z_priority_t = 6;
pub const z_priority_t_Z_PRIORITY_BACKGROUND: z_priority_t = 7;
#[doc = " Priority of Zenoh messages values.\n\n Enumerators:\n   _Z_PRIORITY_CONTROL: Priority for ``Control`` messages.\n   Z_PRIORITY_REAL_TIME: Priority for ``RealTime`` messages.\n   Z_PRIORITY_INTERACTIVE_HIGH: Highest priority for ``Interactive`` messages.\n   Z_PRIORITY_INTERACTIVE_LOW: Lowest priority for ``Interactive`` messages.\n   Z_PRIORITY_DATA_HIGH: Highest priority for ``Data`` messages.\n   Z_PRIORITY_DATA: Default priority for ``Data`` messages.\n   Z_PRIORITY_DATA_LOW: Lowest priority for ``Data`` messages.\n   Z_PRIORITY_BACKGROUND: Priority for ``Background traffic`` messages."]
pub type z_priority_t = ::std::os::raw::c_uint;
pub const z_query_target_t_Z_QUERY_TARGET_BEST_MATCHING: z_query_target_t = 0;
pub const z_query_target_t_Z_QUERY_TARGET_ALL: z_query_target_t = 1;
pub const z_query_target_t_Z_QUERY_TARGET_ALL_COMPLETE: z_query_target_t = 2;
#[doc = " Query target values.\n\n Enumerators:\n   Z_QUERY_TARGET_BEST_MATCHING: The nearest complete queryable if any else all matching queryables.\n   Z_QUERY_TARGET_ALL: All matching queryables.\n   Z_QUERY_TARGET_ALL_COMPLETE: A set of complete queryables."]
pub type z_query_target_t = ::std::os::raw::c_uint;
#[doc = " A zenoh encoding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_encoding_t {
    pub schema: _z_string_t,
    pub id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_encoding_t"][::std::mem::size_of::<_z_encoding_t>() - 40usize];
    ["Alignment of _z_encoding_t"][::std::mem::align_of::<_z_encoding_t>() - 8usize];
    ["Offset of field: _z_encoding_t::schema"]
        [::std::mem::offset_of!(_z_encoding_t, schema) - 0usize];
    ["Offset of field: _z_encoding_t::id"][::std::mem::offset_of!(_z_encoding_t, id) - 32usize];
};
unsafe extern "C" {
    pub fn _z_encoding_wrap(id: u16, schema: *const ::std::os::raw::c_char) -> _z_encoding_t;
}
unsafe extern "C" {
    pub fn _z_encoding_make(
        encoding: *mut _z_encoding_t,
        id: u16,
        schema: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_encoding_copy(dst: *mut _z_encoding_t, src: *const _z_encoding_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_encoding_move(dst: *mut _z_encoding_t, src: *mut _z_encoding_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_str_se_t {
    pub start: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_str_se_t"][::std::mem::size_of::<_z_str_se_t>() - 16usize];
    ["Alignment of _z_str_se_t"][::std::mem::align_of::<_z_str_se_t>() - 8usize];
    ["Offset of field: _z_str_se_t::start"][::std::mem::offset_of!(_z_str_se_t, start) - 0usize];
    ["Offset of field: _z_str_se_t::end"][::std::mem::offset_of!(_z_str_se_t, end) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_splitstr_t {
    pub s: _z_str_se_t,
    pub delimiter: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_splitstr_t"][::std::mem::size_of::<_z_splitstr_t>() - 24usize];
    ["Alignment of _z_splitstr_t"][::std::mem::align_of::<_z_splitstr_t>() - 8usize];
    ["Offset of field: _z_splitstr_t::s"][::std::mem::offset_of!(_z_splitstr_t, s) - 0usize];
    ["Offset of field: _z_splitstr_t::delimiter"]
        [::std::mem::offset_of!(_z_splitstr_t, delimiter) - 16usize];
};
unsafe extern "C" {
    #[doc = " Creates a `_z_str_se_t` from a null-terminated C string."]
    pub fn _z_bstrnew(start: *const ::std::os::raw::c_char) -> _z_str_se_t;
}
unsafe extern "C" {
    #[doc = " The reverse equivalent of libc's `strstr`.\n\n Returns NULL if the needle is not found.\n If found, the return pointer will point to the end of the last occurring\n needle within the haystack."]
    pub fn _z_rstrstr(
        haystack_start: *const ::std::os::raw::c_char,
        haystack_end: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " A non-null-terminated haystack equivalent of libc's `strstr`.\n\n Returns NULL if the needle is not found.\n If found, the return pointer will point to the start of the first occurrence\n of the needle within the haystack."]
    pub fn _z_strstr(
        haystack_start: *const ::std::os::raw::c_char,
        haystack_end: *const ::std::os::raw::c_char,
        needle_start: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_strstr_skipneedle(
        haystack_start: *const ::std::os::raw::c_char,
        haystack_end: *const ::std::os::raw::c_char,
        needle_start: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_bstrstr_skipneedle(
        haystack: _z_str_se_t,
        needle: _z_str_se_t,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_splitstr_is_empty(src: *const _z_splitstr_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_splitstr_next(str_: *mut _z_splitstr_t) -> _z_str_se_t;
}
unsafe extern "C" {
    pub fn _z_splitstr_split_once(src: _z_splitstr_t, next: *mut _z_str_se_t) -> _z_str_se_t;
}
unsafe extern "C" {
    pub fn _z_splitstr_nextback(str_: *mut _z_splitstr_t) -> _z_str_se_t;
}
unsafe extern "C" {
    pub fn _z_strcnt(
        haystack_start: *const ::std::os::raw::c_char,
        harstack_end: *const ::std::os::raw::c_char,
        needle_start: *const ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_startswith(
        s: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_se_atoui(str_: *const _z_str_se_t, result: *mut u32) -> bool;
}
#[doc = " A variable-length encoding unsigned integer."]
pub type _z_zint_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_id_t {
    pub id: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_id_t"][::std::mem::size_of::<_z_id_t>() - 16usize];
    ["Alignment of _z_id_t"][::std::mem::align_of::<_z_id_t>() - 1usize];
    ["Offset of field: _z_id_t::id"][::std::mem::offset_of!(_z_id_t, id) - 0usize];
};
unsafe extern "C" {
    pub static empty_id: _z_id_t;
}
unsafe extern "C" {
    pub fn _z_id_len(id: _z_id_t) -> u8;
}
unsafe extern "C" {
    pub fn _z_id_cmp(left: *const _z_id_t, right: *const _z_id_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_id_hash(id: *const _z_id_t) -> usize;
}
pub type _z_id_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_id_t, right: *const _z_id_t) -> bool,
>;
pub type _z_id_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_id_t, right: *const _z_id_t) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_entity_global_id_t {
    pub zid: _z_id_t,
    pub eid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_entity_global_id_t"][::std::mem::size_of::<_z_entity_global_id_t>() - 20usize];
    ["Alignment of _z_entity_global_id_t"]
        [::std::mem::align_of::<_z_entity_global_id_t>() - 4usize];
    ["Offset of field: _z_entity_global_id_t::zid"]
        [::std::mem::offset_of!(_z_entity_global_id_t, zid) - 0usize];
    ["Offset of field: _z_entity_global_id_t::eid"]
        [::std::mem::offset_of!(_z_entity_global_id_t, eid) - 16usize];
};
unsafe extern "C" {
    pub fn _z_entity_global_id_hash(id: *const _z_entity_global_id_t) -> usize;
}
pub type _z_entity_global_id_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_entity_global_id_t,
        right: *const _z_entity_global_id_t,
    ) -> bool,
>;
pub type _z_entity_global_id_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_entity_global_id_t,
        right: *const _z_entity_global_id_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " NTP64 time."]
pub type _z_ntp64_t = u64;
#[doc = " A zenoh timestamp."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_timestamp_t {
    pub valid: bool,
    pub id: _z_id_t,
    pub time: _z_ntp64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_timestamp_t"][::std::mem::size_of::<_z_timestamp_t>() - 32usize];
    ["Alignment of _z_timestamp_t"][::std::mem::align_of::<_z_timestamp_t>() - 8usize];
    ["Offset of field: _z_timestamp_t::valid"]
        [::std::mem::offset_of!(_z_timestamp_t, valid) - 0usize];
    ["Offset of field: _z_timestamp_t::id"][::std::mem::offset_of!(_z_timestamp_t, id) - 1usize];
    ["Offset of field: _z_timestamp_t::time"]
        [::std::mem::offset_of!(_z_timestamp_t, time) - 24usize];
};
unsafe extern "C" {
    pub fn _z_timestamp_copy(dst: *mut _z_timestamp_t, src: *const _z_timestamp_t);
}
unsafe extern "C" {
    pub fn _z_timestamp_duplicate(tstamp: *const _z_timestamp_t) -> _z_timestamp_t;
}
unsafe extern "C" {
    pub fn _z_timestamp_clear(tstamp: *mut _z_timestamp_t);
}
unsafe extern "C" {
    pub fn _z_timestamp_move(dst: *mut _z_timestamp_t, src: *mut _z_timestamp_t);
}
unsafe extern "C" {
    pub fn _z_timestamp_cmp(
        left: *const _z_timestamp_t,
        right: *const _z_timestamp_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_timestamp_ntp64_from_time(seconds: u32, nanos: u32) -> _z_ntp64_t;
}
pub type _z_timestamp_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_timestamp_t, right: *const _z_timestamp_t) -> bool,
>;
pub type _z_timestamp_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_timestamp_t,
        right: *const _z_timestamp_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_keyexpr_t {
    pub _id: u16,
    pub _mapping: usize,
    pub _suffix: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_keyexpr_t"][::std::mem::size_of::<_z_keyexpr_t>() - 48usize];
    ["Alignment of _z_keyexpr_t"][::std::mem::align_of::<_z_keyexpr_t>() - 8usize];
    ["Offset of field: _z_keyexpr_t::_id"][::std::mem::offset_of!(_z_keyexpr_t, _id) - 0usize];
    ["Offset of field: _z_keyexpr_t::_mapping"]
        [::std::mem::offset_of!(_z_keyexpr_t, _mapping) - 8usize];
    ["Offset of field: _z_keyexpr_t::_suffix"]
        [::std::mem::offset_of!(_z_keyexpr_t, _suffix) - 16usize];
};
unsafe extern "C" {
    #[doc = " Create a resource key from a resource name.\n\n Parameters:\n     rname: The resource name. The caller keeps its ownership.\n\n Returns:\n     A :c:type:`_z_keyexpr_t` containing a new resource key."]
    pub fn _z_rname(rname: *const ::std::os::raw::c_char) -> _z_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Create a resource key from a resource id and a suffix.\n\n Parameters:\n     id: The resource id.\n     suffix: The suffix.\n\n Returns:\n     A :c:type:`_z_keyexpr_t` containing a new resource key."]
    pub fn _z_rid_with_suffix(rid: u16, suffix: *const ::std::os::raw::c_char) -> _z_keyexpr_t;
}
unsafe extern "C" {
    pub fn _z_rid_with_substr_suffix(
        rid: u16,
        suffix: *const ::std::os::raw::c_char,
        suffix_len: usize,
    ) -> _z_keyexpr_t;
}
#[doc = " QoS settings of zenoh message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_qos_t {
    pub _val: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_qos_t"][::std::mem::size_of::<_z_qos_t>() - 1usize];
    ["Alignment of _z_qos_t"][::std::mem::align_of::<_z_qos_t>() - 1usize];
    ["Offset of field: _z_qos_t::_val"][::std::mem::offset_of!(_z_qos_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh value.\n\n Members:\n   _z_bytes_t payload: The payload of this zenoh value.\n   _z_encoding_t encoding: The encoding of the `payload`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_value_t {
    pub payload: _z_bytes_t,
    pub encoding: _z_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_value_t"][::std::mem::size_of::<_z_value_t>() - 72usize];
    ["Alignment of _z_value_t"][::std::mem::align_of::<_z_value_t>() - 8usize];
    ["Offset of field: _z_value_t::payload"][::std::mem::offset_of!(_z_value_t, payload) - 0usize];
    ["Offset of field: _z_value_t::encoding"]
        [::std::mem::offset_of!(_z_value_t, encoding) - 32usize];
};
unsafe extern "C" {
    pub fn _z_value_steal(value: *mut _z_value_t) -> _z_value_t;
}
unsafe extern "C" {
    pub fn _z_value_copy(dst: *mut _z_value_t, src: *const _z_value_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_value_move(dst: *mut _z_value_t, src: *mut _z_value_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_value_clear(src: *mut _z_value_t);
}
unsafe extern "C" {
    pub fn _z_value_free(hello: *mut *mut _z_value_t);
}
#[doc = " A hello message returned by a zenoh entity to a scout message sent with :c:func:`_z_scout`.\n\n Members:\n   _z_slice_t zid: The Zenoh ID of the scouted entity (empty if absent).\n   _z_string_vec_t locators: The locators of the scouted entity.\n   z_whatami_t whatami: The kind of zenoh entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hello_t {
    pub _zid: _z_id_t,
    pub _locators: _z_string_svec_t,
    pub _whatami: z_whatami_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hello_t"][::std::mem::size_of::<_z_hello_t>() - 56usize];
    ["Alignment of _z_hello_t"][::std::mem::align_of::<_z_hello_t>() - 8usize];
    ["Offset of field: _z_hello_t::_zid"][::std::mem::offset_of!(_z_hello_t, _zid) - 0usize];
    ["Offset of field: _z_hello_t::_locators"]
        [::std::mem::offset_of!(_z_hello_t, _locators) - 16usize];
    ["Offset of field: _z_hello_t::_whatami"]
        [::std::mem::offset_of!(_z_hello_t, _whatami) - 48usize];
    ["Offset of field: _z_hello_t::_version"]
        [::std::mem::offset_of!(_z_hello_t, _version) - 52usize];
};
unsafe extern "C" {
    pub fn _z_hello_clear(src: *mut _z_hello_t);
}
unsafe extern "C" {
    pub fn _z_hello_free(hello: *mut *mut _z_hello_t);
}
unsafe extern "C" {
    pub fn _z_hello_copy(dst: *mut _z_hello_t, src: *const _z_hello_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_hello_move(dst: *mut _z_hello_t, src: *mut _z_hello_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_hello_check(hello: *const _z_hello_t) -> bool;
}
pub type _z_hello_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_hello_t, right: *const _z_hello_t) -> bool,
>;
pub type _z_hello_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_hello_t,
        right: *const _z_hello_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_hello_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_target_complete_body_t {
    pub n: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_target_complete_body_t"]
        [::std::mem::size_of::<_z_target_complete_body_t>() - 8usize];
    ["Alignment of _z_target_complete_body_t"]
        [::std::mem::align_of::<_z_target_complete_body_t>() - 8usize];
    ["Offset of field: _z_target_complete_body_t::n"]
        [::std::mem::offset_of!(_z_target_complete_body_t, n) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_source_info_t {
    pub _source_id: _z_entity_global_id_t,
    pub _source_sn: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_source_info_t"][::std::mem::size_of::<_z_source_info_t>() - 24usize];
    ["Alignment of _z_source_info_t"][::std::mem::align_of::<_z_source_info_t>() - 4usize];
    ["Offset of field: _z_source_info_t::_source_id"]
        [::std::mem::offset_of!(_z_source_info_t, _source_id) - 0usize];
    ["Offset of field: _z_source_info_t::_source_sn"]
        [::std::mem::offset_of!(_z_source_info_t, _source_sn) - 20usize];
};
unsafe extern "C" {
    pub fn _z_source_info_copy(
        dst: *mut _z_source_info_t,
        src: *const _z_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_source_info_move(
        dst: *mut _z_source_info_t,
        src: *mut _z_source_info_t,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_reply_context_t {
    pub _request_id: u32,
    pub _entity_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_context_t"][::std::mem::size_of::<_z_reply_context_t>() - 8usize];
    ["Alignment of _z_reply_context_t"][::std::mem::align_of::<_z_reply_context_t>() - 4usize];
    ["Offset of field: _z_reply_context_t::_request_id"]
        [::std::mem::offset_of!(_z_reply_context_t, _request_id) - 0usize];
    ["Offset of field: _z_reply_context_t::_entity_id"]
        [::std::mem::offset_of!(_z_reply_context_t, _entity_id) - 4usize];
};
unsafe extern "C" {
    pub fn _z_keyexpr_is_canon(
        start: *const ::std::os::raw::c_char,
        len: usize,
    ) -> zp_keyexpr_canon_status_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_canonize(
        start: *mut ::std::os::raw::c_char,
        len: *mut usize,
    ) -> zp_keyexpr_canon_status_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_suffix_includes(
        left: *const _z_keyexpr_t,
        right: *const _z_keyexpr_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_suffix_intersects(
        left: *const _z_keyexpr_t,
        right: *const _z_keyexpr_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_suffix_equals(left: *const _z_keyexpr_t, right: *const _z_keyexpr_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_compare(
        first: *mut _z_keyexpr_t,
        second: *mut _z_keyexpr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_keyexpr_from_string(dst: *mut _z_keyexpr_t, rid: u16, str_: *const _z_string_t);
}
unsafe extern "C" {
    pub fn _z_keyexpr_from_substr(
        dst: *mut _z_keyexpr_t,
        rid: u16,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn _z_keyexpr_size(p: *mut _z_keyexpr_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_keyexpr_copy(dst: *mut _z_keyexpr_t, src: *const _z_keyexpr_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_duplicate(src: *const _z_keyexpr_t) -> _z_keyexpr_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_clone(src: *const _z_keyexpr_t) -> *mut _z_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Returns either keyexpr defined by id + mapping with null suffix if id is non-zero,\n or keyexpr defined by its suffix only, with 0 id and no mapping. This is to be used only when forwarding\n keyexpr in user api to properly separate declared keyexpr from its suffix."]
    pub fn _z_keyexpr_alias_from_user_defined(dst: *mut _z_keyexpr_t, src: *const _z_keyexpr_t);
}
unsafe extern "C" {
    pub fn _z_keyexpr_remove_wilds(
        base_key: *mut _z_keyexpr_t,
        wild_loc: *mut *mut ::std::os::raw::c_char,
        wild_suffix_size: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_equals(left: *const _z_keyexpr_t, right: *const _z_keyexpr_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_move(dst: *mut _z_keyexpr_t, src: *mut _z_keyexpr_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_free(rk: *mut *mut _z_keyexpr_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_kexpr_t {
    pub _id: u16,
    pub _keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_kexpr_t"][::std::mem::size_of::<_z_decl_kexpr_t>() - 56usize];
    ["Alignment of _z_decl_kexpr_t"][::std::mem::align_of::<_z_decl_kexpr_t>() - 8usize];
    ["Offset of field: _z_decl_kexpr_t::_id"]
        [::std::mem::offset_of!(_z_decl_kexpr_t, _id) - 0usize];
    ["Offset of field: _z_decl_kexpr_t::_keyexpr"]
        [::std::mem::offset_of!(_z_decl_kexpr_t, _keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_kexpr_t {
    pub _id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_kexpr_t"][::std::mem::size_of::<_z_undecl_kexpr_t>() - 2usize];
    ["Alignment of _z_undecl_kexpr_t"][::std::mem::align_of::<_z_undecl_kexpr_t>() - 2usize];
    ["Offset of field: _z_undecl_kexpr_t::_id"]
        [::std::mem::offset_of!(_z_undecl_kexpr_t, _id) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_subscriber_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_subscriber_t"][::std::mem::size_of::<_z_decl_subscriber_t>() - 56usize];
    ["Alignment of _z_decl_subscriber_t"][::std::mem::align_of::<_z_decl_subscriber_t>() - 8usize];
    ["Offset of field: _z_decl_subscriber_t::_keyexpr"]
        [::std::mem::offset_of!(_z_decl_subscriber_t, _keyexpr) - 0usize];
    ["Offset of field: _z_decl_subscriber_t::_id"]
        [::std::mem::offset_of!(_z_decl_subscriber_t, _id) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_subscriber_t {
    pub _id: u32,
    pub _ext_keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_subscriber_t"][::std::mem::size_of::<_z_undecl_subscriber_t>() - 56usize];
    ["Alignment of _z_undecl_subscriber_t"]
        [::std::mem::align_of::<_z_undecl_subscriber_t>() - 8usize];
    ["Offset of field: _z_undecl_subscriber_t::_id"]
        [::std::mem::offset_of!(_z_undecl_subscriber_t, _id) - 0usize];
    ["Offset of field: _z_undecl_subscriber_t::_ext_keyexpr"]
        [::std::mem::offset_of!(_z_undecl_subscriber_t, _ext_keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_queryable_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
    pub _ext_queryable_info: _z_decl_queryable_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_queryable_t__bindgen_ty_1 {
    pub _complete: bool,
    pub _distance: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_queryable_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_decl_queryable_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _z_decl_queryable_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_decl_queryable_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: _z_decl_queryable_t__bindgen_ty_1::_complete"]
        [::std::mem::offset_of!(_z_decl_queryable_t__bindgen_ty_1, _complete) - 0usize];
    ["Offset of field: _z_decl_queryable_t__bindgen_ty_1::_distance"]
        [::std::mem::offset_of!(_z_decl_queryable_t__bindgen_ty_1, _distance) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_queryable_t"][::std::mem::size_of::<_z_decl_queryable_t>() - 56usize];
    ["Alignment of _z_decl_queryable_t"][::std::mem::align_of::<_z_decl_queryable_t>() - 8usize];
    ["Offset of field: _z_decl_queryable_t::_keyexpr"]
        [::std::mem::offset_of!(_z_decl_queryable_t, _keyexpr) - 0usize];
    ["Offset of field: _z_decl_queryable_t::_id"]
        [::std::mem::offset_of!(_z_decl_queryable_t, _id) - 48usize];
    ["Offset of field: _z_decl_queryable_t::_ext_queryable_info"]
        [::std::mem::offset_of!(_z_decl_queryable_t, _ext_queryable_info) - 52usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_queryable_t {
    pub _id: u32,
    pub _ext_keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_queryable_t"][::std::mem::size_of::<_z_undecl_queryable_t>() - 56usize];
    ["Alignment of _z_undecl_queryable_t"]
        [::std::mem::align_of::<_z_undecl_queryable_t>() - 8usize];
    ["Offset of field: _z_undecl_queryable_t::_id"]
        [::std::mem::offset_of!(_z_undecl_queryable_t, _id) - 0usize];
    ["Offset of field: _z_undecl_queryable_t::_ext_keyexpr"]
        [::std::mem::offset_of!(_z_undecl_queryable_t, _ext_keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_token_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_token_t"][::std::mem::size_of::<_z_decl_token_t>() - 56usize];
    ["Alignment of _z_decl_token_t"][::std::mem::align_of::<_z_decl_token_t>() - 8usize];
    ["Offset of field: _z_decl_token_t::_keyexpr"]
        [::std::mem::offset_of!(_z_decl_token_t, _keyexpr) - 0usize];
    ["Offset of field: _z_decl_token_t::_id"]
        [::std::mem::offset_of!(_z_decl_token_t, _id) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_token_t {
    pub _id: u32,
    pub _ext_keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_token_t"][::std::mem::size_of::<_z_undecl_token_t>() - 56usize];
    ["Alignment of _z_undecl_token_t"][::std::mem::align_of::<_z_undecl_token_t>() - 8usize];
    ["Offset of field: _z_undecl_token_t::_id"]
        [::std::mem::offset_of!(_z_undecl_token_t, _id) - 0usize];
    ["Offset of field: _z_undecl_token_t::_ext_keyexpr"]
        [::std::mem::offset_of!(_z_undecl_token_t, _ext_keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_final_t {
    pub _placeholder: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_final_t"][::std::mem::size_of::<_z_decl_final_t>() - 1usize];
    ["Alignment of _z_decl_final_t"][::std::mem::align_of::<_z_decl_final_t>() - 1usize];
    ["Offset of field: _z_decl_final_t::_placeholder"]
        [::std::mem::offset_of!(_z_decl_final_t, _placeholder) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_declaration_t {
    pub _tag: _z_declaration_t__bindgen_ty_1,
    pub _body: _z_declaration_t__bindgen_ty_2,
}
pub const _z_declaration_t__Z_DECL_KEXPR: _z_declaration_t__bindgen_ty_1 = 0;
pub const _z_declaration_t__Z_UNDECL_KEXPR: _z_declaration_t__bindgen_ty_1 = 1;
pub const _z_declaration_t__Z_DECL_SUBSCRIBER: _z_declaration_t__bindgen_ty_1 = 2;
pub const _z_declaration_t__Z_UNDECL_SUBSCRIBER: _z_declaration_t__bindgen_ty_1 = 3;
pub const _z_declaration_t__Z_DECL_QUERYABLE: _z_declaration_t__bindgen_ty_1 = 4;
pub const _z_declaration_t__Z_UNDECL_QUERYABLE: _z_declaration_t__bindgen_ty_1 = 5;
pub const _z_declaration_t__Z_DECL_TOKEN: _z_declaration_t__bindgen_ty_1 = 6;
pub const _z_declaration_t__Z_UNDECL_TOKEN: _z_declaration_t__bindgen_ty_1 = 7;
pub const _z_declaration_t__Z_DECL_FINAL: _z_declaration_t__bindgen_ty_1 = 8;
pub type _z_declaration_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_declaration_t__bindgen_ty_2 {
    pub _decl_kexpr: _z_decl_kexpr_t,
    pub _undecl_kexpr: _z_undecl_kexpr_t,
    pub _decl_subscriber: _z_decl_subscriber_t,
    pub _undecl_subscriber: _z_undecl_subscriber_t,
    pub _decl_queryable: _z_decl_queryable_t,
    pub _undecl_queryable: _z_undecl_queryable_t,
    pub _decl_token: _z_decl_token_t,
    pub _undecl_token: _z_undecl_token_t,
    pub _decl_final: _z_decl_final_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_declaration_t__bindgen_ty_2"]
        [::std::mem::size_of::<_z_declaration_t__bindgen_ty_2>() - 56usize];
    ["Alignment of _z_declaration_t__bindgen_ty_2"]
        [::std::mem::align_of::<_z_declaration_t__bindgen_ty_2>() - 8usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_kexpr"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_kexpr) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_kexpr"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_kexpr) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_subscriber"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_subscriber) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_subscriber"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_subscriber) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_queryable"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_queryable) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_queryable"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_queryable) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_token"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_token) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_token"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_token) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_final"]
        [::std::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_final) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_declaration_t"][::std::mem::size_of::<_z_declaration_t>() - 64usize];
    ["Alignment of _z_declaration_t"][::std::mem::align_of::<_z_declaration_t>() - 8usize];
    ["Offset of field: _z_declaration_t::_tag"]
        [::std::mem::offset_of!(_z_declaration_t, _tag) - 0usize];
    ["Offset of field: _z_declaration_t::_body"]
        [::std::mem::offset_of!(_z_declaration_t, _body) - 8usize];
};
unsafe extern "C" {
    pub fn _z_declaration_clear(decl: *mut _z_declaration_t);
}
unsafe extern "C" {
    pub fn _z_make_decl_keyexpr(id: u16, key: *mut _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_keyexpr(id: u16) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_subscriber(key: *mut _z_keyexpr_t, id: u32) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_subscriber(id: u32, key: *const _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_queryable(
        key: *mut _z_keyexpr_t,
        id: u32,
        complete: bool,
        distance: u16,
    ) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_queryable(id: u32, key: *const _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_token(key: *mut _z_keyexpr_t, id: u32) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_token(id: u32, key: *const _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_final() -> _z_declaration_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_interest_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
    pub flags: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_interest_t"][::std::mem::size_of::<_z_interest_t>() - 56usize];
    ["Alignment of _z_interest_t"][::std::mem::align_of::<_z_interest_t>() - 8usize];
    ["Offset of field: _z_interest_t::_keyexpr"]
        [::std::mem::offset_of!(_z_interest_t, _keyexpr) - 0usize];
    ["Offset of field: _z_interest_t::_id"][::std::mem::offset_of!(_z_interest_t, _id) - 48usize];
    ["Offset of field: _z_interest_t::flags"]
        [::std::mem::offset_of!(_z_interest_t, flags) - 52usize];
};
unsafe extern "C" {
    pub fn _z_interest_clear(decl: *mut _z_interest_t);
}
unsafe extern "C" {
    pub fn _z_make_interest(key: *mut _z_keyexpr_t, id: u32, flags: u8) -> _z_interest_t;
}
unsafe extern "C" {
    pub fn _z_make_interest_final(id: u32) -> _z_interest_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_err_t {
    pub _encoding: _z_encoding_t,
    pub _ext_source_info: _z_source_info_t,
    pub _payload: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_err_t"][::std::mem::size_of::<_z_msg_err_t>() - 96usize];
    ["Alignment of _z_msg_err_t"][::std::mem::align_of::<_z_msg_err_t>() - 8usize];
    ["Offset of field: _z_msg_err_t::_encoding"]
        [::std::mem::offset_of!(_z_msg_err_t, _encoding) - 0usize];
    ["Offset of field: _z_msg_err_t::_ext_source_info"]
        [::std::mem::offset_of!(_z_msg_err_t, _ext_source_info) - 40usize];
    ["Offset of field: _z_msg_err_t::_payload"]
        [::std::mem::offset_of!(_z_msg_err_t, _payload) - 64usize];
};
unsafe extern "C" {
    pub fn _z_msg_err_clear(err: *mut _z_msg_err_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_m_push_commons_t {
    pub _timestamp: _z_timestamp_t,
    pub _source_info: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_m_push_commons_t"][::std::mem::size_of::<_z_m_push_commons_t>() - 56usize];
    ["Alignment of _z_m_push_commons_t"][::std::mem::align_of::<_z_m_push_commons_t>() - 8usize];
    ["Offset of field: _z_m_push_commons_t::_timestamp"]
        [::std::mem::offset_of!(_z_m_push_commons_t, _timestamp) - 0usize];
    ["Offset of field: _z_m_push_commons_t::_source_info"]
        [::std::mem::offset_of!(_z_m_push_commons_t, _source_info) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_del_t {
    pub _commons: _z_m_push_commons_t,
    pub _attachment: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_del_t"][::std::mem::size_of::<_z_msg_del_t>() - 88usize];
    ["Alignment of _z_msg_del_t"][::std::mem::align_of::<_z_msg_del_t>() - 8usize];
    ["Offset of field: _z_msg_del_t::_commons"]
        [::std::mem::offset_of!(_z_msg_del_t, _commons) - 0usize];
    ["Offset of field: _z_msg_del_t::_attachment"]
        [::std::mem::offset_of!(_z_msg_del_t, _attachment) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_put_t {
    pub _commons: _z_m_push_commons_t,
    pub _payload: _z_bytes_t,
    pub _encoding: _z_encoding_t,
    pub _attachment: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_put_t"][::std::mem::size_of::<_z_msg_put_t>() - 160usize];
    ["Alignment of _z_msg_put_t"][::std::mem::align_of::<_z_msg_put_t>() - 8usize];
    ["Offset of field: _z_msg_put_t::_commons"]
        [::std::mem::offset_of!(_z_msg_put_t, _commons) - 0usize];
    ["Offset of field: _z_msg_put_t::_payload"]
        [::std::mem::offset_of!(_z_msg_put_t, _payload) - 56usize];
    ["Offset of field: _z_msg_put_t::_encoding"]
        [::std::mem::offset_of!(_z_msg_put_t, _encoding) - 88usize];
    ["Offset of field: _z_msg_put_t::_attachment"]
        [::std::mem::offset_of!(_z_msg_put_t, _attachment) - 128usize];
};
unsafe extern "C" {
    pub fn _z_msg_put_clear(arg1: *mut _z_msg_put_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_query_t {
    pub _parameters: _z_slice_t,
    pub _ext_info: _z_source_info_t,
    pub _ext_value: _z_value_t,
    pub _consolidation: z_consolidation_mode_t,
    pub _ext_attachment: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_query_t"][::std::mem::size_of::<_z_msg_query_t>() - 168usize];
    ["Alignment of _z_msg_query_t"][::std::mem::align_of::<_z_msg_query_t>() - 8usize];
    ["Offset of field: _z_msg_query_t::_parameters"]
        [::std::mem::offset_of!(_z_msg_query_t, _parameters) - 0usize];
    ["Offset of field: _z_msg_query_t::_ext_info"]
        [::std::mem::offset_of!(_z_msg_query_t, _ext_info) - 32usize];
    ["Offset of field: _z_msg_query_t::_ext_value"]
        [::std::mem::offset_of!(_z_msg_query_t, _ext_value) - 56usize];
    ["Offset of field: _z_msg_query_t::_consolidation"]
        [::std::mem::offset_of!(_z_msg_query_t, _consolidation) - 128usize];
    ["Offset of field: _z_msg_query_t::_ext_attachment"]
        [::std::mem::offset_of!(_z_msg_query_t, _ext_attachment) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_query_reqexts_t {
    pub info: bool,
    pub body: bool,
    pub attachment: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_query_reqexts_t"][::std::mem::size_of::<_z_msg_query_reqexts_t>() - 3usize];
    ["Alignment of _z_msg_query_reqexts_t"]
        [::std::mem::align_of::<_z_msg_query_reqexts_t>() - 1usize];
    ["Offset of field: _z_msg_query_reqexts_t::info"]
        [::std::mem::offset_of!(_z_msg_query_reqexts_t, info) - 0usize];
    ["Offset of field: _z_msg_query_reqexts_t::body"]
        [::std::mem::offset_of!(_z_msg_query_reqexts_t, body) - 1usize];
    ["Offset of field: _z_msg_query_reqexts_t::attachment"]
        [::std::mem::offset_of!(_z_msg_query_reqexts_t, attachment) - 2usize];
};
unsafe extern "C" {
    pub fn _z_msg_query_required_extensions(msg: *const _z_msg_query_t) -> _z_msg_query_reqexts_t;
}
unsafe extern "C" {
    pub fn _z_msg_query_clear(msg: *mut _z_msg_query_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_body_t {
    pub _is_put: bool,
    pub _body: _z_reply_body_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_reply_body_t__bindgen_ty_1 {
    pub _del: _z_msg_del_t,
    pub _put: _z_msg_put_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_body_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_reply_body_t__bindgen_ty_1>() - 160usize];
    ["Alignment of _z_reply_body_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_reply_body_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_reply_body_t__bindgen_ty_1::_del"]
        [::std::mem::offset_of!(_z_reply_body_t__bindgen_ty_1, _del) - 0usize];
    ["Offset of field: _z_reply_body_t__bindgen_ty_1::_put"]
        [::std::mem::offset_of!(_z_reply_body_t__bindgen_ty_1, _put) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_body_t"][::std::mem::size_of::<_z_reply_body_t>() - 168usize];
    ["Alignment of _z_reply_body_t"][::std::mem::align_of::<_z_reply_body_t>() - 8usize];
    ["Offset of field: _z_reply_body_t::_is_put"]
        [::std::mem::offset_of!(_z_reply_body_t, _is_put) - 0usize];
    ["Offset of field: _z_reply_body_t::_body"]
        [::std::mem::offset_of!(_z_reply_body_t, _body) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_msg_reply_t {
    pub _consolidation: z_consolidation_mode_t,
    pub _body: _z_reply_body_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_reply_t"][::std::mem::size_of::<_z_msg_reply_t>() - 176usize];
    ["Alignment of _z_msg_reply_t"][::std::mem::align_of::<_z_msg_reply_t>() - 8usize];
    ["Offset of field: _z_msg_reply_t::_consolidation"]
        [::std::mem::offset_of!(_z_msg_reply_t, _consolidation) - 0usize];
    ["Offset of field: _z_msg_reply_t::_body"]
        [::std::mem::offset_of!(_z_msg_reply_t, _body) - 8usize];
};
unsafe extern "C" {
    pub fn _z_msg_reply_clear(msg: *mut _z_msg_reply_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_ext_unit_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_unit_t"][::std::mem::size_of::<_z_msg_ext_unit_t>() - 1usize];
    ["Alignment of _z_msg_ext_unit_t"][::std::mem::align_of::<_z_msg_ext_unit_t>() - 1usize];
    ["Offset of field: _z_msg_ext_unit_t::__dummy"]
        [::std::mem::offset_of!(_z_msg_ext_unit_t, __dummy) - 0usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear_unit(ext: *mut _z_msg_ext_unit_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_ext_zint_t {
    pub _val: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_zint_t"][::std::mem::size_of::<_z_msg_ext_zint_t>() - 8usize];
    ["Alignment of _z_msg_ext_zint_t"][::std::mem::align_of::<_z_msg_ext_zint_t>() - 8usize];
    ["Offset of field: _z_msg_ext_zint_t::_val"]
        [::std::mem::offset_of!(_z_msg_ext_zint_t, _val) - 0usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear_zint(ext: *mut _z_msg_ext_zint_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_ext_zbuf_t {
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_zbuf_t"][::std::mem::size_of::<_z_msg_ext_zbuf_t>() - 32usize];
    ["Alignment of _z_msg_ext_zbuf_t"][::std::mem::align_of::<_z_msg_ext_zbuf_t>() - 8usize];
    ["Offset of field: _z_msg_ext_zbuf_t::_val"]
        [::std::mem::offset_of!(_z_msg_ext_zbuf_t, _val) - 0usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear_zbuf(ext: *mut _z_msg_ext_zbuf_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_msg_ext_body_t {
    pub _unit: _z_msg_ext_unit_t,
    pub _zint: _z_msg_ext_zint_t,
    pub _zbuf: _z_msg_ext_zbuf_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_body_t"][::std::mem::size_of::<_z_msg_ext_body_t>() - 32usize];
    ["Alignment of _z_msg_ext_body_t"][::std::mem::align_of::<_z_msg_ext_body_t>() - 8usize];
    ["Offset of field: _z_msg_ext_body_t::_unit"]
        [::std::mem::offset_of!(_z_msg_ext_body_t, _unit) - 0usize];
    ["Offset of field: _z_msg_ext_body_t::_zint"]
        [::std::mem::offset_of!(_z_msg_ext_body_t, _zint) - 0usize];
    ["Offset of field: _z_msg_ext_body_t::_zbuf"]
        [::std::mem::offset_of!(_z_msg_ext_body_t, _zbuf) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_msg_ext_t {
    pub _body: _z_msg_ext_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_t"][::std::mem::size_of::<_z_msg_ext_t>() - 40usize];
    ["Alignment of _z_msg_ext_t"][::std::mem::align_of::<_z_msg_ext_t>() - 8usize];
    ["Offset of field: _z_msg_ext_t::_body"][::std::mem::offset_of!(_z_msg_ext_t, _body) - 0usize];
    ["Offset of field: _z_msg_ext_t::_header"]
        [::std::mem::offset_of!(_z_msg_ext_t, _header) - 32usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear(ext: *mut _z_msg_ext_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_make_unit(id: u8) -> _z_msg_ext_t;
}
unsafe extern "C" {
    pub fn _z_msg_ext_make_zint(id: u8, zid: _z_zint_t) -> _z_msg_ext_t;
}
unsafe extern "C" {
    pub fn _z_msg_ext_make_zbuf(id: u8, zbuf: _z_slice_t) -> _z_msg_ext_t;
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy(clone: *mut _z_msg_ext_t, ext: *const _z_msg_ext_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy_unit(clone: *mut _z_msg_ext_unit_t, ext: *const _z_msg_ext_unit_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy_zint(clone: *mut _z_msg_ext_zint_t, ext: *const _z_msg_ext_zint_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy_zbuf(clone: *mut _z_msg_ext_zbuf_t, ext: *const _z_msg_ext_zbuf_t);
}
pub type _z_msg_ext_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_msg_ext_t, right: *const _z_msg_ext_t) -> bool,
>;
pub type _z_msg_ext_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_msg_ext_t,
        right: *const _z_msg_ext_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored as pointers."]
pub type _z_msg_ext_vec_t = _z_vec_t;
#[doc = " QoS settings of zenoh message."]
pub type _z_n_qos_t = _z_qos_t;
unsafe extern "C" {
    pub static _Z_N_QOS_DEFAULT: _z_qos_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_request_t {
    pub _rid: _z_zint_t,
    pub _key: _z_keyexpr_t,
    pub _ext_timestamp: _z_timestamp_t,
    pub _ext_qos: _z_n_qos_t,
    pub _ext_target: z_query_target_t,
    pub _ext_budget: u32,
    pub _ext_timeout_ms: u64,
    pub _tag: _z_n_msg_request_t__bindgen_ty_1,
    pub _body: _z_n_msg_request_t__bindgen_ty_2,
}
pub const _z_n_msg_request_t__Z_REQUEST_QUERY: _z_n_msg_request_t__bindgen_ty_1 = 0;
pub const _z_n_msg_request_t__Z_REQUEST_PUT: _z_n_msg_request_t__bindgen_ty_1 = 1;
pub const _z_n_msg_request_t__Z_REQUEST_DEL: _z_n_msg_request_t__bindgen_ty_1 = 2;
pub type _z_n_msg_request_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_n_msg_request_t__bindgen_ty_2 {
    pub _query: _z_msg_query_t,
    pub _put: _z_msg_put_t,
    pub _del: _z_msg_del_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_request_t__bindgen_ty_2"]
        [::std::mem::size_of::<_z_n_msg_request_t__bindgen_ty_2>() - 168usize];
    ["Alignment of _z_n_msg_request_t__bindgen_ty_2"]
        [::std::mem::align_of::<_z_n_msg_request_t__bindgen_ty_2>() - 8usize];
    ["Offset of field: _z_n_msg_request_t__bindgen_ty_2::_query"]
        [::std::mem::offset_of!(_z_n_msg_request_t__bindgen_ty_2, _query) - 0usize];
    ["Offset of field: _z_n_msg_request_t__bindgen_ty_2::_put"]
        [::std::mem::offset_of!(_z_n_msg_request_t__bindgen_ty_2, _put) - 0usize];
    ["Offset of field: _z_n_msg_request_t__bindgen_ty_2::_del"]
        [::std::mem::offset_of!(_z_n_msg_request_t__bindgen_ty_2, _del) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_request_t"][::std::mem::size_of::<_z_n_msg_request_t>() - 288usize];
    ["Alignment of _z_n_msg_request_t"][::std::mem::align_of::<_z_n_msg_request_t>() - 8usize];
    ["Offset of field: _z_n_msg_request_t::_rid"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _rid) - 0usize];
    ["Offset of field: _z_n_msg_request_t::_key"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _key) - 8usize];
    ["Offset of field: _z_n_msg_request_t::_ext_timestamp"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _ext_timestamp) - 56usize];
    ["Offset of field: _z_n_msg_request_t::_ext_qos"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _ext_qos) - 88usize];
    ["Offset of field: _z_n_msg_request_t::_ext_target"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _ext_target) - 92usize];
    ["Offset of field: _z_n_msg_request_t::_ext_budget"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _ext_budget) - 96usize];
    ["Offset of field: _z_n_msg_request_t::_ext_timeout_ms"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _ext_timeout_ms) - 104usize];
    ["Offset of field: _z_n_msg_request_t::_tag"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _tag) - 112usize];
    ["Offset of field: _z_n_msg_request_t::_body"]
        [::std::mem::offset_of!(_z_n_msg_request_t, _body) - 120usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_request_exts_t {
    pub ext_qos: bool,
    pub ext_tstamp: bool,
    pub ext_target: bool,
    pub ext_budget: bool,
    pub ext_timeout_ms: bool,
    pub n: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_request_exts_t"][::std::mem::size_of::<_z_n_msg_request_exts_t>() - 6usize];
    ["Alignment of _z_n_msg_request_exts_t"]
        [::std::mem::align_of::<_z_n_msg_request_exts_t>() - 1usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_qos"]
        [::std::mem::offset_of!(_z_n_msg_request_exts_t, ext_qos) - 0usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_tstamp"]
        [::std::mem::offset_of!(_z_n_msg_request_exts_t, ext_tstamp) - 1usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_target"]
        [::std::mem::offset_of!(_z_n_msg_request_exts_t, ext_target) - 2usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_budget"]
        [::std::mem::offset_of!(_z_n_msg_request_exts_t, ext_budget) - 3usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_timeout_ms"]
        [::std::mem::offset_of!(_z_n_msg_request_exts_t, ext_timeout_ms) - 4usize];
    ["Offset of field: _z_n_msg_request_exts_t::n"]
        [::std::mem::offset_of!(_z_n_msg_request_exts_t, n) - 5usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_request_needed_exts(msg: *const _z_n_msg_request_t) -> _z_n_msg_request_exts_t;
}
unsafe extern "C" {
    pub fn _z_n_msg_request_clear(msg: *mut _z_n_msg_request_t);
}
pub type _z_push_body_t = _z_reply_body_t;
unsafe extern "C" {
    pub fn _z_push_body_steal(msg: *mut _z_push_body_t) -> _z_push_body_t;
}
unsafe extern "C" {
    pub fn _z_push_body_clear(msg: *mut _z_push_body_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_response_final_t {
    pub _request_id: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_final_t"]
        [::std::mem::size_of::<_z_n_msg_response_final_t>() - 8usize];
    ["Alignment of _z_n_msg_response_final_t"]
        [::std::mem::align_of::<_z_n_msg_response_final_t>() - 8usize];
    ["Offset of field: _z_n_msg_response_final_t::_request_id"]
        [::std::mem::offset_of!(_z_n_msg_response_final_t, _request_id) - 0usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_response_final_clear(msg: *mut _z_n_msg_response_final_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_push_t {
    pub _key: _z_keyexpr_t,
    pub _timestamp: _z_timestamp_t,
    pub _qos: _z_n_qos_t,
    pub _body: _z_push_body_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_push_t"][::std::mem::size_of::<_z_n_msg_push_t>() - 256usize];
    ["Alignment of _z_n_msg_push_t"][::std::mem::align_of::<_z_n_msg_push_t>() - 8usize];
    ["Offset of field: _z_n_msg_push_t::_key"]
        [::std::mem::offset_of!(_z_n_msg_push_t, _key) - 0usize];
    ["Offset of field: _z_n_msg_push_t::_timestamp"]
        [::std::mem::offset_of!(_z_n_msg_push_t, _timestamp) - 48usize];
    ["Offset of field: _z_n_msg_push_t::_qos"]
        [::std::mem::offset_of!(_z_n_msg_push_t, _qos) - 80usize];
    ["Offset of field: _z_n_msg_push_t::_body"]
        [::std::mem::offset_of!(_z_n_msg_push_t, _body) - 88usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_push_clear(msg: *mut _z_n_msg_push_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_response_t {
    pub _ext_timestamp: _z_timestamp_t,
    pub _request_id: _z_zint_t,
    pub _key: _z_keyexpr_t,
    pub _ext_qos: _z_n_qos_t,
    pub _ext_responder: _z_n_msg_response_t__bindgen_ty_1,
    pub _tag: _z_n_msg_response_t__bindgen_ty_2,
    pub _body: _z_n_msg_response_t__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_response_t__bindgen_ty_1 {
    pub _zid: _z_id_t,
    pub _eid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_n_msg_response_t__bindgen_ty_1>() - 20usize];
    ["Alignment of _z_n_msg_response_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_n_msg_response_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_1::_zid"]
        [::std::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_1, _zid) - 0usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_1::_eid"]
        [::std::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_1, _eid) - 16usize];
};
pub const _z_n_msg_response_t__Z_RESPONSE_BODY_REPLY: _z_n_msg_response_t__bindgen_ty_2 = 0;
pub const _z_n_msg_response_t__Z_RESPONSE_BODY_ERR: _z_n_msg_response_t__bindgen_ty_2 = 1;
pub type _z_n_msg_response_t__bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_n_msg_response_t__bindgen_ty_3 {
    pub _reply: _z_msg_reply_t,
    pub _err: _z_msg_err_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_t__bindgen_ty_3"]
        [::std::mem::size_of::<_z_n_msg_response_t__bindgen_ty_3>() - 176usize];
    ["Alignment of _z_n_msg_response_t__bindgen_ty_3"]
        [::std::mem::align_of::<_z_n_msg_response_t__bindgen_ty_3>() - 8usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_3::_reply"]
        [::std::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_3, _reply) - 0usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_3::_err"]
        [::std::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_3, _err) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_t"][::std::mem::size_of::<_z_n_msg_response_t>() - 296usize];
    ["Alignment of _z_n_msg_response_t"][::std::mem::align_of::<_z_n_msg_response_t>() - 8usize];
    ["Offset of field: _z_n_msg_response_t::_ext_timestamp"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _ext_timestamp) - 0usize];
    ["Offset of field: _z_n_msg_response_t::_request_id"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _request_id) - 32usize];
    ["Offset of field: _z_n_msg_response_t::_key"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _key) - 40usize];
    ["Offset of field: _z_n_msg_response_t::_ext_qos"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _ext_qos) - 88usize];
    ["Offset of field: _z_n_msg_response_t::_ext_responder"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _ext_responder) - 92usize];
    ["Offset of field: _z_n_msg_response_t::_tag"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _tag) - 112usize];
    ["Offset of field: _z_n_msg_response_t::_body"]
        [::std::mem::offset_of!(_z_n_msg_response_t, _body) - 120usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_response_clear(msg: *mut _z_n_msg_response_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_declare_t {
    pub _decl: _z_declaration_t,
    pub _ext_timestamp: _z_timestamp_t,
    pub _ext_qos: _z_n_qos_t,
    pub _interest_id: u32,
    pub has_interest_id: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_declare_t"][::std::mem::size_of::<_z_n_msg_declare_t>() - 112usize];
    ["Alignment of _z_n_msg_declare_t"][::std::mem::align_of::<_z_n_msg_declare_t>() - 8usize];
    ["Offset of field: _z_n_msg_declare_t::_decl"]
        [::std::mem::offset_of!(_z_n_msg_declare_t, _decl) - 0usize];
    ["Offset of field: _z_n_msg_declare_t::_ext_timestamp"]
        [::std::mem::offset_of!(_z_n_msg_declare_t, _ext_timestamp) - 64usize];
    ["Offset of field: _z_n_msg_declare_t::_ext_qos"]
        [::std::mem::offset_of!(_z_n_msg_declare_t, _ext_qos) - 96usize];
    ["Offset of field: _z_n_msg_declare_t::_interest_id"]
        [::std::mem::offset_of!(_z_n_msg_declare_t, _interest_id) - 100usize];
    ["Offset of field: _z_n_msg_declare_t::has_interest_id"]
        [::std::mem::offset_of!(_z_n_msg_declare_t, has_interest_id) - 104usize];
};
#[doc = " Flags:\n - C: Current       If C==1 then interest concerns current declarations\n - F: Future        If F==1 then interest concerns future declarations\n - Z: Extension     If Z==1 then Zenoh extensions are present\n If C==0 and F==0, then interest is final\n\n 7 6 5 4 3 2 1 0\n +-+-+-+-+-+-+-+-+\n |Z|F|C|INTEREST |\n +-+-+-+---------+\n ~    id:z32     ~\n +---------------+\n |A|M|N|R|T|Q|S|K|  (*) if interest is not final\n +---------------+\n ~ key_scope:z16 ~  if interest is not final && R==1\n +---------------+\n ~  key_suffix   ~  if interest is not final && R==1 && N==1 -- <u8;z16>\n +---------------+\n ~  [int_exts]   ~  if Z==1\n +---------------+\n\n (*) - if K==1 then the interest refers to key expressions\n     - if S==1 then the interest refers to subscribers\n     - if Q==1 then the interest refers to queryables\n     - if T==1 then the interest refers to tokens\n     - if R==1 then the interest is restricted to the matching key expression, else it is for all key expressions.\n     - if N==1 then the key expr has name/suffix. If R==0 then N should be set to 0.\n     - if M==1 then key expr mapping is the one declared by the sender, else it is the one declared by the receiver.\n               If R==0 then M should be set to 0.\n     - if A==1 then the replies SHOULD be aggregated\n ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_interest_t {
    pub _interest: _z_interest_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_interest_t"][::std::mem::size_of::<_z_n_msg_interest_t>() - 56usize];
    ["Alignment of _z_n_msg_interest_t"][::std::mem::align_of::<_z_n_msg_interest_t>() - 8usize];
    ["Offset of field: _z_n_msg_interest_t::_interest"]
        [::std::mem::offset_of!(_z_n_msg_interest_t, _interest) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_network_body_t {
    pub _declare: _z_n_msg_declare_t,
    pub _push: _z_n_msg_push_t,
    pub _request: _z_n_msg_request_t,
    pub _response: _z_n_msg_response_t,
    pub _response_final: _z_n_msg_response_final_t,
    pub _interest: _z_n_msg_interest_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_network_body_t"][::std::mem::size_of::<_z_network_body_t>() - 296usize];
    ["Alignment of _z_network_body_t"][::std::mem::align_of::<_z_network_body_t>() - 8usize];
    ["Offset of field: _z_network_body_t::_declare"]
        [::std::mem::offset_of!(_z_network_body_t, _declare) - 0usize];
    ["Offset of field: _z_network_body_t::_push"]
        [::std::mem::offset_of!(_z_network_body_t, _push) - 0usize];
    ["Offset of field: _z_network_body_t::_request"]
        [::std::mem::offset_of!(_z_network_body_t, _request) - 0usize];
    ["Offset of field: _z_network_body_t::_response"]
        [::std::mem::offset_of!(_z_network_body_t, _response) - 0usize];
    ["Offset of field: _z_network_body_t::_response_final"]
        [::std::mem::offset_of!(_z_network_body_t, _response_final) - 0usize];
    ["Offset of field: _z_network_body_t::_interest"]
        [::std::mem::offset_of!(_z_network_body_t, _interest) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_network_message_t {
    pub _tag: _z_network_message_t__bindgen_ty_1,
    pub _body: _z_network_body_t,
    pub _reliability: z_reliability_t,
}
pub const _z_network_message_t__Z_N_DECLARE: _z_network_message_t__bindgen_ty_1 = 0;
pub const _z_network_message_t__Z_N_PUSH: _z_network_message_t__bindgen_ty_1 = 1;
pub const _z_network_message_t__Z_N_REQUEST: _z_network_message_t__bindgen_ty_1 = 2;
pub const _z_network_message_t__Z_N_RESPONSE: _z_network_message_t__bindgen_ty_1 = 3;
pub const _z_network_message_t__Z_N_RESPONSE_FINAL: _z_network_message_t__bindgen_ty_1 = 4;
pub const _z_network_message_t__Z_N_INTEREST: _z_network_message_t__bindgen_ty_1 = 5;
pub type _z_network_message_t__bindgen_ty_1 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_network_message_t"][::std::mem::size_of::<_z_network_message_t>() - 312usize];
    ["Alignment of _z_network_message_t"][::std::mem::align_of::<_z_network_message_t>() - 8usize];
    ["Offset of field: _z_network_message_t::_tag"]
        [::std::mem::offset_of!(_z_network_message_t, _tag) - 0usize];
    ["Offset of field: _z_network_message_t::_body"]
        [::std::mem::offset_of!(_z_network_message_t, _body) - 8usize];
    ["Offset of field: _z_network_message_t::_reliability"]
        [::std::mem::offset_of!(_z_network_message_t, _reliability) - 304usize];
};
pub type _z_zenoh_message_t = _z_network_message_t;
unsafe extern "C" {
    pub fn _z_n_msg_clear(m: *mut _z_network_message_t);
}
unsafe extern "C" {
    pub fn _z_n_msg_free(m: *mut *mut _z_network_message_t);
}
unsafe extern "C" {
    pub fn _z_n_msg_copy(
        dst: *mut _z_network_message_t,
        src: *const _z_network_message_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_n_msg_clone(src: *const _z_network_message_t) -> *mut _z_network_message_t;
}
pub type _z_network_message_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_network_message_t,
        right: *const _z_network_message_t,
    ) -> bool,
>;
pub type _z_network_message_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_network_message_t,
        right: *const _z_network_message_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_network_message_svec_t = _z_svec_t;
pub type _z_network_message_slist_t = _z_slist_t;
unsafe extern "C" {
    pub fn _z_n_msg_make_response_final(msg: *mut _z_network_message_t, rid: _z_zint_t);
}
unsafe extern "C" {
    pub fn _z_n_msg_make_declare(
        msg: *mut _z_network_message_t,
        declaration: _z_declaration_t,
        has_interest_id: bool,
        interest_id: u32,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_query(
        msg: *mut _z_zenoh_message_t,
        key: *const _z_keyexpr_t,
        parameters: *const _z_slice_t,
        qid: _z_zint_t,
        reliability: z_reliability_t,
        consolidation: z_consolidation_mode_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        timeout_ms: u64,
        attachment: *const _z_bytes_t,
        qos: _z_n_qos_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_push_put(
        dst: *mut _z_network_message_t,
        key: *const _z_keyexpr_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        attachment: *const _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_push_del(
        dst: *mut _z_network_message_t,
        key: *const _z_keyexpr_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        reliability: z_reliability_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_reply_ok_put(
        dst: *mut _z_network_message_t,
        zid: *const _z_id_t,
        rid: _z_zint_t,
        key: *const _z_keyexpr_t,
        reliability: z_reliability_t,
        consolidation: z_consolidation_mode_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        source_info: *const _z_source_info_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        attachment: *const _z_bytes_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_reply_ok_del(
        dst: *mut _z_network_message_t,
        zid: *const _z_id_t,
        rid: _z_zint_t,
        key: *const _z_keyexpr_t,
        reliability: z_reliability_t,
        consolidation: z_consolidation_mode_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        source_info: *const _z_source_info_t,
        attachment: *const _z_bytes_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_reply_err(
        dst: *mut _z_network_message_t,
        zid: *const _z_id_t,
        rid: _z_zint_t,
        reliability: z_reliability_t,
        qos: _z_n_qos_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_interest(msg: *mut _z_network_message_t, interest: _z_interest_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_locator_t {
    pub _metadata: _z_str_intmap_t,
    pub _protocol: _z_string_t,
    pub _address: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_locator_t"][::std::mem::size_of::<_z_locator_t>() - 96usize];
    ["Alignment of _z_locator_t"][::std::mem::align_of::<_z_locator_t>() - 8usize];
    ["Offset of field: _z_locator_t::_metadata"]
        [::std::mem::offset_of!(_z_locator_t, _metadata) - 0usize];
    ["Offset of field: _z_locator_t::_protocol"]
        [::std::mem::offset_of!(_z_locator_t, _protocol) - 32usize];
    ["Offset of field: _z_locator_t::_address"]
        [::std::mem::offset_of!(_z_locator_t, _address) - 64usize];
};
unsafe extern "C" {
    pub fn _z_locator_eq(left: *const _z_locator_t, right: *const _z_locator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_locator_init(locator: *mut _z_locator_t);
}
unsafe extern "C" {
    pub fn _z_locator_to_string(loc: *const _z_locator_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_locator_from_string(lc: *mut _z_locator_t, s: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_locator_size(lc: *mut _z_locator_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_locator_clear(lc: *mut _z_locator_t);
}
pub type _z_locator_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_locator_t, right: *const _z_locator_t) -> bool,
>;
pub type _z_locator_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_locator_t,
        right: *const _z_locator_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_locator_array_t {
    pub _len: usize,
    pub _val: *mut _z_locator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_locator_array_t"][::std::mem::size_of::<_z_locator_array_t>() - 16usize];
    ["Alignment of _z_locator_array_t"][::std::mem::align_of::<_z_locator_array_t>() - 8usize];
    ["Offset of field: _z_locator_array_t::_len"]
        [::std::mem::offset_of!(_z_locator_array_t, _len) - 0usize];
    ["Offset of field: _z_locator_array_t::_val"]
        [::std::mem::offset_of!(_z_locator_array_t, _val) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_endpoint_t {
    pub _locator: _z_locator_t,
    pub _config: _z_str_intmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_endpoint_t"][::std::mem::size_of::<_z_endpoint_t>() - 128usize];
    ["Alignment of _z_endpoint_t"][::std::mem::align_of::<_z_endpoint_t>() - 8usize];
    ["Offset of field: _z_endpoint_t::_locator"]
        [::std::mem::offset_of!(_z_endpoint_t, _locator) - 0usize];
    ["Offset of field: _z_endpoint_t::_config"]
        [::std::mem::offset_of!(_z_endpoint_t, _config) - 96usize];
};
unsafe extern "C" {
    pub fn _z_endpoint_to_string(e: *const _z_endpoint_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_from_string(ep: *mut _z_endpoint_t, s: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_clear(ep: *mut _z_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_endpoint_free(ep: *mut *mut _z_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_endpoint_parse_host(addr: *mut _z_string_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_endpoint_parse_port(addr: *mut _z_string_t) -> *mut ::std::os::raw::c_char;
}
#[doc = " Zenoh-net properties are represented as int-string map."]
pub type _z_config_t = _z_str_intmap_t;
unsafe extern "C" {
    #[doc = " Initialize a new empty map of properties."]
    pub fn _z_config_init(ps: *mut _z_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Insert a property with a given key to a properties map.\n If a property with the same key already exists in the properties map, it is replaced.\n\n Parameters:\n   ps: A pointer to the properties map.\n   key: The key of the property to add.\n   value: The value of the property to add."]
    pub fn _zp_config_insert(
        ps: *mut _z_config_t,
        key: u8,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _zp_config_insert_string(
        ps: *mut _z_config_t,
        key: u8,
        value: *const _z_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Get the property with the given key from a properties map.\n\n Parameters:\n     ps: A pointer to properties map.\n     key: The key of the property.\n\n Returns:\n     The value of the property with key ``key`` in properties map ``ps``."]
    pub fn _z_config_get(ps: *const _z_config_t, key: u8) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn _z_config_get_all(
        ps: *const _z_config_t,
        locators: *mut _z_string_svec_t,
        key: u8,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_tcp_socket_t {
    pub _sock: _z_sys_net_socket_t,
    pub _rep: _z_sys_net_endpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_tcp_socket_t"][::std::mem::size_of::<_z_tcp_socket_t>() - 16usize];
    ["Alignment of _z_tcp_socket_t"][::std::mem::align_of::<_z_tcp_socket_t>() - 8usize];
    ["Offset of field: _z_tcp_socket_t::_sock"]
        [::std::mem::offset_of!(_z_tcp_socket_t, _sock) - 0usize];
    ["Offset of field: _z_tcp_socket_t::_rep"]
        [::std::mem::offset_of!(_z_tcp_socket_t, _rep) - 8usize];
};
unsafe extern "C" {
    pub fn _z_create_endpoint_tcp(
        ep: *mut _z_sys_net_endpoint_t,
        s_address: *const ::std::os::raw::c_char,
        s_port: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_free_endpoint_tcp(ep: *mut _z_sys_net_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_open_tcp(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_tcp(sock: *mut _z_sys_net_socket_t, rep: _z_sys_net_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_close_tcp(sock: *mut _z_sys_net_socket_t);
}
unsafe extern "C" {
    pub fn _z_read_exact_tcp(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_read_tcp(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_send_tcp(sock: _z_sys_net_socket_t, ptr: *const u8, len: usize) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_udp_socket_t {
    pub _sock: _z_sys_net_socket_t,
    pub _msock: _z_sys_net_socket_t,
    pub _rep: _z_sys_net_endpoint_t,
    pub _lep: _z_sys_net_endpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_udp_socket_t"][::std::mem::size_of::<_z_udp_socket_t>() - 24usize];
    ["Alignment of _z_udp_socket_t"][::std::mem::align_of::<_z_udp_socket_t>() - 8usize];
    ["Offset of field: _z_udp_socket_t::_sock"]
        [::std::mem::offset_of!(_z_udp_socket_t, _sock) - 0usize];
    ["Offset of field: _z_udp_socket_t::_msock"]
        [::std::mem::offset_of!(_z_udp_socket_t, _msock) - 4usize];
    ["Offset of field: _z_udp_socket_t::_rep"]
        [::std::mem::offset_of!(_z_udp_socket_t, _rep) - 8usize];
    ["Offset of field: _z_udp_socket_t::_lep"]
        [::std::mem::offset_of!(_z_udp_socket_t, _lep) - 16usize];
};
unsafe extern "C" {
    pub fn _z_create_endpoint_udp(
        ep: *mut _z_sys_net_endpoint_t,
        s_address: *const ::std::os::raw::c_char,
        s_port: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_free_endpoint_udp(ep: *mut _z_sys_net_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_open_udp_unicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_udp_unicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_close_udp_unicast(sock: *mut _z_sys_net_socket_t);
}
unsafe extern "C" {
    pub fn _z_read_exact_udp_unicast(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_read_udp_unicast(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_send_udp_unicast(
        sock: _z_sys_net_socket_t,
        ptr: *const u8,
        len: usize,
        rep: _z_sys_net_endpoint_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_open_udp_multicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        lep: *mut _z_sys_net_endpoint_t,
        tout: u32,
        iface: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_udp_multicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
        iface: *const ::std::os::raw::c_char,
        join: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_close_udp_multicast(
        sockrecv: *mut _z_sys_net_socket_t,
        socksend: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        lep: _z_sys_net_endpoint_t,
    );
}
unsafe extern "C" {
    pub fn _z_read_exact_udp_multicast(
        sock: _z_sys_net_socket_t,
        ptr: *mut u8,
        len: usize,
        lep: _z_sys_net_endpoint_t,
        ep: *mut _z_slice_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_read_udp_multicast(
        sock: _z_sys_net_socket_t,
        ptr: *mut u8,
        len: usize,
        lep: _z_sys_net_endpoint_t,
        ep: *mut _z_slice_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_send_udp_multicast(
        sock: _z_sys_net_socket_t,
        ptr: *const u8,
        len: usize,
        rep: _z_sys_net_endpoint_t,
    ) -> usize;
}
pub const _z_link_cap_transport_t_Z_LINK_CAP_TRANSPORT_UNICAST: _z_link_cap_transport_t = 0;
pub const _z_link_cap_transport_t_Z_LINK_CAP_TRANSPORT_MULTICAST: _z_link_cap_transport_t = 1;
pub const _z_link_cap_transport_t_Z_LINK_CAP_TRANSPORT_RAWETH: _z_link_cap_transport_t = 2;
#[doc = " Link transport capability enum.\n\n Enumerators:\n     Z_LINK_CAP_TRANSPORT_UNICAST: Link has unicast capabilities.\n     Z_LINK_CAP_TRANSPORT_MULTICAST: Link has multicast capabilities."]
pub type _z_link_cap_transport_t = ::std::os::raw::c_uint;
pub const _z_link_cap_flow_t_Z_LINK_CAP_FLOW_DATAGRAM: _z_link_cap_flow_t = 0;
pub const _z_link_cap_flow_t_Z_LINK_CAP_FLOW_STREAM: _z_link_cap_flow_t = 1;
#[doc = " Link flow capability enum.\n\n Enumerators:\n     Z_LINK_CAP_FLOW_STREAM: Link use datagrams.\n     Z_LINK_CAP_FLOW_DATAGRAM: Link use byte stream."]
pub type _z_link_cap_flow_t = ::std::os::raw::c_uint;
#[doc = " Link capabilities, stored as a register-like object.\n\n Fields:\n     transport: 2 bits, see _z_link_cap_transport_t enum.\n     flow: 1 bit, see _z_link_cap_flow_t enum.\n     reliable: 1 bit, 1 if the link is reliable (network definition)\n     reserved: 4 bits, reserved for future use"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_link_capabilities_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_capabilities_t"][::std::mem::size_of::<_z_link_capabilities_t>() - 1usize];
    ["Alignment of _z_link_capabilities_t"]
        [::std::mem::align_of::<_z_link_capabilities_t>() - 1usize];
};
impl _z_link_capabilities_t {
    #[inline]
    pub fn _transport(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set__transport(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _transport_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__transport_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _flow(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__flow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flow_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__flow_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _is_reliable(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__is_reliable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _is_reliable_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__is_reliable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _reserved_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__reserved_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _transport: u8,
        _flow: u8,
        _is_reliable: u8,
        _reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let _transport: u8 = unsafe { ::std::mem::transmute(_transport) };
            _transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _flow: u8 = unsafe { ::std::mem::transmute(_flow) };
            _flow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _is_reliable: u8 = unsafe { ::std::mem::transmute(_is_reliable) };
            _is_reliable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _reserved: u8 = unsafe { ::std::mem::transmute(_reserved) };
            _reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type _z_f_link_open =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t) -> z_result_t>;
pub type _z_f_link_listen =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t) -> z_result_t>;
pub type _z_f_link_close = ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t)>;
pub type _z_f_link_write = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *const u8,
        len: usize,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize,
>;
pub type _z_f_link_write_all = ::std::option::Option<
    unsafe extern "C" fn(self_: *const _z_link_t, ptr: *const u8, len: usize) -> usize,
>;
pub type _z_f_link_read = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *mut u8,
        len: usize,
        addr: *mut _z_slice_t,
    ) -> usize,
>;
pub type _z_f_link_read_exact = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *mut u8,
        len: usize,
        addr: *mut _z_slice_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize,
>;
pub type _z_f_link_read_socket = ::std::option::Option<
    unsafe extern "C" fn(socket: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize,
>;
pub type _z_f_link_free = ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t)>;
pub const _z_link_type_e__Z_LINK_TYPE_TCP: _z_link_type_e = 0;
pub const _z_link_type_e__Z_LINK_TYPE_UDP: _z_link_type_e = 1;
pub const _z_link_type_e__Z_LINK_TYPE_BT: _z_link_type_e = 2;
pub const _z_link_type_e__Z_LINK_TYPE_SERIAL: _z_link_type_e = 3;
pub const _z_link_type_e__Z_LINK_TYPE_WS: _z_link_type_e = 4;
pub const _z_link_type_e__Z_LINK_TYPE_TLS: _z_link_type_e = 5;
pub const _z_link_type_e__Z_LINK_TYPE_RAWETH: _z_link_type_e = 6;
pub type _z_link_type_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_link_t {
    pub _endpoint: _z_endpoint_t,
    pub _type: ::std::os::raw::c_int,
    pub _socket: _z_link_t__bindgen_ty_1,
    pub _open_f: _z_f_link_open,
    pub _listen_f: _z_f_link_listen,
    pub _close_f: _z_f_link_close,
    pub _write_f: _z_f_link_write,
    pub _write_all_f: _z_f_link_write_all,
    pub _read_f: _z_f_link_read,
    pub _read_exact_f: _z_f_link_read_exact,
    pub _read_socket_f: _z_f_link_read_socket,
    pub _free_f: _z_f_link_free,
    pub _mtu: u16,
    pub _cap: _z_link_capabilities_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_link_t__bindgen_ty_1 {
    pub _tcp: _z_tcp_socket_t,
    pub _udp: _z_udp_socket_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_t__bindgen_ty_1"][::std::mem::size_of::<_z_link_t__bindgen_ty_1>() - 24usize];
    ["Alignment of _z_link_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_link_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_link_t__bindgen_ty_1::_tcp"]
        [::std::mem::offset_of!(_z_link_t__bindgen_ty_1, _tcp) - 0usize];
    ["Offset of field: _z_link_t__bindgen_ty_1::_udp"]
        [::std::mem::offset_of!(_z_link_t__bindgen_ty_1, _udp) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_t"][::std::mem::size_of::<_z_link_t>() - 240usize];
    ["Alignment of _z_link_t"][::std::mem::align_of::<_z_link_t>() - 8usize];
    ["Offset of field: _z_link_t::_endpoint"]
        [::std::mem::offset_of!(_z_link_t, _endpoint) - 0usize];
    ["Offset of field: _z_link_t::_type"][::std::mem::offset_of!(_z_link_t, _type) - 128usize];
    ["Offset of field: _z_link_t::_socket"][::std::mem::offset_of!(_z_link_t, _socket) - 136usize];
    ["Offset of field: _z_link_t::_open_f"][::std::mem::offset_of!(_z_link_t, _open_f) - 160usize];
    ["Offset of field: _z_link_t::_listen_f"]
        [::std::mem::offset_of!(_z_link_t, _listen_f) - 168usize];
    ["Offset of field: _z_link_t::_close_f"]
        [::std::mem::offset_of!(_z_link_t, _close_f) - 176usize];
    ["Offset of field: _z_link_t::_write_f"]
        [::std::mem::offset_of!(_z_link_t, _write_f) - 184usize];
    ["Offset of field: _z_link_t::_write_all_f"]
        [::std::mem::offset_of!(_z_link_t, _write_all_f) - 192usize];
    ["Offset of field: _z_link_t::_read_f"][::std::mem::offset_of!(_z_link_t, _read_f) - 200usize];
    ["Offset of field: _z_link_t::_read_exact_f"]
        [::std::mem::offset_of!(_z_link_t, _read_exact_f) - 208usize];
    ["Offset of field: _z_link_t::_read_socket_f"]
        [::std::mem::offset_of!(_z_link_t, _read_socket_f) - 216usize];
    ["Offset of field: _z_link_t::_free_f"][::std::mem::offset_of!(_z_link_t, _free_f) - 224usize];
    ["Offset of field: _z_link_t::_mtu"][::std::mem::offset_of!(_z_link_t, _mtu) - 232usize];
    ["Offset of field: _z_link_t::_cap"][::std::mem::offset_of!(_z_link_t, _cap) - 234usize];
};
unsafe extern "C" {
    pub fn _z_link_clear(zl: *mut _z_link_t);
}
unsafe extern "C" {
    pub fn _z_link_free(zl: *mut *mut _z_link_t);
}
unsafe extern "C" {
    pub fn _z_open_socket(
        locator: *const _z_string_t,
        session_cfg: *const _z_config_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_open_link(
        zl: *mut _z_link_t,
        locator: *const _z_string_t,
        session_cfg: *const _z_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_link(
        zl: *mut _z_link_t,
        locator: *const _z_string_t,
        session_cfg: *const _z_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_link_send_wbuf(
        zl: *const _z_link_t,
        wbf: *const _z_wbuf_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_link_recv_zbuf(
        zl: *const _z_link_t,
        zbf: *mut _z_zbuf_t,
        addr: *mut _z_slice_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_link_recv_exact_zbuf(
        zl: *const _z_link_t,
        zbf: *mut _z_zbuf_t,
        len: usize,
        addr: *mut _z_slice_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_link_socket_recv_zbuf(
        link: *const _z_link_t,
        zbf: *mut _z_zbuf_t,
        socket: _z_sys_net_socket_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_link_get_socket(link: *const _z_link_t) -> *const _z_sys_net_socket_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_tcp_valid(ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_peer_tcp(
        endpoint: *mut _z_endpoint_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_link_tcp(zl: *mut _z_link_t, ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_udp_unicast_valid(ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_link_udp_unicast(zl: *mut _z_link_t, ep: _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_udp_multicast_valid(ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_link_udp_multicast(zl: *mut _z_link_t, ep: _z_endpoint_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_s_msg_scout_t {
    pub _zid: _z_id_t,
    pub _what: z_what_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_s_msg_scout_t"][::std::mem::size_of::<_z_s_msg_scout_t>() - 24usize];
    ["Alignment of _z_s_msg_scout_t"][::std::mem::align_of::<_z_s_msg_scout_t>() - 4usize];
    ["Offset of field: _z_s_msg_scout_t::_zid"]
        [::std::mem::offset_of!(_z_s_msg_scout_t, _zid) - 0usize];
    ["Offset of field: _z_s_msg_scout_t::_what"]
        [::std::mem::offset_of!(_z_s_msg_scout_t, _what) - 16usize];
    ["Offset of field: _z_s_msg_scout_t::_version"]
        [::std::mem::offset_of!(_z_s_msg_scout_t, _version) - 20usize];
};
unsafe extern "C" {
    pub fn _z_s_msg_scout_clear(msg: *mut _z_s_msg_scout_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_s_msg_hello_t {
    pub _zid: _z_id_t,
    pub _locators: _z_locator_array_t,
    pub _whatami: z_whatami_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_s_msg_hello_t"][::std::mem::size_of::<_z_s_msg_hello_t>() - 40usize];
    ["Alignment of _z_s_msg_hello_t"][::std::mem::align_of::<_z_s_msg_hello_t>() - 8usize];
    ["Offset of field: _z_s_msg_hello_t::_zid"]
        [::std::mem::offset_of!(_z_s_msg_hello_t, _zid) - 0usize];
    ["Offset of field: _z_s_msg_hello_t::_locators"]
        [::std::mem::offset_of!(_z_s_msg_hello_t, _locators) - 16usize];
    ["Offset of field: _z_s_msg_hello_t::_whatami"]
        [::std::mem::offset_of!(_z_s_msg_hello_t, _whatami) - 32usize];
    ["Offset of field: _z_s_msg_hello_t::_version"]
        [::std::mem::offset_of!(_z_s_msg_hello_t, _version) - 36usize];
};
unsafe extern "C" {
    pub fn _z_s_msg_hello_clear(msg: *mut _z_s_msg_hello_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_coundit_sn_t {
    pub _reliable: _z_zint_t,
    pub _best_effort: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_coundit_sn_t"][::std::mem::size_of::<_z_coundit_sn_t>() - 16usize];
    ["Alignment of _z_coundit_sn_t"][::std::mem::align_of::<_z_coundit_sn_t>() - 8usize];
    ["Offset of field: _z_coundit_sn_t::_reliable"]
        [::std::mem::offset_of!(_z_coundit_sn_t, _reliable) - 0usize];
    ["Offset of field: _z_coundit_sn_t::_best_effort"]
        [::std::mem::offset_of!(_z_coundit_sn_t, _best_effort) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_conduit_sn_list_t {
    pub _val: _z_conduit_sn_list_t__bindgen_ty_1,
    pub _is_qos: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_conduit_sn_list_t__bindgen_ty_1 {
    pub _plain: _z_coundit_sn_t,
    pub _qos: [_z_coundit_sn_t; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_conduit_sn_list_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_conduit_sn_list_t__bindgen_ty_1>() - 128usize];
    ["Alignment of _z_conduit_sn_list_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_conduit_sn_list_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_conduit_sn_list_t__bindgen_ty_1::_plain"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t__bindgen_ty_1, _plain) - 0usize];
    ["Offset of field: _z_conduit_sn_list_t__bindgen_ty_1::_qos"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t__bindgen_ty_1, _qos) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_conduit_sn_list_t"][::std::mem::size_of::<_z_conduit_sn_list_t>() - 136usize];
    ["Alignment of _z_conduit_sn_list_t"][::std::mem::align_of::<_z_conduit_sn_list_t>() - 8usize];
    ["Offset of field: _z_conduit_sn_list_t::_val"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t, _val) - 0usize];
    ["Offset of field: _z_conduit_sn_list_t::_is_qos"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t, _is_qos) - 128usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_t_msg_join_t {
    pub _zid: _z_id_t,
    pub _lease: _z_zint_t,
    pub _next_sn: _z_conduit_sn_list_t,
    pub _batch_size: u16,
    pub _whatami: z_whatami_t,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _version: u8,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_join_t"][::std::mem::size_of::<_z_t_msg_join_t>() - 176usize];
    ["Alignment of _z_t_msg_join_t"][::std::mem::align_of::<_z_t_msg_join_t>() - 8usize];
    ["Offset of field: _z_t_msg_join_t::_zid"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _zid) - 0usize];
    ["Offset of field: _z_t_msg_join_t::_lease"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _lease) - 16usize];
    ["Offset of field: _z_t_msg_join_t::_next_sn"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _next_sn) - 24usize];
    ["Offset of field: _z_t_msg_join_t::_batch_size"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _batch_size) - 160usize];
    ["Offset of field: _z_t_msg_join_t::_whatami"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _whatami) - 164usize];
    ["Offset of field: _z_t_msg_join_t::_req_id_res"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _req_id_res) - 168usize];
    ["Offset of field: _z_t_msg_join_t::_seq_num_res"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _seq_num_res) - 169usize];
    ["Offset of field: _z_t_msg_join_t::_version"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _version) - 170usize];
    ["Offset of field: _z_t_msg_join_t::_patch"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _patch) - 171usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_join_clear(msg: *mut _z_t_msg_join_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_init_t {
    pub _zid: _z_id_t,
    pub _cookie: _z_slice_t,
    pub _batch_size: u16,
    pub _whatami: z_whatami_t,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _version: u8,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_init_t"][::std::mem::size_of::<_z_t_msg_init_t>() - 64usize];
    ["Alignment of _z_t_msg_init_t"][::std::mem::align_of::<_z_t_msg_init_t>() - 8usize];
    ["Offset of field: _z_t_msg_init_t::_zid"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _zid) - 0usize];
    ["Offset of field: _z_t_msg_init_t::_cookie"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _cookie) - 16usize];
    ["Offset of field: _z_t_msg_init_t::_batch_size"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _batch_size) - 48usize];
    ["Offset of field: _z_t_msg_init_t::_whatami"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _whatami) - 52usize];
    ["Offset of field: _z_t_msg_init_t::_req_id_res"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _req_id_res) - 56usize];
    ["Offset of field: _z_t_msg_init_t::_seq_num_res"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _seq_num_res) - 57usize];
    ["Offset of field: _z_t_msg_init_t::_version"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _version) - 58usize];
    ["Offset of field: _z_t_msg_init_t::_patch"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _patch) - 59usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_init_clear(msg: *mut _z_t_msg_init_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_open_t {
    pub _lease: _z_zint_t,
    pub _initial_sn: _z_zint_t,
    pub _cookie: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_open_t"][::std::mem::size_of::<_z_t_msg_open_t>() - 48usize];
    ["Alignment of _z_t_msg_open_t"][::std::mem::align_of::<_z_t_msg_open_t>() - 8usize];
    ["Offset of field: _z_t_msg_open_t::_lease"]
        [::std::mem::offset_of!(_z_t_msg_open_t, _lease) - 0usize];
    ["Offset of field: _z_t_msg_open_t::_initial_sn"]
        [::std::mem::offset_of!(_z_t_msg_open_t, _initial_sn) - 8usize];
    ["Offset of field: _z_t_msg_open_t::_cookie"]
        [::std::mem::offset_of!(_z_t_msg_open_t, _cookie) - 16usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_open_clear(msg: *mut _z_t_msg_open_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_close_t {
    pub _reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_close_t"][::std::mem::size_of::<_z_t_msg_close_t>() - 1usize];
    ["Alignment of _z_t_msg_close_t"][::std::mem::align_of::<_z_t_msg_close_t>() - 1usize];
    ["Offset of field: _z_t_msg_close_t::_reason"]
        [::std::mem::offset_of!(_z_t_msg_close_t, _reason) - 0usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_close_clear(msg: *mut _z_t_msg_close_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_keep_alive_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_keep_alive_t"][::std::mem::size_of::<_z_t_msg_keep_alive_t>() - 1usize];
    ["Alignment of _z_t_msg_keep_alive_t"]
        [::std::mem::align_of::<_z_t_msg_keep_alive_t>() - 1usize];
    ["Offset of field: _z_t_msg_keep_alive_t::__dummy"]
        [::std::mem::offset_of!(_z_t_msg_keep_alive_t, __dummy) - 0usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_keep_alive_clear(msg: *mut _z_t_msg_keep_alive_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_frame_t {
    pub _payload: *mut _z_zbuf_t,
    pub _sn: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_frame_t"][::std::mem::size_of::<_z_t_msg_frame_t>() - 16usize];
    ["Alignment of _z_t_msg_frame_t"][::std::mem::align_of::<_z_t_msg_frame_t>() - 8usize];
    ["Offset of field: _z_t_msg_frame_t::_payload"]
        [::std::mem::offset_of!(_z_t_msg_frame_t, _payload) - 0usize];
    ["Offset of field: _z_t_msg_frame_t::_sn"]
        [::std::mem::offset_of!(_z_t_msg_frame_t, _sn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_frame_clear(msg: *mut _z_t_msg_frame_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_fragment_t {
    pub _payload: _z_slice_t,
    pub _sn: _z_zint_t,
    pub first: bool,
    pub drop: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_fragment_t"][::std::mem::size_of::<_z_t_msg_fragment_t>() - 48usize];
    ["Alignment of _z_t_msg_fragment_t"][::std::mem::align_of::<_z_t_msg_fragment_t>() - 8usize];
    ["Offset of field: _z_t_msg_fragment_t::_payload"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, _payload) - 0usize];
    ["Offset of field: _z_t_msg_fragment_t::_sn"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, _sn) - 32usize];
    ["Offset of field: _z_t_msg_fragment_t::first"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, first) - 40usize];
    ["Offset of field: _z_t_msg_fragment_t::drop"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, drop) - 41usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_fragment_clear(msg: *mut _z_t_msg_fragment_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_transport_body_t {
    pub _join: _z_t_msg_join_t,
    pub _init: _z_t_msg_init_t,
    pub _open: _z_t_msg_open_t,
    pub _close: _z_t_msg_close_t,
    pub _keep_alive: _z_t_msg_keep_alive_t,
    pub _frame: _z_t_msg_frame_t,
    pub _fragment: _z_t_msg_fragment_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_body_t"][::std::mem::size_of::<_z_transport_body_t>() - 176usize];
    ["Alignment of _z_transport_body_t"][::std::mem::align_of::<_z_transport_body_t>() - 8usize];
    ["Offset of field: _z_transport_body_t::_join"]
        [::std::mem::offset_of!(_z_transport_body_t, _join) - 0usize];
    ["Offset of field: _z_transport_body_t::_init"]
        [::std::mem::offset_of!(_z_transport_body_t, _init) - 0usize];
    ["Offset of field: _z_transport_body_t::_open"]
        [::std::mem::offset_of!(_z_transport_body_t, _open) - 0usize];
    ["Offset of field: _z_transport_body_t::_close"]
        [::std::mem::offset_of!(_z_transport_body_t, _close) - 0usize];
    ["Offset of field: _z_transport_body_t::_keep_alive"]
        [::std::mem::offset_of!(_z_transport_body_t, _keep_alive) - 0usize];
    ["Offset of field: _z_transport_body_t::_frame"]
        [::std::mem::offset_of!(_z_transport_body_t, _frame) - 0usize];
    ["Offset of field: _z_transport_body_t::_fragment"]
        [::std::mem::offset_of!(_z_transport_body_t, _fragment) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_message_t {
    pub _body: _z_transport_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_message_t"][::std::mem::size_of::<_z_transport_message_t>() - 184usize];
    ["Alignment of _z_transport_message_t"]
        [::std::mem::align_of::<_z_transport_message_t>() - 8usize];
    ["Offset of field: _z_transport_message_t::_body"]
        [::std::mem::offset_of!(_z_transport_message_t, _body) - 0usize];
    ["Offset of field: _z_transport_message_t::_header"]
        [::std::mem::offset_of!(_z_transport_message_t, _header) - 176usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_clear(msg: *mut _z_transport_message_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_get_reliability(msg: *mut _z_transport_message_t) -> z_reliability_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_join(
        whatami: z_whatami_t,
        lease: _z_zint_t,
        zid: _z_id_t,
        next_sn: _z_conduit_sn_list_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_init_syn(whatami: z_whatami_t, zid: _z_id_t) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_init_ack(
        whatami: z_whatami_t,
        zid: _z_id_t,
        cookie: _z_slice_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_open_syn(
        lease: _z_zint_t,
        initial_sn: _z_zint_t,
        cookie: _z_slice_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_open_ack(
        lease: _z_zint_t,
        initial_sn: _z_zint_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_close(reason: u8, link_only: bool) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_keep_alive() -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_frame(
        sn: _z_zint_t,
        payload: *mut _z_zbuf_t,
        reliability: z_reliability_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_frame_header(
        sn: _z_zint_t,
        reliability: z_reliability_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_fragment_header(
        sn: _z_zint_t,
        reliability: z_reliability_t,
        is_last: bool,
        first: bool,
        drop: bool,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_fragment(
        sn: _z_zint_t,
        messages: _z_slice_t,
        reliability: z_reliability_t,
        is_last: bool,
        first: bool,
        drop: bool,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_copy(clone: *mut _z_transport_message_t, msg: *mut _z_transport_message_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_join(clone: *mut _z_t_msg_join_t, msg: *mut _z_t_msg_join_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_init(clone: *mut _z_t_msg_init_t, msg: *mut _z_t_msg_init_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_open(clone: *mut _z_t_msg_open_t, msg: *mut _z_t_msg_open_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_close(clone: *mut _z_t_msg_close_t, msg: *mut _z_t_msg_close_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_keep_alive(
        clone: *mut _z_t_msg_keep_alive_t,
        msg: *mut _z_t_msg_keep_alive_t,
    );
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_frame(clone: *mut _z_t_msg_frame_t, msg: *mut _z_t_msg_frame_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_scouting_body_t {
    pub _scout: _z_s_msg_scout_t,
    pub _hello: _z_s_msg_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_scouting_body_t"][::std::mem::size_of::<_z_scouting_body_t>() - 40usize];
    ["Alignment of _z_scouting_body_t"][::std::mem::align_of::<_z_scouting_body_t>() - 8usize];
    ["Offset of field: _z_scouting_body_t::_scout"]
        [::std::mem::offset_of!(_z_scouting_body_t, _scout) - 0usize];
    ["Offset of field: _z_scouting_body_t::_hello"]
        [::std::mem::offset_of!(_z_scouting_body_t, _hello) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_scouting_message_t {
    pub _body: _z_scouting_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_scouting_message_t"][::std::mem::size_of::<_z_scouting_message_t>() - 48usize];
    ["Alignment of _z_scouting_message_t"]
        [::std::mem::align_of::<_z_scouting_message_t>() - 8usize];
    ["Offset of field: _z_scouting_message_t::_body"]
        [::std::mem::offset_of!(_z_scouting_message_t, _body) - 0usize];
    ["Offset of field: _z_scouting_message_t::_header"]
        [::std::mem::offset_of!(_z_scouting_message_t, _header) - 40usize];
};
unsafe extern "C" {
    pub fn _z_s_msg_clear(msg: *mut _z_scouting_message_t);
}
unsafe extern "C" {
    pub fn _z_s_msg_make_scout(what: z_what_t, zid: _z_id_t) -> _z_scouting_message_t;
}
unsafe extern "C" {
    pub fn _z_s_msg_make_hello(
        whatami: z_whatami_t,
        zid: _z_id_t,
        locators: _z_locator_array_t,
    ) -> _z_scouting_message_t;
}
unsafe extern "C" {
    pub fn _z_s_msg_copy(clone: *mut _z_scouting_message_t, msg: *mut _z_scouting_message_t);
}
unsafe extern "C" {
    pub fn _z_s_msg_copy_scout(clone: *mut _z_s_msg_scout_t, msg: *mut _z_s_msg_scout_t);
}
unsafe extern "C" {
    pub fn _z_s_msg_copy_hello(clone: *mut _z_s_msg_hello_t, msg: *mut _z_s_msg_hello_t);
}
pub const _z_dbuf_state_e__Z_DBUF_STATE_NULL: _z_dbuf_state_e = 0;
pub const _z_dbuf_state_e__Z_DBUF_STATE_INIT: _z_dbuf_state_e = 1;
pub const _z_dbuf_state_e__Z_DBUF_STATE_OVERFLOW: _z_dbuf_state_e = 2;
pub type _z_dbuf_state_e = ::std::os::raw::c_uint;
pub const _z_batching_state_e__Z_BATCHING_IDLE: _z_batching_state_e = 0;
pub const _z_batching_state_e__Z_BATCHING_ACTIVE: _z_batching_state_e = 1;
pub type _z_batching_state_e = ::std::os::raw::c_uint;
pub type _z_resource_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_peer_common_t {
    pub _remote_zid: _z_id_t,
    pub _received: bool,
    pub _remote_resources: *mut _z_resource_slist_t,
    pub _state_reliable: u8,
    pub _state_best_effort: u8,
    pub _dbuf_reliable: _z_wbuf_t,
    pub _dbuf_best_effort: _z_wbuf_t,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_peer_common_t"]
        [::std::mem::size_of::<_z_transport_peer_common_t>() - 160usize];
    ["Alignment of _z_transport_peer_common_t"]
        [::std::mem::align_of::<_z_transport_peer_common_t>() - 8usize];
    ["Offset of field: _z_transport_peer_common_t::_remote_zid"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _remote_zid) - 0usize];
    ["Offset of field: _z_transport_peer_common_t::_received"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _received) - 16usize];
    ["Offset of field: _z_transport_peer_common_t::_remote_resources"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _remote_resources) - 24usize];
    ["Offset of field: _z_transport_peer_common_t::_state_reliable"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _state_reliable) - 32usize];
    ["Offset of field: _z_transport_peer_common_t::_state_best_effort"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _state_best_effort) - 33usize];
    ["Offset of field: _z_transport_peer_common_t::_dbuf_reliable"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _dbuf_reliable) - 40usize];
    ["Offset of field: _z_transport_peer_common_t::_dbuf_best_effort"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _dbuf_best_effort) - 96usize];
    ["Offset of field: _z_transport_peer_common_t::_patch"]
        [::std::mem::offset_of!(_z_transport_peer_common_t, _patch) - 152usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_common_clear(src: *mut _z_transport_peer_common_t);
}
unsafe extern "C" {
    pub fn _z_transport_peer_common_copy(
        dst: *mut _z_transport_peer_common_t,
        src: *const _z_transport_peer_common_t,
    );
}
unsafe extern "C" {
    pub fn _z_transport_peer_common_eq(
        left: *const _z_transport_peer_common_t,
        right: *const _z_transport_peer_common_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_peer_multicast_t {
    pub common: _z_transport_peer_common_t,
    pub _remote_addr: _z_slice_t,
    pub _sn_rx_sns: _z_conduit_sn_list_t,
    pub _sn_res: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _next_lease: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_peer_multicast_t"]
        [::std::mem::size_of::<_z_transport_peer_multicast_t>() - 352usize];
    ["Alignment of _z_transport_peer_multicast_t"]
        [::std::mem::align_of::<_z_transport_peer_multicast_t>() - 8usize];
    ["Offset of field: _z_transport_peer_multicast_t::common"]
        [::std::mem::offset_of!(_z_transport_peer_multicast_t, common) - 0usize];
    ["Offset of field: _z_transport_peer_multicast_t::_remote_addr"]
        [::std::mem::offset_of!(_z_transport_peer_multicast_t, _remote_addr) - 160usize];
    ["Offset of field: _z_transport_peer_multicast_t::_sn_rx_sns"]
        [::std::mem::offset_of!(_z_transport_peer_multicast_t, _sn_rx_sns) - 192usize];
    ["Offset of field: _z_transport_peer_multicast_t::_sn_res"]
        [::std::mem::offset_of!(_z_transport_peer_multicast_t, _sn_res) - 328usize];
    ["Offset of field: _z_transport_peer_multicast_t::_lease"]
        [::std::mem::offset_of!(_z_transport_peer_multicast_t, _lease) - 336usize];
    ["Offset of field: _z_transport_peer_multicast_t::_next_lease"]
        [::std::mem::offset_of!(_z_transport_peer_multicast_t, _next_lease) - 344usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_size(src: *const _z_transport_peer_multicast_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_clear(src: *mut _z_transport_peer_multicast_t);
}
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_copy(
        dst: *mut _z_transport_peer_multicast_t,
        src: *const _z_transport_peer_multicast_t,
    );
}
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_eq(
        left: *const _z_transport_peer_multicast_t,
        right: *const _z_transport_peer_multicast_t,
    ) -> bool;
}
pub type _z_transport_peer_multicast_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_multicast_t,
        right: *const _z_transport_peer_multicast_t,
    ) -> bool,
>;
pub type _z_transport_peer_multicast_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_multicast_t,
        right: *const _z_transport_peer_multicast_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_transport_peer_multicast_slist_t = _z_slist_t;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_INACTIVE: _z_unicast_peer_flow_state_e = 0;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_PENDING_SIZE: _z_unicast_peer_flow_state_e = 1;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_PENDING_DATA: _z_unicast_peer_flow_state_e = 2;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_READY: _z_unicast_peer_flow_state_e = 3;
pub type _z_unicast_peer_flow_state_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_peer_unicast_t {
    pub common: _z_transport_peer_common_t,
    pub _socket: _z_sys_net_socket_t,
    pub _sn_rx_reliable: _z_zint_t,
    pub _sn_rx_best_effort: _z_zint_t,
    pub _pending: bool,
    pub flow_state: u8,
    pub flow_curr_size: u16,
    pub flow_buff: _z_zbuf_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_peer_unicast_t"]
        [::std::mem::size_of::<_z_transport_peer_unicast_t>() - 240usize];
    ["Alignment of _z_transport_peer_unicast_t"]
        [::std::mem::align_of::<_z_transport_peer_unicast_t>() - 8usize];
    ["Offset of field: _z_transport_peer_unicast_t::common"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, common) - 0usize];
    ["Offset of field: _z_transport_peer_unicast_t::_socket"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, _socket) - 160usize];
    ["Offset of field: _z_transport_peer_unicast_t::_sn_rx_reliable"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, _sn_rx_reliable) - 168usize];
    ["Offset of field: _z_transport_peer_unicast_t::_sn_rx_best_effort"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, _sn_rx_best_effort) - 176usize];
    ["Offset of field: _z_transport_peer_unicast_t::_pending"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, _pending) - 184usize];
    ["Offset of field: _z_transport_peer_unicast_t::flow_state"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, flow_state) - 185usize];
    ["Offset of field: _z_transport_peer_unicast_t::flow_curr_size"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, flow_curr_size) - 186usize];
    ["Offset of field: _z_transport_peer_unicast_t::flow_buff"]
        [::std::mem::offset_of!(_z_transport_peer_unicast_t, flow_buff) - 192usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_clear(src: *mut _z_transport_peer_unicast_t);
}
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_copy(
        dst: *mut _z_transport_peer_unicast_t,
        src: *const _z_transport_peer_unicast_t,
    );
}
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_size(src: *const _z_transport_peer_unicast_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_eq(
        left: *const _z_transport_peer_unicast_t,
        right: *const _z_transport_peer_unicast_t,
    ) -> bool;
}
pub type _z_transport_peer_unicast_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_unicast_t,
        right: *const _z_transport_peer_unicast_t,
    ) -> bool,
>;
pub type _z_transport_peer_unicast_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_unicast_t,
        right: *const _z_transport_peer_unicast_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_transport_peer_unicast_slist_t = _z_slist_t;
unsafe extern "C" {
    pub fn _z_session_clear(zn: *mut _z_session_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_rc_t {
    pub _val: *mut _z_session_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_rc_t"][::std::mem::size_of::<_z_session_rc_t>() - 16usize];
    ["Alignment of _z_session_rc_t"][::std::mem::align_of::<_z_session_rc_t>() - 8usize];
    ["Offset of field: _z_session_rc_t::_val"]
        [::std::mem::offset_of!(_z_session_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_session_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_weak_t {
    pub _val: *mut _z_session_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_weak_t"][::std::mem::size_of::<_z_session_weak_t>() - 16usize];
    ["Alignment of _z_session_weak_t"][::std::mem::align_of::<_z_session_weak_t>() - 8usize];
    ["Offset of field: _z_session_weak_t::_val"]
        [::std::mem::offset_of!(_z_session_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_session_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_common_t {
    pub _session: _z_session_weak_t,
    pub _link: *mut _z_link_t,
    pub _wbuf: _z_wbuf_t,
    pub _zbuf: _z_zbuf_t,
    pub _sn_res: _z_zint_t,
    pub _sn_tx_reliable: _z_zint_t,
    pub _sn_tx_best_effort: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _transmitted: bool,
    pub _mutex_rx: _z_mutex_t,
    pub _mutex_tx: _z_mutex_t,
    pub _mutex_peer: _z_mutex_rec_t,
    pub _read_task: *mut _z_task_t,
    pub _lease_task: *mut _z_task_t,
    pub _accept_task_running: *mut bool,
    pub _read_task_running: bool,
    pub _lease_task_running: bool,
    pub _batch_state: u8,
    pub _batch_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_common_t"][::std::mem::size_of::<_z_transport_common_t>() - 216usize];
    ["Alignment of _z_transport_common_t"]
        [::std::mem::align_of::<_z_transport_common_t>() - 8usize];
    ["Offset of field: _z_transport_common_t::_session"]
        [::std::mem::offset_of!(_z_transport_common_t, _session) - 0usize];
    ["Offset of field: _z_transport_common_t::_link"]
        [::std::mem::offset_of!(_z_transport_common_t, _link) - 16usize];
    ["Offset of field: _z_transport_common_t::_wbuf"]
        [::std::mem::offset_of!(_z_transport_common_t, _wbuf) - 24usize];
    ["Offset of field: _z_transport_common_t::_zbuf"]
        [::std::mem::offset_of!(_z_transport_common_t, _zbuf) - 80usize];
    ["Offset of field: _z_transport_common_t::_sn_res"]
        [::std::mem::offset_of!(_z_transport_common_t, _sn_res) - 128usize];
    ["Offset of field: _z_transport_common_t::_sn_tx_reliable"]
        [::std::mem::offset_of!(_z_transport_common_t, _sn_tx_reliable) - 136usize];
    ["Offset of field: _z_transport_common_t::_sn_tx_best_effort"]
        [::std::mem::offset_of!(_z_transport_common_t, _sn_tx_best_effort) - 144usize];
    ["Offset of field: _z_transport_common_t::_lease"]
        [::std::mem::offset_of!(_z_transport_common_t, _lease) - 152usize];
    ["Offset of field: _z_transport_common_t::_transmitted"]
        [::std::mem::offset_of!(_z_transport_common_t, _transmitted) - 160usize];
    ["Offset of field: _z_transport_common_t::_mutex_rx"]
        [::std::mem::offset_of!(_z_transport_common_t, _mutex_rx) - 164usize];
    ["Offset of field: _z_transport_common_t::_mutex_tx"]
        [::std::mem::offset_of!(_z_transport_common_t, _mutex_tx) - 168usize];
    ["Offset of field: _z_transport_common_t::_mutex_peer"]
        [::std::mem::offset_of!(_z_transport_common_t, _mutex_peer) - 172usize];
    ["Offset of field: _z_transport_common_t::_read_task"]
        [::std::mem::offset_of!(_z_transport_common_t, _read_task) - 176usize];
    ["Offset of field: _z_transport_common_t::_lease_task"]
        [::std::mem::offset_of!(_z_transport_common_t, _lease_task) - 184usize];
    ["Offset of field: _z_transport_common_t::_accept_task_running"]
        [::std::mem::offset_of!(_z_transport_common_t, _accept_task_running) - 192usize];
    ["Offset of field: _z_transport_common_t::_read_task_running"]
        [::std::mem::offset_of!(_z_transport_common_t, _read_task_running) - 200usize];
    ["Offset of field: _z_transport_common_t::_lease_task_running"]
        [::std::mem::offset_of!(_z_transport_common_t, _lease_task_running) - 201usize];
    ["Offset of field: _z_transport_common_t::_batch_state"]
        [::std::mem::offset_of!(_z_transport_common_t, _batch_state) - 202usize];
    ["Offset of field: _z_transport_common_t::_batch_count"]
        [::std::mem::offset_of!(_z_transport_common_t, _batch_count) - 208usize];
};
pub type _zp_f_send_tmsg = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut _z_transport_common_t,
        t_msg: *const _z_transport_message_t,
    ) -> z_result_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_unicast_t {
    pub _common: _z_transport_common_t,
    pub _peers: *mut _z_transport_peer_unicast_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_unicast_t"][::std::mem::size_of::<_z_transport_unicast_t>() - 224usize];
    ["Alignment of _z_transport_unicast_t"]
        [::std::mem::align_of::<_z_transport_unicast_t>() - 8usize];
    ["Offset of field: _z_transport_unicast_t::_common"]
        [::std::mem::offset_of!(_z_transport_unicast_t, _common) - 0usize];
    ["Offset of field: _z_transport_unicast_t::_peers"]
        [::std::mem::offset_of!(_z_transport_unicast_t, _peers) - 216usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_multicast_t {
    pub _common: _z_transport_common_t,
    pub _peers: *mut _z_transport_peer_multicast_slist_t,
    pub _send_f: _zp_f_send_tmsg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_multicast_t"]
        [::std::mem::size_of::<_z_transport_multicast_t>() - 232usize];
    ["Alignment of _z_transport_multicast_t"]
        [::std::mem::align_of::<_z_transport_multicast_t>() - 8usize];
    ["Offset of field: _z_transport_multicast_t::_common"]
        [::std::mem::offset_of!(_z_transport_multicast_t, _common) - 0usize];
    ["Offset of field: _z_transport_multicast_t::_peers"]
        [::std::mem::offset_of!(_z_transport_multicast_t, _peers) - 216usize];
    ["Offset of field: _z_transport_multicast_t::_send_f"]
        [::std::mem::offset_of!(_z_transport_multicast_t, _send_f) - 224usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_t {
    pub _transport: _z_transport_t__bindgen_ty_1,
    pub _type: _z_transport_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_transport_t__bindgen_ty_1 {
    pub _unicast: _z_transport_unicast_t,
    pub _multicast: _z_transport_multicast_t,
    pub _raweth: _z_transport_multicast_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_transport_t__bindgen_ty_1>() - 232usize];
    ["Alignment of _z_transport_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_transport_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_unicast"]
        [::std::mem::offset_of!(_z_transport_t__bindgen_ty_1, _unicast) - 0usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_multicast"]
        [::std::mem::offset_of!(_z_transport_t__bindgen_ty_1, _multicast) - 0usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_raweth"]
        [::std::mem::offset_of!(_z_transport_t__bindgen_ty_1, _raweth) - 0usize];
};
pub const _z_transport_t__Z_TRANSPORT_UNICAST_TYPE: _z_transport_t__bindgen_ty_2 = 0;
pub const _z_transport_t__Z_TRANSPORT_MULTICAST_TYPE: _z_transport_t__bindgen_ty_2 = 1;
pub const _z_transport_t__Z_TRANSPORT_RAWETH_TYPE: _z_transport_t__bindgen_ty_2 = 2;
pub const _z_transport_t__Z_TRANSPORT_NONE: _z_transport_t__bindgen_ty_2 = 3;
pub type _z_transport_t__bindgen_ty_2 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_t"][::std::mem::size_of::<_z_transport_t>() - 240usize];
    ["Alignment of _z_transport_t"][::std::mem::align_of::<_z_transport_t>() - 8usize];
    ["Offset of field: _z_transport_t::_transport"]
        [::std::mem::offset_of!(_z_transport_t, _transport) - 0usize];
    ["Offset of field: _z_transport_t::_type"]
        [::std::mem::offset_of!(_z_transport_t, _type) - 232usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_unicast_establish_param_t {
    pub _remote_zid: _z_id_t,
    pub _batch_size: u16,
    pub _initial_sn_rx: _z_zint_t,
    pub _initial_sn_tx: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _whatami: z_whatami_t,
    pub _key_id_res: u8,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _is_qos: bool,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_unicast_establish_param_t"]
        [::std::mem::size_of::<_z_transport_unicast_establish_param_t>() - 64usize];
    ["Alignment of _z_transport_unicast_establish_param_t"]
        [::std::mem::align_of::<_z_transport_unicast_establish_param_t>() - 8usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_remote_zid"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _remote_zid) - 0usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_batch_size"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _batch_size) - 16usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_initial_sn_rx"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _initial_sn_rx) - 24usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_initial_sn_tx"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _initial_sn_tx) - 32usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_lease"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _lease) - 40usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_whatami"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _whatami) - 48usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_key_id_res"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _key_id_res) - 52usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_req_id_res"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _req_id_res) - 53usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_seq_num_res"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _seq_num_res) - 54usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_is_qos"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _is_qos) - 55usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_patch"]
        [::std::mem::offset_of!(_z_transport_unicast_establish_param_t, _patch) - 56usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_multicast_establish_param_t {
    pub _initial_sn_tx: _z_conduit_sn_list_t,
    pub _seq_num_res: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_multicast_establish_param_t"]
        [::std::mem::size_of::<_z_transport_multicast_establish_param_t>() - 144usize];
    ["Alignment of _z_transport_multicast_establish_param_t"]
        [::std::mem::align_of::<_z_transport_multicast_establish_param_t>() - 8usize];
    ["Offset of field: _z_transport_multicast_establish_param_t::_initial_sn_tx"]
        [::std::mem::offset_of!(_z_transport_multicast_establish_param_t, _initial_sn_tx) - 0usize];
    ["Offset of field: _z_transport_multicast_establish_param_t::_seq_num_res"]
        [::std::mem::offset_of!(_z_transport_multicast_establish_param_t, _seq_num_res) - 136usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_add(
        ztu: *mut _z_transport_unicast_t,
        param: *mut _z_transport_unicast_establish_param_t,
        socket: _z_sys_net_socket_t,
        output_peer: *mut *mut _z_transport_peer_unicast_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_transport_get_common(zt: *mut _z_transport_t) -> *mut _z_transport_common_t;
}
unsafe extern "C" {
    pub fn _z_transport_close(zt: *mut _z_transport_t, reason: u8) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_transport_clear(zt: *mut _z_transport_t);
}
unsafe extern "C" {
    pub fn _z_transport_free(zt: *mut *mut _z_transport_t);
}
unsafe extern "C" {
    pub fn _z_transport_start_batching(zt: *mut _z_transport_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_transport_stop_batching(zt: *mut _z_transport_t);
}
pub const _z_peer_op_e__Z_PEER_OP_OPEN: _z_peer_op_e = 0;
pub const _z_peer_op_e__Z_PEER_OP_LISTEN: _z_peer_op_e = 1;
pub type _z_peer_op_e = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn _z_new_transport(
        zt: *mut _z_transport_t,
        bs: *const _z_id_t,
        locator: *const _z_string_t,
        mode: z_whatami_t,
        peer_op: ::std::os::raw::c_int,
        session_cfg: *const _z_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_peer(
        zt: *mut _z_transport_t,
        session_id: *const _z_id_t,
        locator: *const _z_string_t,
        session_cfg: *const _z_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_free_transport(zt: *mut *mut _z_transport_t);
}
#[doc = " The callback signature of the cleanup functions."]
pub type _z_drop_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
pub const _z_subscriber_kind_t__Z_SUBSCRIBER_KIND_SUBSCRIBER: _z_subscriber_kind_t = 0;
pub const _z_subscriber_kind_t__Z_SUBSCRIBER_KIND_LIVELINESS_SUBSCRIBER: _z_subscriber_kind_t = 1;
pub type _z_subscriber_kind_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_resource_t {
    pub _key: _z_keyexpr_t,
    pub _id: u16,
    pub _refcount: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_resource_t"][::std::mem::size_of::<_z_resource_t>() - 56usize];
    ["Alignment of _z_resource_t"][::std::mem::align_of::<_z_resource_t>() - 8usize];
    ["Offset of field: _z_resource_t::_key"][::std::mem::offset_of!(_z_resource_t, _key) - 0usize];
    ["Offset of field: _z_resource_t::_id"][::std::mem::offset_of!(_z_resource_t, _id) - 48usize];
    ["Offset of field: _z_resource_t::_refcount"]
        [::std::mem::offset_of!(_z_resource_t, _refcount) - 50usize];
};
unsafe extern "C" {
    pub fn _z_resource_eq(one: *const _z_resource_t, two: *const _z_resource_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_resource_clear(res: *mut _z_resource_t);
}
unsafe extern "C" {
    pub fn _z_resource_copy(dst: *mut _z_resource_t, src: *const _z_resource_t);
}
unsafe extern "C" {
    pub fn _z_resource_free(res: *mut *mut _z_resource_t);
}
unsafe extern "C" {
    pub fn _z_resource_size(p: *mut _z_resource_t) -> usize;
}
pub type _z_resource_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_resource_t, right: *const _z_resource_t) -> bool,
>;
pub type _z_resource_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_resource_t,
        right: *const _z_resource_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_keyexpr_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_keyexpr_t, right: *const _z_keyexpr_t) -> bool,
>;
pub type _z_keyexpr_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_keyexpr_t,
        right: *const _z_keyexpr_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_keyexpr_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_keyexpr_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_keyexpr_intmap_iterator_t = _z_int_void_map_iterator_t;
#[doc = " The callback signature of the functions handling data messages."]
pub type _z_closure_sample_callback_t = ::std::option::Option<
    unsafe extern "C" fn(sample: *mut _z_sample_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_t {
    pub _key: _z_keyexpr_t,
    pub _declared_key: _z_keyexpr_t,
    pub _key_id: u16,
    pub _id: u32,
    pub _callback: _z_closure_sample_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _arg: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_t"][::std::mem::size_of::<_z_subscription_t>() - 128usize];
    ["Alignment of _z_subscription_t"][::std::mem::align_of::<_z_subscription_t>() - 8usize];
    ["Offset of field: _z_subscription_t::_key"]
        [::std::mem::offset_of!(_z_subscription_t, _key) - 0usize];
    ["Offset of field: _z_subscription_t::_declared_key"]
        [::std::mem::offset_of!(_z_subscription_t, _declared_key) - 48usize];
    ["Offset of field: _z_subscription_t::_key_id"]
        [::std::mem::offset_of!(_z_subscription_t, _key_id) - 96usize];
    ["Offset of field: _z_subscription_t::_id"]
        [::std::mem::offset_of!(_z_subscription_t, _id) - 100usize];
    ["Offset of field: _z_subscription_t::_callback"]
        [::std::mem::offset_of!(_z_subscription_t, _callback) - 104usize];
    ["Offset of field: _z_subscription_t::_dropper"]
        [::std::mem::offset_of!(_z_subscription_t, _dropper) - 112usize];
    ["Offset of field: _z_subscription_t::_arg"]
        [::std::mem::offset_of!(_z_subscription_t, _arg) - 120usize];
};
unsafe extern "C" {
    pub fn _z_subscription_eq(one: *const _z_subscription_t, two: *const _z_subscription_t)
        -> bool;
}
unsafe extern "C" {
    pub fn _z_subscription_clear(sub: *mut _z_subscription_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_rc_t {
    pub _val: *mut _z_subscription_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_rc_t"][::std::mem::size_of::<_z_subscription_rc_t>() - 16usize];
    ["Alignment of _z_subscription_rc_t"][::std::mem::align_of::<_z_subscription_rc_t>() - 8usize];
    ["Offset of field: _z_subscription_rc_t::_val"]
        [::std::mem::offset_of!(_z_subscription_rc_t, _val) - 0usize];
    ["Offset of field: _z_subscription_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_subscription_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_weak_t {
    pub _val: *mut _z_subscription_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_weak_t"][::std::mem::size_of::<_z_subscription_weak_t>() - 16usize];
    ["Alignment of _z_subscription_weak_t"]
        [::std::mem::align_of::<_z_subscription_weak_t>() - 8usize];
    ["Offset of field: _z_subscription_weak_t::_val"]
        [::std::mem::offset_of!(_z_subscription_weak_t, _val) - 0usize];
    ["Offset of field: _z_subscription_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_subscription_weak_t, _cnt) - 8usize];
};
pub type _z_subscriber_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_subscription_t, right: *const _z_subscription_t) -> bool,
>;
pub type _z_subscriber_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_t,
        right: *const _z_subscription_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_subscription_rc_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_rc_t,
        right: *const _z_subscription_rc_t,
    ) -> bool,
>;
pub type _z_subscription_rc_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_rc_t,
        right: *const _z_subscription_rc_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_subscription_rc_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_publication_t {
    pub _key: _z_keyexpr_t,
    pub _id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_publication_t"][::std::mem::size_of::<_z_publication_t>() - 56usize];
    ["Alignment of _z_publication_t"][::std::mem::align_of::<_z_publication_t>() - 8usize];
    ["Offset of field: _z_publication_t::_key"]
        [::std::mem::offset_of!(_z_publication_t, _key) - 0usize];
    ["Offset of field: _z_publication_t::_id"]
        [::std::mem::offset_of!(_z_publication_t, _id) - 48usize];
};
#[doc = " The callback signature of the functions handling query messages."]
pub type _z_closure_query_callback_t = ::std::option::Option<
    unsafe extern "C" fn(query: *mut _z_query_rc_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_queryable_t {
    pub _key: _z_keyexpr_t,
    pub _declared_key: _z_keyexpr_t,
    pub _id: u32,
    pub _callback: _z_closure_query_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _arg: *mut ::std::os::raw::c_void,
    pub _complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_queryable_t"][::std::mem::size_of::<_z_session_queryable_t>() - 136usize];
    ["Alignment of _z_session_queryable_t"]
        [::std::mem::align_of::<_z_session_queryable_t>() - 8usize];
    ["Offset of field: _z_session_queryable_t::_key"]
        [::std::mem::offset_of!(_z_session_queryable_t, _key) - 0usize];
    ["Offset of field: _z_session_queryable_t::_declared_key"]
        [::std::mem::offset_of!(_z_session_queryable_t, _declared_key) - 48usize];
    ["Offset of field: _z_session_queryable_t::_id"]
        [::std::mem::offset_of!(_z_session_queryable_t, _id) - 96usize];
    ["Offset of field: _z_session_queryable_t::_callback"]
        [::std::mem::offset_of!(_z_session_queryable_t, _callback) - 104usize];
    ["Offset of field: _z_session_queryable_t::_dropper"]
        [::std::mem::offset_of!(_z_session_queryable_t, _dropper) - 112usize];
    ["Offset of field: _z_session_queryable_t::_arg"]
        [::std::mem::offset_of!(_z_session_queryable_t, _arg) - 120usize];
    ["Offset of field: _z_session_queryable_t::_complete"]
        [::std::mem::offset_of!(_z_session_queryable_t, _complete) - 128usize];
};
unsafe extern "C" {
    pub fn _z_session_queryable_eq(
        one: *const _z_session_queryable_t,
        two: *const _z_session_queryable_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_session_queryable_clear(res: *mut _z_session_queryable_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_queryable_rc_t {
    pub _val: *mut _z_session_queryable_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_queryable_rc_t"]
        [::std::mem::size_of::<_z_session_queryable_rc_t>() - 16usize];
    ["Alignment of _z_session_queryable_rc_t"]
        [::std::mem::align_of::<_z_session_queryable_rc_t>() - 8usize];
    ["Offset of field: _z_session_queryable_rc_t::_val"]
        [::std::mem::offset_of!(_z_session_queryable_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_queryable_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_session_queryable_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_queryable_weak_t {
    pub _val: *mut _z_session_queryable_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_queryable_weak_t"]
        [::std::mem::size_of::<_z_session_queryable_weak_t>() - 16usize];
    ["Alignment of _z_session_queryable_weak_t"]
        [::std::mem::align_of::<_z_session_queryable_weak_t>() - 8usize];
    ["Offset of field: _z_session_queryable_weak_t::_val"]
        [::std::mem::offset_of!(_z_session_queryable_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_queryable_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_session_queryable_weak_t, _cnt) - 8usize];
};
pub type _z_session_queryable_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_t,
        right: *const _z_session_queryable_t,
    ) -> bool,
>;
pub type _z_session_queryable_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_t,
        right: *const _z_session_queryable_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_session_queryable_rc_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_rc_t,
        right: *const _z_session_queryable_rc_t,
    ) -> bool,
>;
pub type _z_session_queryable_rc_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_rc_t,
        right: *const _z_session_queryable_rc_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_session_queryable_rc_slist_t = _z_slist_t;
pub type _z_pending_reply_slist_t = _z_slist_t;
#[doc = " The callback signature of the functions handling query replies."]
pub type _z_closure_reply_callback_t = ::std::option::Option<
    unsafe extern "C" fn(reply: *mut _z_reply_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_pending_query_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _callback: _z_closure_reply_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _start_time: z_clock_t,
    pub _timeout: u64,
    pub _arg: *mut ::std::os::raw::c_void,
    pub _pending_replies: *mut _z_pending_reply_slist_t,
    pub _target: z_query_target_t,
    pub _consolidation: z_consolidation_mode_t,
    pub _anykey: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_pending_query_t"][::std::mem::size_of::<_z_pending_query_t>() - 128usize];
    ["Alignment of _z_pending_query_t"][::std::mem::align_of::<_z_pending_query_t>() - 8usize];
    ["Offset of field: _z_pending_query_t::_key"]
        [::std::mem::offset_of!(_z_pending_query_t, _key) - 0usize];
    ["Offset of field: _z_pending_query_t::_id"]
        [::std::mem::offset_of!(_z_pending_query_t, _id) - 48usize];
    ["Offset of field: _z_pending_query_t::_callback"]
        [::std::mem::offset_of!(_z_pending_query_t, _callback) - 56usize];
    ["Offset of field: _z_pending_query_t::_dropper"]
        [::std::mem::offset_of!(_z_pending_query_t, _dropper) - 64usize];
    ["Offset of field: _z_pending_query_t::_start_time"]
        [::std::mem::offset_of!(_z_pending_query_t, _start_time) - 72usize];
    ["Offset of field: _z_pending_query_t::_timeout"]
        [::std::mem::offset_of!(_z_pending_query_t, _timeout) - 88usize];
    ["Offset of field: _z_pending_query_t::_arg"]
        [::std::mem::offset_of!(_z_pending_query_t, _arg) - 96usize];
    ["Offset of field: _z_pending_query_t::_pending_replies"]
        [::std::mem::offset_of!(_z_pending_query_t, _pending_replies) - 104usize];
    ["Offset of field: _z_pending_query_t::_target"]
        [::std::mem::offset_of!(_z_pending_query_t, _target) - 112usize];
    ["Offset of field: _z_pending_query_t::_consolidation"]
        [::std::mem::offset_of!(_z_pending_query_t, _consolidation) - 116usize];
    ["Offset of field: _z_pending_query_t::_anykey"]
        [::std::mem::offset_of!(_z_pending_query_t, _anykey) - 120usize];
};
unsafe extern "C" {
    pub fn _z_pending_query_eq(
        one: *const _z_pending_query_t,
        two: *const _z_pending_query_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_pending_query_clear(res: *mut _z_pending_query_t);
}
pub type _z_pending_query_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_pending_query_t, right: *const _z_pending_query_t) -> bool,
>;
pub type _z_pending_query_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_pending_query_t,
        right: *const _z_pending_query_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_pending_query_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __z_hello_handler_wrapper_t {
    _unused: [u8; 0],
}
#[doc = " The callback signature of the functions handling hello messages."]
pub type _z_closure_hello_callback_t = ::std::option::Option<
    unsafe extern "C" fn(hello: *mut _z_hello_t, arg: *mut __z_hello_handler_wrapper_t),
>;
unsafe extern "C" {
    pub fn _z_session_generate_zid(bs: *mut _z_id_t, size: u8) -> z_result_t;
}
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_FINAL: _z_interest_msg_type_t = 0;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_DECL_SUBSCRIBER: _z_interest_msg_type_t = 1;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_DECL_QUERYABLE: _z_interest_msg_type_t = 2;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_DECL_TOKEN: _z_interest_msg_type_t = 3;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_UNDECL_SUBSCRIBER: _z_interest_msg_type_t = 4;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_UNDECL_QUERYABLE: _z_interest_msg_type_t = 5;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_UNDECL_TOKEN: _z_interest_msg_type_t = 6;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_CONNECTION_DROPPED: _z_interest_msg_type_t =
    7;
pub type _z_interest_msg_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_interest_msg_t {
    pub type_: u8,
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_interest_msg_t"][::std::mem::size_of::<_z_interest_msg_t>() - 8usize];
    ["Alignment of _z_interest_msg_t"][::std::mem::align_of::<_z_interest_msg_t>() - 4usize];
    ["Offset of field: _z_interest_msg_t::type_"]
        [::std::mem::offset_of!(_z_interest_msg_t, type_) - 0usize];
    ["Offset of field: _z_interest_msg_t::id"]
        [::std::mem::offset_of!(_z_interest_msg_t, id) - 4usize];
};
#[doc = " The callback signature of the functions handling interest messages."]
pub type _z_interest_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const _z_interest_msg_t,
        peer: *mut _z_transport_peer_common_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_interest_t {
    pub _key: _z_keyexpr_t,
    pub _id: u32,
    pub _callback: _z_interest_handler_t,
    pub _arg: *mut ::std::os::raw::c_void,
    pub _flags: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_interest_t"][::std::mem::size_of::<_z_session_interest_t>() - 80usize];
    ["Alignment of _z_session_interest_t"]
        [::std::mem::align_of::<_z_session_interest_t>() - 8usize];
    ["Offset of field: _z_session_interest_t::_key"]
        [::std::mem::offset_of!(_z_session_interest_t, _key) - 0usize];
    ["Offset of field: _z_session_interest_t::_id"]
        [::std::mem::offset_of!(_z_session_interest_t, _id) - 48usize];
    ["Offset of field: _z_session_interest_t::_callback"]
        [::std::mem::offset_of!(_z_session_interest_t, _callback) - 56usize];
    ["Offset of field: _z_session_interest_t::_arg"]
        [::std::mem::offset_of!(_z_session_interest_t, _arg) - 64usize];
    ["Offset of field: _z_session_interest_t::_flags"]
        [::std::mem::offset_of!(_z_session_interest_t, _flags) - 72usize];
};
unsafe extern "C" {
    pub fn _z_session_interest_eq(
        one: *const _z_session_interest_t,
        two: *const _z_session_interest_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_session_interest_clear(res: *mut _z_session_interest_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_interest_rc_t {
    pub _val: *mut _z_session_interest_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_interest_rc_t"]
        [::std::mem::size_of::<_z_session_interest_rc_t>() - 16usize];
    ["Alignment of _z_session_interest_rc_t"]
        [::std::mem::align_of::<_z_session_interest_rc_t>() - 8usize];
    ["Offset of field: _z_session_interest_rc_t::_val"]
        [::std::mem::offset_of!(_z_session_interest_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_interest_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_session_interest_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_interest_weak_t {
    pub _val: *mut _z_session_interest_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_interest_weak_t"]
        [::std::mem::size_of::<_z_session_interest_weak_t>() - 16usize];
    ["Alignment of _z_session_interest_weak_t"]
        [::std::mem::align_of::<_z_session_interest_weak_t>() - 8usize];
    ["Offset of field: _z_session_interest_weak_t::_val"]
        [::std::mem::offset_of!(_z_session_interest_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_interest_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_session_interest_weak_t, _cnt) - 8usize];
};
pub type _z_session_interest_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_t,
        right: *const _z_session_interest_t,
    ) -> bool,
>;
pub type _z_session_interest_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_t,
        right: *const _z_session_interest_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_session_interest_rc_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_rc_t,
        right: *const _z_session_interest_rc_t,
    ) -> bool,
>;
pub type _z_session_interest_rc_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_rc_t,
        right: *const _z_session_interest_rc_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_session_interest_rc_slist_t = _z_slist_t;
pub const _z_declare_type_t__Z_DECLARE_TYPE_SUBSCRIBER: _z_declare_type_t = 0;
pub const _z_declare_type_t__Z_DECLARE_TYPE_QUERYABLE: _z_declare_type_t = 1;
pub const _z_declare_type_t__Z_DECLARE_TYPE_TOKEN: _z_declare_type_t = 2;
pub type _z_declare_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_declare_data_t {
    pub _key: _z_keyexpr_t,
    pub _id: u32,
    pub _type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_declare_data_t"][::std::mem::size_of::<_z_declare_data_t>() - 56usize];
    ["Alignment of _z_declare_data_t"][::std::mem::align_of::<_z_declare_data_t>() - 8usize];
    ["Offset of field: _z_declare_data_t::_key"]
        [::std::mem::offset_of!(_z_declare_data_t, _key) - 0usize];
    ["Offset of field: _z_declare_data_t::_id"]
        [::std::mem::offset_of!(_z_declare_data_t, _id) - 48usize];
    ["Offset of field: _z_declare_data_t::_type"]
        [::std::mem::offset_of!(_z_declare_data_t, _type) - 52usize];
};
unsafe extern "C" {
    pub fn _z_declare_data_clear(data: *mut _z_declare_data_t);
}
unsafe extern "C" {
    pub fn _z_declare_data_size(data: *mut _z_declare_data_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_declare_data_copy(dst: *mut _z_declare_data_t, src: *const _z_declare_data_t);
}
pub type _z_declare_data_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_declare_data_t, right: *const _z_declare_data_t) -> bool,
>;
pub type _z_declare_data_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_declare_data_t,
        right: *const _z_declare_data_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_declare_data_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_liveliness_pending_query_t {
    pub _key: _z_keyexpr_t,
    pub _callback: _z_closure_reply_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _arg: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_liveliness_pending_query_t"]
        [::std::mem::size_of::<_z_liveliness_pending_query_t>() - 72usize];
    ["Alignment of _z_liveliness_pending_query_t"]
        [::std::mem::align_of::<_z_liveliness_pending_query_t>() - 8usize];
    ["Offset of field: _z_liveliness_pending_query_t::_key"]
        [::std::mem::offset_of!(_z_liveliness_pending_query_t, _key) - 0usize];
    ["Offset of field: _z_liveliness_pending_query_t::_callback"]
        [::std::mem::offset_of!(_z_liveliness_pending_query_t, _callback) - 48usize];
    ["Offset of field: _z_liveliness_pending_query_t::_dropper"]
        [::std::mem::offset_of!(_z_liveliness_pending_query_t, _dropper) - 56usize];
    ["Offset of field: _z_liveliness_pending_query_t::_arg"]
        [::std::mem::offset_of!(_z_liveliness_pending_query_t, _arg) - 64usize];
};
unsafe extern "C" {
    pub fn _z_liveliness_pending_query_clear(res: *mut _z_liveliness_pending_query_t);
}
unsafe extern "C" {
    pub fn _z_liveliness_pending_query_copy(
        dst: *mut _z_liveliness_pending_query_t,
        src: *const _z_liveliness_pending_query_t,
    );
}
unsafe extern "C" {
    pub fn _z_liveliness_pending_query_clone(
        src: *const _z_liveliness_pending_query_t,
    ) -> *mut _z_liveliness_pending_query_t;
}
pub type _z_liveliness_pending_query_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_liveliness_pending_query_t,
        right: *const _z_liveliness_pending_query_t,
    ) -> bool,
>;
pub type _z_liveliness_pending_query_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_liveliness_pending_query_t,
        right: *const _z_liveliness_pending_query_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_liveliness_pending_query_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_liveliness_pending_query_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_liveliness_pending_query_intmap_iterator_t = _z_int_void_map_iterator_t;
unsafe extern "C" {
    pub fn _z_liveliness_get_query_id(zn: *mut _z_session_t) -> u32;
}
unsafe extern "C" {
    pub fn _z_liveliness_register_token(
        zn: *mut _z_session_t,
        id: u32,
        keyexpr: *const _z_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_unregister_token(zn: *mut _z_session_t, id: u32);
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_declare(
        zn: *mut _z_session_t,
        id: u32,
        keyexpr: *const _z_keyexpr_t,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_undeclare(
        zn: *mut _z_session_t,
        id: u32,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_undeclare_all(zn: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_trigger_history(
        zn: *mut _z_session_t,
        keyexpr: *const _z_keyexpr_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_register_pending_query(
        zn: *mut _z_session_t,
        id: u32,
        pen_qry: *mut _z_liveliness_pending_query_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_unregister_pending_query(zn: *mut _z_session_t, id: u32);
}
unsafe extern "C" {
    pub fn _z_liveliness_init(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_liveliness_clear(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_liveliness_process_token_declare(
        zn: *mut _z_session_t,
        decl: *const _z_n_msg_declare_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_process_token_undeclare(
        zn: *mut _z_session_t,
        decl: *const _z_n_msg_declare_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_process_declare_final(
        zn: *mut _z_session_t,
        decl: *const _z_n_msg_declare_t,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_status_t {
    pub matching: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_status_t"][::std::mem::size_of::<_z_matching_status_t>() - 1usize];
    ["Alignment of _z_matching_status_t"][::std::mem::align_of::<_z_matching_status_t>() - 1usize];
    ["Offset of field: _z_matching_status_t::matching"]
        [::std::mem::offset_of!(_z_matching_status_t, matching) - 0usize];
};
pub type _z_closure_matching_status_callback_t = ::std::option::Option<
    unsafe extern "C" fn(status: *const _z_matching_status_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_matching_status_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: _z_closure_matching_status_callback_t,
    pub drop: _z_drop_handler_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_matching_status_t"]
        [::std::mem::size_of::<_z_closure_matching_status_t>() - 24usize];
    ["Alignment of _z_closure_matching_status_t"]
        [::std::mem::align_of::<_z_closure_matching_status_t>() - 8usize];
    ["Offset of field: _z_closure_matching_status_t::context"]
        [::std::mem::offset_of!(_z_closure_matching_status_t, context) - 0usize];
    ["Offset of field: _z_closure_matching_status_t::call"]
        [::std::mem::offset_of!(_z_closure_matching_status_t, call) - 8usize];
    ["Offset of field: _z_closure_matching_status_t::drop"]
        [::std::mem::offset_of!(_z_closure_matching_status_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_ctx_t {
    pub decl_id: u32,
    pub callback: _z_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_ctx_t"]
        [::std::mem::size_of::<_z_matching_listener_ctx_t>() - 32usize];
    ["Alignment of _z_matching_listener_ctx_t"]
        [::std::mem::align_of::<_z_matching_listener_ctx_t>() - 8usize];
    ["Offset of field: _z_matching_listener_ctx_t::decl_id"]
        [::std::mem::offset_of!(_z_matching_listener_ctx_t, decl_id) - 0usize];
    ["Offset of field: _z_matching_listener_ctx_t::callback"]
        [::std::mem::offset_of!(_z_matching_listener_ctx_t, callback) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_state_t {
    pub interest_id: u32,
    pub entity_id: _z_zint_t,
    pub ctx: *mut _z_matching_listener_ctx_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_state_t"]
        [::std::mem::size_of::<_z_matching_listener_state_t>() - 24usize];
    ["Alignment of _z_matching_listener_state_t"]
        [::std::mem::align_of::<_z_matching_listener_state_t>() - 8usize];
    ["Offset of field: _z_matching_listener_state_t::interest_id"]
        [::std::mem::offset_of!(_z_matching_listener_state_t, interest_id) - 0usize];
    ["Offset of field: _z_matching_listener_state_t::entity_id"]
        [::std::mem::offset_of!(_z_matching_listener_state_t, entity_id) - 8usize];
    ["Offset of field: _z_matching_listener_state_t::ctx"]
        [::std::mem::offset_of!(_z_matching_listener_state_t, ctx) - 16usize];
};
unsafe extern "C" {
    pub fn _z_matching_listener_ctx_new(
        callback: _z_closure_matching_status_t,
    ) -> *mut _z_matching_listener_ctx_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_ctx_clear(ctx: *mut _z_matching_listener_ctx_t);
}
unsafe extern "C" {
    pub fn _z_matching_listener_state_new(
        interest_id: u32,
        entity_id: _z_zint_t,
        ctx: *mut _z_matching_listener_ctx_t,
    ) -> *mut _z_matching_listener_state_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_state_clear(state: *mut _z_matching_listener_state_t);
}
pub type _z_matching_listener_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_matching_listener_state_t,
        right: *const _z_matching_listener_state_t,
    ) -> bool,
>;
pub type _z_matching_listener_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_matching_listener_state_t,
        right: *const _z_matching_listener_state_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_matching_listener_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_matching_listener_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_matching_listener_intmap_iterator_t = _z_int_void_map_iterator_t;
pub type _z_lru_val_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        first: *const ::std::os::raw::c_void,
        second: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_lru_cache_node_t = ::std::os::raw::c_void;
#[doc = " A least recently used cache implementation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_lru_cache_t {
    pub capacity: usize,
    pub len: usize,
    pub head: *mut _z_lru_cache_node_t,
    pub tail: *mut _z_lru_cache_node_t,
    pub slist: *mut *mut _z_lru_cache_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_lru_cache_t"][::std::mem::size_of::<_z_lru_cache_t>() - 40usize];
    ["Alignment of _z_lru_cache_t"][::std::mem::align_of::<_z_lru_cache_t>() - 8usize];
    ["Offset of field: _z_lru_cache_t::capacity"]
        [::std::mem::offset_of!(_z_lru_cache_t, capacity) - 0usize];
    ["Offset of field: _z_lru_cache_t::len"][::std::mem::offset_of!(_z_lru_cache_t, len) - 8usize];
    ["Offset of field: _z_lru_cache_t::head"]
        [::std::mem::offset_of!(_z_lru_cache_t, head) - 16usize];
    ["Offset of field: _z_lru_cache_t::tail"]
        [::std::mem::offset_of!(_z_lru_cache_t, tail) - 24usize];
    ["Offset of field: _z_lru_cache_t::slist"]
        [::std::mem::offset_of!(_z_lru_cache_t, slist) - 32usize];
};
unsafe extern "C" {
    pub fn _z_lru_cache_init(capacity: usize) -> _z_lru_cache_t;
}
unsafe extern "C" {
    pub fn _z_lru_cache_get(
        cache: *mut _z_lru_cache_t,
        value: *mut ::std::os::raw::c_void,
        compare: _z_lru_val_cmp_f,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_lru_cache_insert(
        cache: *mut _z_lru_cache_t,
        value: *mut ::std::os::raw::c_void,
        value_size: usize,
        compare: _z_lru_val_cmp_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_lru_cache_clear(cache: *mut _z_lru_cache_t, clear: z_element_clear_f);
}
unsafe extern "C" {
    pub fn _z_lru_cache_delete(cache: *mut _z_lru_cache_t, clear: z_element_clear_f);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_infos_t {
    pub callback: _z_closure_query_callback_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_infos_t"][::std::mem::size_of::<_z_queryable_infos_t>() - 16usize];
    ["Alignment of _z_queryable_infos_t"][::std::mem::align_of::<_z_queryable_infos_t>() - 8usize];
    ["Offset of field: _z_queryable_infos_t::callback"]
        [::std::mem::offset_of!(_z_queryable_infos_t, callback) - 0usize];
    ["Offset of field: _z_queryable_infos_t::arg"]
        [::std::mem::offset_of!(_z_queryable_infos_t, arg) - 8usize];
};
pub type _z_queryable_infos_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_queryable_infos_t,
        right: *const _z_queryable_infos_t,
    ) -> bool,
>;
pub type _z_queryable_infos_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_queryable_infos_t,
        right: *const _z_queryable_infos_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_queryable_infos_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_cache_data_t {
    pub ke_in: _z_keyexpr_t,
    pub ke_out: _z_keyexpr_t,
    pub infos: _z_queryable_infos_svec_t,
    pub qle_nb: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_cache_data_t"]
        [::std::mem::size_of::<_z_queryable_cache_data_t>() - 136usize];
    ["Alignment of _z_queryable_cache_data_t"]
        [::std::mem::align_of::<_z_queryable_cache_data_t>() - 8usize];
    ["Offset of field: _z_queryable_cache_data_t::ke_in"]
        [::std::mem::offset_of!(_z_queryable_cache_data_t, ke_in) - 0usize];
    ["Offset of field: _z_queryable_cache_data_t::ke_out"]
        [::std::mem::offset_of!(_z_queryable_cache_data_t, ke_out) - 48usize];
    ["Offset of field: _z_queryable_cache_data_t::infos"]
        [::std::mem::offset_of!(_z_queryable_cache_data_t, infos) - 96usize];
    ["Offset of field: _z_queryable_cache_data_t::qle_nb"]
        [::std::mem::offset_of!(_z_queryable_cache_data_t, qle_nb) - 128usize];
};
unsafe extern "C" {
    pub fn _z_queryable_cache_invalidate(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_queryable_cache_data_compare(
        first: *const ::std::os::raw::c_void,
        second: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_queryable_cache_data_clear(val: *mut _z_queryable_cache_data_t);
}
unsafe extern "C" {
    pub fn _z_get_session_queryable_by_id(
        zn: *mut _z_session_t,
        id: _z_zint_t,
    ) -> *mut _z_session_queryable_rc_t;
}
unsafe extern "C" {
    pub fn _z_register_session_queryable(
        zn: *mut _z_session_t,
        q: *mut _z_session_queryable_t,
    ) -> *mut _z_session_queryable_rc_t;
}
unsafe extern "C" {
    pub fn _z_trigger_queryables(
        transport: *mut _z_transport_common_t,
        query: *mut _z_msg_query_t,
        q_key: *mut _z_keyexpr_t,
        qid: u32,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_unregister_session_queryable(
        zn: *mut _z_session_t,
        q: *mut _z_session_queryable_rc_t,
    );
}
unsafe extern "C" {
    pub fn _z_flush_session_queryable(zn: *mut _z_session_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_infos_t {
    pub callback: _z_closure_sample_callback_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_infos_t"][::std::mem::size_of::<_z_subscription_infos_t>() - 16usize];
    ["Alignment of _z_subscription_infos_t"]
        [::std::mem::align_of::<_z_subscription_infos_t>() - 8usize];
    ["Offset of field: _z_subscription_infos_t::callback"]
        [::std::mem::offset_of!(_z_subscription_infos_t, callback) - 0usize];
    ["Offset of field: _z_subscription_infos_t::arg"]
        [::std::mem::offset_of!(_z_subscription_infos_t, arg) - 8usize];
};
pub type _z_subscription_infos_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_infos_t,
        right: *const _z_subscription_infos_t,
    ) -> bool,
>;
pub type _z_subscription_infos_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_infos_t,
        right: *const _z_subscription_infos_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_subscription_infos_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_cache_data_t {
    pub ke_in: _z_keyexpr_t,
    pub ke_out: _z_keyexpr_t,
    pub infos: _z_subscription_infos_svec_t,
    pub sub_nb: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_cache_data_t"]
        [::std::mem::size_of::<_z_subscription_cache_data_t>() - 136usize];
    ["Alignment of _z_subscription_cache_data_t"]
        [::std::mem::align_of::<_z_subscription_cache_data_t>() - 8usize];
    ["Offset of field: _z_subscription_cache_data_t::ke_in"]
        [::std::mem::offset_of!(_z_subscription_cache_data_t, ke_in) - 0usize];
    ["Offset of field: _z_subscription_cache_data_t::ke_out"]
        [::std::mem::offset_of!(_z_subscription_cache_data_t, ke_out) - 48usize];
    ["Offset of field: _z_subscription_cache_data_t::infos"]
        [::std::mem::offset_of!(_z_subscription_cache_data_t, infos) - 96usize];
    ["Offset of field: _z_subscription_cache_data_t::sub_nb"]
        [::std::mem::offset_of!(_z_subscription_cache_data_t, sub_nb) - 128usize];
};
unsafe extern "C" {
    pub fn _z_subscription_cache_invalidate(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_subscription_cache_data_compare(
        first: *const ::std::os::raw::c_void,
        second: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _z_subscription_cache_data_clear(val: *mut _z_subscription_cache_data_t);
}
unsafe extern "C" {
    pub fn _z_trigger_liveliness_subscriptions_declare(
        zn: *mut _z_session_t,
        keyexpr: *const _z_keyexpr_t,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_trigger_liveliness_subscriptions_undeclare(
        zn: *mut _z_session_t,
        keyexpr: *const _z_keyexpr_t,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_get_subscription_by_id(
        zn: *mut _z_session_t,
        kind: _z_subscriber_kind_t,
        id: _z_zint_t,
    ) -> *mut _z_subscription_rc_t;
}
unsafe extern "C" {
    pub fn _z_register_subscription(
        zn: *mut _z_session_t,
        kind: _z_subscriber_kind_t,
        sub: *mut _z_subscription_t,
    ) -> *mut _z_subscription_rc_t;
}
unsafe extern "C" {
    pub fn _z_trigger_subscriptions_impl(
        zn: *mut _z_session_t,
        sub_kind: _z_subscriber_kind_t,
        keyexpr: *mut _z_keyexpr_t,
        payload: *mut _z_bytes_t,
        encoding: *mut _z_encoding_t,
        sample_kind: _z_zint_t,
        timestamp: *const _z_timestamp_t,
        qos: _z_n_qos_t,
        attachment: *mut _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *mut _z_source_info_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_unregister_subscription(
        zn: *mut _z_session_t,
        kind: _z_subscriber_kind_t,
        sub: *mut _z_subscription_rc_t,
    );
}
unsafe extern "C" {
    pub fn _z_flush_subscriptions(zn: *mut _z_session_t);
}
#[doc = " A zenoh-net session."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_session_t {
    pub _mutex_inner_initialized: bool,
    pub _mutex_inner: _z_mutex_t,
    pub _mode: z_whatami_t,
    pub _tp: _z_transport_t,
    pub _local_zid: _z_id_t,
    pub _resource_id: u16,
    pub _entity_id: u32,
    pub _query_id: _z_zint_t,
    pub _interest_id: _z_zint_t,
    pub _local_resources: *mut _z_resource_slist_t,
    pub _config: _z_config_t,
    pub _declaration_cache: *mut _z_network_message_slist_t,
    pub _lease_task_attr: *mut z_task_attr_t,
    pub _read_task_attr: *mut z_task_attr_t,
    pub _subscriptions: *mut _z_subscription_rc_slist_t,
    pub _liveliness_subscriptions: *mut _z_subscription_rc_slist_t,
    pub _local_tokens: _z_keyexpr_intmap_t,
    pub _remote_tokens: _z_keyexpr_intmap_t,
    pub _liveliness_query_id: u32,
    pub _liveliness_pending_queries: _z_liveliness_pending_query_intmap_t,
    pub _local_queryable: *mut _z_session_queryable_rc_slist_t,
    pub _pending_queries: *mut _z_pending_query_slist_t,
    pub _matching_listeners: _z_matching_listener_intmap_t,
    pub _local_interests: *mut _z_session_interest_rc_slist_t,
    pub _remote_declares: *mut _z_declare_data_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_t"][::std::mem::size_of::<_z_session_t>() - 544usize];
    ["Alignment of _z_session_t"][::std::mem::align_of::<_z_session_t>() - 8usize];
    ["Offset of field: _z_session_t::_mutex_inner_initialized"]
        [::std::mem::offset_of!(_z_session_t, _mutex_inner_initialized) - 0usize];
    ["Offset of field: _z_session_t::_mutex_inner"]
        [::std::mem::offset_of!(_z_session_t, _mutex_inner) - 4usize];
    ["Offset of field: _z_session_t::_mode"][::std::mem::offset_of!(_z_session_t, _mode) - 8usize];
    ["Offset of field: _z_session_t::_tp"][::std::mem::offset_of!(_z_session_t, _tp) - 16usize];
    ["Offset of field: _z_session_t::_local_zid"]
        [::std::mem::offset_of!(_z_session_t, _local_zid) - 256usize];
    ["Offset of field: _z_session_t::_resource_id"]
        [::std::mem::offset_of!(_z_session_t, _resource_id) - 272usize];
    ["Offset of field: _z_session_t::_entity_id"]
        [::std::mem::offset_of!(_z_session_t, _entity_id) - 276usize];
    ["Offset of field: _z_session_t::_query_id"]
        [::std::mem::offset_of!(_z_session_t, _query_id) - 280usize];
    ["Offset of field: _z_session_t::_interest_id"]
        [::std::mem::offset_of!(_z_session_t, _interest_id) - 288usize];
    ["Offset of field: _z_session_t::_local_resources"]
        [::std::mem::offset_of!(_z_session_t, _local_resources) - 296usize];
    ["Offset of field: _z_session_t::_config"]
        [::std::mem::offset_of!(_z_session_t, _config) - 304usize];
    ["Offset of field: _z_session_t::_declaration_cache"]
        [::std::mem::offset_of!(_z_session_t, _declaration_cache) - 336usize];
    ["Offset of field: _z_session_t::_lease_task_attr"]
        [::std::mem::offset_of!(_z_session_t, _lease_task_attr) - 344usize];
    ["Offset of field: _z_session_t::_read_task_attr"]
        [::std::mem::offset_of!(_z_session_t, _read_task_attr) - 352usize];
    ["Offset of field: _z_session_t::_subscriptions"]
        [::std::mem::offset_of!(_z_session_t, _subscriptions) - 360usize];
    ["Offset of field: _z_session_t::_liveliness_subscriptions"]
        [::std::mem::offset_of!(_z_session_t, _liveliness_subscriptions) - 368usize];
    ["Offset of field: _z_session_t::_local_tokens"]
        [::std::mem::offset_of!(_z_session_t, _local_tokens) - 376usize];
    ["Offset of field: _z_session_t::_remote_tokens"]
        [::std::mem::offset_of!(_z_session_t, _remote_tokens) - 408usize];
    ["Offset of field: _z_session_t::_liveliness_query_id"]
        [::std::mem::offset_of!(_z_session_t, _liveliness_query_id) - 440usize];
    ["Offset of field: _z_session_t::_liveliness_pending_queries"]
        [::std::mem::offset_of!(_z_session_t, _liveliness_pending_queries) - 448usize];
    ["Offset of field: _z_session_t::_local_queryable"]
        [::std::mem::offset_of!(_z_session_t, _local_queryable) - 480usize];
    ["Offset of field: _z_session_t::_pending_queries"]
        [::std::mem::offset_of!(_z_session_t, _pending_queries) - 488usize];
    ["Offset of field: _z_session_t::_matching_listeners"]
        [::std::mem::offset_of!(_z_session_t, _matching_listeners) - 496usize];
    ["Offset of field: _z_session_t::_local_interests"]
        [::std::mem::offset_of!(_z_session_t, _local_interests) - 528usize];
    ["Offset of field: _z_session_t::_remote_declares"]
        [::std::mem::offset_of!(_z_session_t, _remote_declares) - 536usize];
};
unsafe extern "C" {
    #[doc = " Open a zenoh-net session\n\n Parameters:\n     zn: A pointer of A :c:type:`_z_session_rc_t` used as a return value.\n     config: A set of properties. The caller keeps its ownership.\n     zid: A pointer to Zenoh ID.\n\n Returns:\n     ``0`` in case of success, or a ``negative value`` in case of failure."]
    pub fn _z_open(
        zn: *mut _z_session_rc_t,
        config: *mut _z_config_t,
        zid: *const _z_id_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Reopen a disconnected zenoh-net session\n\n Parameters:\n     zn: Existing zenoh-net session.\n\n Returns:\n     ``0`` in case of success, or a ``negative value`` in case of failure."]
    pub fn _z_reopen(zn: *mut _z_session_rc_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Store declaration network message to cache for resend it after session restore\n\n Parameters:\n     zs: A zenoh-net session.\n     z_msg: Network message with declaration"]
    pub fn _z_cache_declaration(zs: *mut _z_session_t, n_msg: *const _z_network_message_t);
}
unsafe extern "C" {
    #[doc = " Remove corresponding declaration from the cache\n\n Parameters:\n     zs: A zenoh-net session.\n     z_msg: Network message with undeclaration"]
    pub fn _z_prune_declaration(zs: *mut _z_session_t, n_msg: *const _z_network_message_t);
}
unsafe extern "C" {
    #[doc = " Close a zenoh-net session.\n\n Parameters:\n     session: A zenoh-net session. The callee releases session upon successful return."]
    pub fn _z_close(session: *mut _z_session_t);
}
unsafe extern "C" {
    #[doc = " Return true is session and all associated transports were closed."]
    pub fn _z_session_is_closed(session: *const _z_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Upgrades weak session session, than resets it to null if session is closed."]
    pub fn _z_session_weak_upgrade_if_open(session: *const _z_session_weak_t) -> _z_session_rc_t;
}
unsafe extern "C" {
    #[doc = " Get informations about an zenoh-net session.\n\n Parameters:\n     session: A zenoh-net session. The caller keeps its ownership.\n\n Returns:\n     A :c:type:`_z_config_t` map containing informations on the given zenoh-net session."]
    pub fn _z_info(session: *const _z_session_t) -> *mut _z_config_t;
}
unsafe extern "C" {
    #[doc = " Read from the network. This function should be called manually called when\n the read loop has not been started, e.g., when running in a single thread.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n     single_read: Read a single packet from the buffer instead of the whole buffer\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_read(z: *mut _z_session_t, single_read: bool) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Send a KeepAlive message.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_send_keep_alive(z: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Send a Join message.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_send_join(z: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Start a separate task to read from the network and process the messages\n as soon as they are received. Note that the task can be implemented in\n form of thread, process, etc. and its implementation is platform-dependent.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_start_read_task(z: *mut _z_session_t, attr: *mut z_task_attr_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stop the read task. This may result in stopping a thread or a process depending\n on the target platform.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_stop_read_task(z: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Start a separate task to handle the session lease. This task will send ``KeepAlive``\n messages when needed and will close the session when the lease is expired. Note that\n the task can be implemented in form of thread, process, etc. and its implementation\n is platform-dependent.\n\n In case of a multicast transport, this task will also send periodic ``Join``\n messages.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_start_lease_task(z: *mut _z_session_t, attr: *mut z_task_attr_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stop the lease task. This may result in stopping a thread or a process depending\n on the target platform.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_stop_lease_task(z: *mut _z_session_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_t {
    pub _id: u32,
    pub _interest_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_t"][::std::mem::size_of::<_z_matching_listener_t>() - 24usize];
    ["Alignment of _z_matching_listener_t"]
        [::std::mem::align_of::<_z_matching_listener_t>() - 8usize];
    ["Offset of field: _z_matching_listener_t::_id"]
        [::std::mem::offset_of!(_z_matching_listener_t, _id) - 0usize];
    ["Offset of field: _z_matching_listener_t::_interest_id"]
        [::std::mem::offset_of!(_z_matching_listener_t, _interest_id) - 4usize];
    ["Offset of field: _z_matching_listener_t::_zn"]
        [::std::mem::offset_of!(_z_matching_listener_t, _zn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_matching_listener_declare(
        zn: *mut _z_session_rc_t,
        key: *const _z_keyexpr_t,
        entity_id: _z_zint_t,
        interest_type_flag: u8,
        callback: _z_closure_matching_status_t,
    ) -> _z_matching_listener_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_entity_undeclare(
        zn: *mut _z_session_t,
        entity_id: _z_zint_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_undeclare(listener: *mut _z_matching_listener_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_clear(listener: *mut _z_matching_listener_t);
}
unsafe extern "C" {
    pub fn _z_matching_listener_free(listener: *mut *mut _z_matching_listener_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_filter_target_t {
    pub peer: usize,
    pub decl_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_filter_target_t"][::std::mem::size_of::<_z_filter_target_t>() - 16usize];
    ["Alignment of _z_filter_target_t"][::std::mem::align_of::<_z_filter_target_t>() - 8usize];
    ["Offset of field: _z_filter_target_t::peer"]
        [::std::mem::offset_of!(_z_filter_target_t, peer) - 0usize];
    ["Offset of field: _z_filter_target_t::decl_id"]
        [::std::mem::offset_of!(_z_filter_target_t, decl_id) - 8usize];
};
pub type _z_filter_target_eq_f = z_element_eq_f;
pub type _z_filter_target_slist_t = _z_slist_t;
pub const _z_write_filter_state_t_WRITE_FILTER_ACTIVE: _z_write_filter_state_t = 0;
pub const _z_write_filter_state_t_WRITE_FILTER_OFF: _z_write_filter_state_t = 1;
pub type _z_write_filter_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_writer_filter_ctx_t {
    pub mutex: _z_mutex_t,
    pub targets: *mut _z_filter_target_slist_t,
    pub state: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_writer_filter_ctx_t"][::std::mem::size_of::<_z_writer_filter_ctx_t>() - 24usize];
    ["Alignment of _z_writer_filter_ctx_t"]
        [::std::mem::align_of::<_z_writer_filter_ctx_t>() - 8usize];
    ["Offset of field: _z_writer_filter_ctx_t::mutex"]
        [::std::mem::offset_of!(_z_writer_filter_ctx_t, mutex) - 0usize];
    ["Offset of field: _z_writer_filter_ctx_t::targets"]
        [::std::mem::offset_of!(_z_writer_filter_ctx_t, targets) - 8usize];
    ["Offset of field: _z_writer_filter_ctx_t::state"]
        [::std::mem::offset_of!(_z_writer_filter_ctx_t, state) - 16usize];
};
#[doc = " Return type when declaring a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_write_filter_t {
    pub _interest_id: u32,
    pub ctx: *mut _z_writer_filter_ctx_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_write_filter_t"][::std::mem::size_of::<_z_write_filter_t>() - 16usize];
    ["Alignment of _z_write_filter_t"][::std::mem::align_of::<_z_write_filter_t>() - 8usize];
    ["Offset of field: _z_write_filter_t::_interest_id"]
        [::std::mem::offset_of!(_z_write_filter_t, _interest_id) - 0usize];
    ["Offset of field: _z_write_filter_t::ctx"]
        [::std::mem::offset_of!(_z_write_filter_t, ctx) - 8usize];
};
unsafe extern "C" {
    pub fn _z_write_filter_create(
        zn: *mut _z_session_t,
        filter: *mut _z_write_filter_t,
        keyexpr: _z_keyexpr_t,
        interest_flag: u8,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_write_filter_destroy(
        zn: *mut _z_session_t,
        filter: *mut _z_write_filter_t,
    ) -> z_result_t;
}
#[doc = " Return type when declaring a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_publisher_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _zn: _z_session_weak_t,
    pub _encoding: _z_encoding_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub reliability: z_reliability_t,
    pub _is_express: bool,
    pub _filter: _z_write_filter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_publisher_t"][::std::mem::size_of::<_z_publisher_t>() - 144usize];
    ["Alignment of _z_publisher_t"][::std::mem::align_of::<_z_publisher_t>() - 8usize];
    ["Offset of field: _z_publisher_t::_key"]
        [::std::mem::offset_of!(_z_publisher_t, _key) - 0usize];
    ["Offset of field: _z_publisher_t::_id"][::std::mem::offset_of!(_z_publisher_t, _id) - 48usize];
    ["Offset of field: _z_publisher_t::_zn"][::std::mem::offset_of!(_z_publisher_t, _zn) - 56usize];
    ["Offset of field: _z_publisher_t::_encoding"]
        [::std::mem::offset_of!(_z_publisher_t, _encoding) - 72usize];
    ["Offset of field: _z_publisher_t::_congestion_control"]
        [::std::mem::offset_of!(_z_publisher_t, _congestion_control) - 112usize];
    ["Offset of field: _z_publisher_t::_priority"]
        [::std::mem::offset_of!(_z_publisher_t, _priority) - 116usize];
    ["Offset of field: _z_publisher_t::reliability"]
        [::std::mem::offset_of!(_z_publisher_t, reliability) - 120usize];
    ["Offset of field: _z_publisher_t::_is_express"]
        [::std::mem::offset_of!(_z_publisher_t, _is_express) - 124usize];
    ["Offset of field: _z_publisher_t::_filter"]
        [::std::mem::offset_of!(_z_publisher_t, _filter) - 128usize];
};
unsafe extern "C" {
    pub fn _z_publisher_clear(pub_: *mut _z_publisher_t);
}
unsafe extern "C" {
    pub fn _z_publisher_free(pub_: *mut *mut _z_publisher_t);
}
#[doc = " The query to be answered by a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_t {
    pub _key: _z_keyexpr_t,
    pub _value: _z_value_t,
    pub _request_id: u32,
    pub _zn: _z_session_weak_t,
    pub _attachment: _z_bytes_t,
    pub _parameters: _z_string_t,
    pub _anyke: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_t"][::std::mem::size_of::<_z_query_t>() - 216usize];
    ["Alignment of _z_query_t"][::std::mem::align_of::<_z_query_t>() - 8usize];
    ["Offset of field: _z_query_t::_key"][::std::mem::offset_of!(_z_query_t, _key) - 0usize];
    ["Offset of field: _z_query_t::_value"][::std::mem::offset_of!(_z_query_t, _value) - 48usize];
    ["Offset of field: _z_query_t::_request_id"]
        [::std::mem::offset_of!(_z_query_t, _request_id) - 120usize];
    ["Offset of field: _z_query_t::_zn"][::std::mem::offset_of!(_z_query_t, _zn) - 128usize];
    ["Offset of field: _z_query_t::_attachment"]
        [::std::mem::offset_of!(_z_query_t, _attachment) - 144usize];
    ["Offset of field: _z_query_t::_parameters"]
        [::std::mem::offset_of!(_z_query_t, _parameters) - 176usize];
    ["Offset of field: _z_query_t::_anyke"][::std::mem::offset_of!(_z_query_t, _anyke) - 208usize];
};
unsafe extern "C" {
    pub fn _z_query_send_reply_final(q: *mut _z_query_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_query_clear(q: *mut _z_query_t);
}
unsafe extern "C" {
    pub fn _z_query_free(query: *mut *mut _z_query_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_rc_t {
    pub _val: *mut _z_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_rc_t"][::std::mem::size_of::<_z_query_rc_t>() - 16usize];
    ["Alignment of _z_query_rc_t"][::std::mem::align_of::<_z_query_rc_t>() - 8usize];
    ["Offset of field: _z_query_rc_t::_val"][::std::mem::offset_of!(_z_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_query_rc_t::_cnt"][::std::mem::offset_of!(_z_query_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_weak_t {
    pub _val: *mut _z_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_weak_t"][::std::mem::size_of::<_z_query_weak_t>() - 16usize];
    ["Alignment of _z_query_weak_t"][::std::mem::align_of::<_z_query_weak_t>() - 8usize];
    ["Offset of field: _z_query_weak_t::_val"]
        [::std::mem::offset_of!(_z_query_weak_t, _val) - 0usize];
    ["Offset of field: _z_query_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_query_weak_t, _cnt) - 8usize];
};
#[doc = " Return type when declaring a querier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_querier_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _zn: _z_session_weak_t,
    pub _encoding: _z_encoding_t,
    pub _consolidation_mode: z_consolidation_mode_t,
    pub _target: z_query_target_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub reliability: z_reliability_t,
    pub _is_express: bool,
    pub _timeout_ms: u64,
    pub _filter: _z_write_filter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_querier_t"][::std::mem::size_of::<_z_querier_t>() - 160usize];
    ["Alignment of _z_querier_t"][::std::mem::align_of::<_z_querier_t>() - 8usize];
    ["Offset of field: _z_querier_t::_key"][::std::mem::offset_of!(_z_querier_t, _key) - 0usize];
    ["Offset of field: _z_querier_t::_id"][::std::mem::offset_of!(_z_querier_t, _id) - 48usize];
    ["Offset of field: _z_querier_t::_zn"][::std::mem::offset_of!(_z_querier_t, _zn) - 56usize];
    ["Offset of field: _z_querier_t::_encoding"]
        [::std::mem::offset_of!(_z_querier_t, _encoding) - 72usize];
    ["Offset of field: _z_querier_t::_consolidation_mode"]
        [::std::mem::offset_of!(_z_querier_t, _consolidation_mode) - 112usize];
    ["Offset of field: _z_querier_t::_target"]
        [::std::mem::offset_of!(_z_querier_t, _target) - 116usize];
    ["Offset of field: _z_querier_t::_congestion_control"]
        [::std::mem::offset_of!(_z_querier_t, _congestion_control) - 120usize];
    ["Offset of field: _z_querier_t::_priority"]
        [::std::mem::offset_of!(_z_querier_t, _priority) - 124usize];
    ["Offset of field: _z_querier_t::reliability"]
        [::std::mem::offset_of!(_z_querier_t, reliability) - 128usize];
    ["Offset of field: _z_querier_t::_is_express"]
        [::std::mem::offset_of!(_z_querier_t, _is_express) - 132usize];
    ["Offset of field: _z_querier_t::_timeout_ms"]
        [::std::mem::offset_of!(_z_querier_t, _timeout_ms) - 136usize];
    ["Offset of field: _z_querier_t::_filter"]
        [::std::mem::offset_of!(_z_querier_t, _filter) - 144usize];
};
unsafe extern "C" {
    pub fn _z_querier_clear(querier: *mut _z_querier_t);
}
unsafe extern "C" {
    pub fn _z_querier_free(querier: *mut *mut _z_querier_t);
}
#[doc = " Return type when declaring a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_t {
    pub _entity_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_t"][::std::mem::size_of::<_z_queryable_t>() - 24usize];
    ["Alignment of _z_queryable_t"][::std::mem::align_of::<_z_queryable_t>() - 8usize];
    ["Offset of field: _z_queryable_t::_entity_id"]
        [::std::mem::offset_of!(_z_queryable_t, _entity_id) - 0usize];
    ["Offset of field: _z_queryable_t::_zn"][::std::mem::offset_of!(_z_queryable_t, _zn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_queryable_clear(qbl: *mut _z_queryable_t);
}
unsafe extern "C" {
    pub fn _z_queryable_free(qbl: *mut *mut _z_queryable_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_t {
    pub _val: *mut *mut ::std::os::raw::c_void,
    pub _capacity: usize,
    pub _len: usize,
    pub _r_idx: usize,
    pub _w_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_t"][::std::mem::size_of::<_z_ring_t>() - 40usize];
    ["Alignment of _z_ring_t"][::std::mem::align_of::<_z_ring_t>() - 8usize];
    ["Offset of field: _z_ring_t::_val"][::std::mem::offset_of!(_z_ring_t, _val) - 0usize];
    ["Offset of field: _z_ring_t::_capacity"]
        [::std::mem::offset_of!(_z_ring_t, _capacity) - 8usize];
    ["Offset of field: _z_ring_t::_len"][::std::mem::offset_of!(_z_ring_t, _len) - 16usize];
    ["Offset of field: _z_ring_t::_r_idx"][::std::mem::offset_of!(_z_ring_t, _r_idx) - 24usize];
    ["Offset of field: _z_ring_t::_w_idx"][::std::mem::offset_of!(_z_ring_t, _w_idx) - 32usize];
};
#[doc = " Forward iterator of a ring buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_iterator_t {
    pub _val: *mut ::std::os::raw::c_void,
    pub _ring: *const _z_ring_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_iterator_t"][::std::mem::size_of::<_z_ring_iterator_t>() - 32usize];
    ["Alignment of _z_ring_iterator_t"][::std::mem::align_of::<_z_ring_iterator_t>() - 8usize];
    ["Offset of field: _z_ring_iterator_t::_val"]
        [::std::mem::offset_of!(_z_ring_iterator_t, _val) - 0usize];
    ["Offset of field: _z_ring_iterator_t::_ring"]
        [::std::mem::offset_of!(_z_ring_iterator_t, _ring) - 8usize];
    ["Offset of field: _z_ring_iterator_t::_r_idx"]
        [::std::mem::offset_of!(_z_ring_iterator_t, _r_idx) - 16usize];
    ["Offset of field: _z_ring_iterator_t::_w_idx"]
        [::std::mem::offset_of!(_z_ring_iterator_t, _w_idx) - 24usize];
};
#[doc = " Reverse iterator of a ring buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_reverse_iterator_t {
    pub _val: *mut ::std::os::raw::c_void,
    pub _ring: *const _z_ring_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_reverse_iterator_t"]
        [::std::mem::size_of::<_z_ring_reverse_iterator_t>() - 32usize];
    ["Alignment of _z_ring_reverse_iterator_t"]
        [::std::mem::align_of::<_z_ring_reverse_iterator_t>() - 8usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_val"]
        [::std::mem::offset_of!(_z_ring_reverse_iterator_t, _val) - 0usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_ring"]
        [::std::mem::offset_of!(_z_ring_reverse_iterator_t, _ring) - 8usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_r_idx"]
        [::std::mem::offset_of!(_z_ring_reverse_iterator_t, _r_idx) - 16usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_w_idx"]
        [::std::mem::offset_of!(_z_ring_reverse_iterator_t, _w_idx) - 24usize];
};
unsafe extern "C" {
    pub fn _z_ring_init(ring: *mut _z_ring_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_make(capacity: usize) -> _z_ring_t;
}
unsafe extern "C" {
    pub fn _z_ring_capacity(r: *const _z_ring_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_ring_len(r: *const _z_ring_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_ring_is_empty(r: *const _z_ring_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_is_full(r: *const _z_ring_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_push(
        r: *mut _z_ring_t,
        e: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_push_force(
        r: *mut _z_ring_t,
        e: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_push_force_drop(
        r: *mut _z_ring_t,
        e: *mut ::std::os::raw::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_ring_pull(r: *mut _z_ring_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_clone(xs: *const _z_ring_t, d_f: z_element_clone_f) -> *mut _z_ring_t;
}
unsafe extern "C" {
    pub fn _z_ring_clear(v: *mut _z_ring_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_free(xs: *mut *mut _z_ring_t, f_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_iterator_make(ring: *const _z_ring_t) -> _z_ring_iterator_t;
}
unsafe extern "C" {
    pub fn _z_ring_iterator_next(iter: *mut _z_ring_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_iterator_value(iter: *const _z_ring_iterator_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_reverse_iterator_make(ring: *const _z_ring_t) -> _z_ring_reverse_iterator_t;
}
unsafe extern "C" {
    pub fn _z_ring_reverse_iterator_next(iter: *mut _z_ring_reverse_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_reverse_iterator_value(
        iter: *const _z_ring_reverse_iterator_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " A zenoh-net data sample.\n\n A sample is the value associated to a given resource at a given point in time.\n\n Members:\n   _z_keyexpr_t key: The resource key of this data sample.\n   _z_slice_t value: The value of this data sample.\n   _z_encoding_t encoding: The encoding for the value of this data sample.\n   _z_source_info_t source_info: The source info for this data sample (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sample_t {
    pub keyexpr: _z_keyexpr_t,
    pub payload: _z_bytes_t,
    pub timestamp: _z_timestamp_t,
    pub encoding: _z_encoding_t,
    pub kind: z_sample_kind_t,
    pub qos: _z_qos_t,
    pub attachment: _z_bytes_t,
    pub reliability: z_reliability_t,
    pub source_info: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sample_t"][::std::mem::size_of::<_z_sample_t>() - 224usize];
    ["Alignment of _z_sample_t"][::std::mem::align_of::<_z_sample_t>() - 8usize];
    ["Offset of field: _z_sample_t::keyexpr"]
        [::std::mem::offset_of!(_z_sample_t, keyexpr) - 0usize];
    ["Offset of field: _z_sample_t::payload"]
        [::std::mem::offset_of!(_z_sample_t, payload) - 48usize];
    ["Offset of field: _z_sample_t::timestamp"]
        [::std::mem::offset_of!(_z_sample_t, timestamp) - 80usize];
    ["Offset of field: _z_sample_t::encoding"]
        [::std::mem::offset_of!(_z_sample_t, encoding) - 112usize];
    ["Offset of field: _z_sample_t::kind"][::std::mem::offset_of!(_z_sample_t, kind) - 152usize];
    ["Offset of field: _z_sample_t::qos"][::std::mem::offset_of!(_z_sample_t, qos) - 156usize];
    ["Offset of field: _z_sample_t::attachment"]
        [::std::mem::offset_of!(_z_sample_t, attachment) - 160usize];
    ["Offset of field: _z_sample_t::reliability"]
        [::std::mem::offset_of!(_z_sample_t, reliability) - 192usize];
    ["Offset of field: _z_sample_t::source_info"]
        [::std::mem::offset_of!(_z_sample_t, source_info) - 196usize];
};
unsafe extern "C" {
    pub fn _z_sample_clear(sample: *mut _z_sample_t);
}
unsafe extern "C" {
    pub fn _z_sample_steal_data(
        dst: *mut _z_sample_t,
        key: *mut _z_keyexpr_t,
        payload: *mut _z_bytes_t,
        timestamp: *const _z_timestamp_t,
        encoding: *mut _z_encoding_t,
        kind: z_sample_kind_t,
        qos: _z_qos_t,
        attachment: *mut _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *mut _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_sample_copy_data(
        dst: *mut _z_sample_t,
        key: *const _z_keyexpr_t,
        payload: *const _z_bytes_t,
        timestamp: *const _z_timestamp_t,
        encoding: *const _z_encoding_t,
        kind: z_sample_kind_t,
        qos: _z_qos_t,
        attachment: *const _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *const _z_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_sample_move(dst: *mut _z_sample_t, src: *mut _z_sample_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Free a :c:type:`_z_sample_t`, including its internal fields.\n\n Parameters:\n     sample: The :c:type:`_z_sample_t` to free."]
    pub fn _z_sample_free(sample: *mut *mut _z_sample_t);
}
unsafe extern "C" {
    pub fn _z_sample_copy(dst: *mut _z_sample_t, src: *const _z_sample_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_sample_duplicate(src: *const _z_sample_t) -> _z_sample_t;
}
pub type _z_sample_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_sample_t, right: *const _z_sample_t) -> bool,
>;
pub type _z_sample_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_sample_t,
        right: *const _z_sample_t,
    ) -> ::std::os::raw::c_int,
>;
pub type _z_sample_ring_t = _z_ring_t;
#[doc = " Forward iterator of a ring buffer."]
pub type _z_sample_ring_iterator_t = _z_ring_iterator_t;
#[doc = " Reverse iterator of a ring buffer."]
pub type _z_sample_ring_reverse_iterator_t = _z_ring_reverse_iterator_t;
pub const _z_reply_tag_t__Z_REPLY_TAG_DATA: _z_reply_tag_t = 0;
pub const _z_reply_tag_t__Z_REPLY_TAG_FINAL: _z_reply_tag_t = 1;
pub const _z_reply_tag_t__Z_REPLY_TAG_ERROR: _z_reply_tag_t = 2;
pub const _z_reply_tag_t__Z_REPLY_TAG_NONE: _z_reply_tag_t = 3;
#[doc = " Reply tag values.\n\n Enumerators:\n     _Z_REPLY_TAG_DATA: Tag identifying that the reply contains some data.\n     _Z_REPLY_TAG_FINAL: Tag identifying that the reply does not contain any data and that there will be no more\n         replies for this query.\n     _Z_REPLY_TAG_ERROR: Tag identifying that the reply contains error.\n     _Z_REPLY_TAG_NONE: Tag identifying empty reply."]
pub type _z_reply_tag_t = ::std::os::raw::c_uint;
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_sample_t data: a :c:type:`_z_sample_t` containing the key and value of the reply.\n   _z_slice_t replier_id: The id of the entity that sent this reply.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_data_t {
    pub _result: _z_reply_data_t__bindgen_ty_1,
    pub replier_id: _z_entity_global_id_t,
    pub _tag: _z_reply_tag_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_reply_data_t__bindgen_ty_1 {
    pub error: _z_value_t,
    pub sample: _z_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_data_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_reply_data_t__bindgen_ty_1>() - 224usize];
    ["Alignment of _z_reply_data_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_reply_data_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_reply_data_t__bindgen_ty_1::error"]
        [::std::mem::offset_of!(_z_reply_data_t__bindgen_ty_1, error) - 0usize];
    ["Offset of field: _z_reply_data_t__bindgen_ty_1::sample"]
        [::std::mem::offset_of!(_z_reply_data_t__bindgen_ty_1, sample) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_data_t"][::std::mem::size_of::<_z_reply_data_t>() - 248usize];
    ["Alignment of _z_reply_data_t"][::std::mem::align_of::<_z_reply_data_t>() - 8usize];
    ["Offset of field: _z_reply_data_t::_result"]
        [::std::mem::offset_of!(_z_reply_data_t, _result) - 0usize];
    ["Offset of field: _z_reply_data_t::replier_id"]
        [::std::mem::offset_of!(_z_reply_data_t, replier_id) - 224usize];
    ["Offset of field: _z_reply_data_t::_tag"]
        [::std::mem::offset_of!(_z_reply_data_t, _tag) - 244usize];
};
unsafe extern "C" {
    pub fn _z_reply_data_clear(rd: *mut _z_reply_data_t);
}
unsafe extern "C" {
    pub fn _z_reply_data_copy(dst: *mut _z_reply_data_t, src: *const _z_reply_data_t)
        -> z_result_t;
}
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_reply_t_Tag tag: Indicates if the reply contains data or if it's a FINAL reply.\n   _z_reply_data_t data: The reply data if :c:member:`_z_reply_t.tag` equals\n :c:member:`_z_reply_t_Tag._Z_REPLY_TAG_DATA`.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_t {
    pub data: _z_reply_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_t"][::std::mem::size_of::<_z_reply_t>() - 248usize];
    ["Alignment of _z_reply_t"][::std::mem::align_of::<_z_reply_t>() - 8usize];
    ["Offset of field: _z_reply_t::data"][::std::mem::offset_of!(_z_reply_t, data) - 0usize];
};
unsafe extern "C" {
    pub fn _z_reply_steal_data(
        dst: *mut _z_reply_t,
        keyexpr: *mut _z_keyexpr_t,
        replier_id: _z_entity_global_id_t,
        payload: *mut _z_bytes_t,
        timestamp: *const _z_timestamp_t,
        encoding: *mut _z_encoding_t,
        kind: z_sample_kind_t,
        attachment: *mut _z_bytes_t,
        source_info: *mut _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_reply_err_steal_data(
        dst: *mut _z_reply_t,
        payload: *mut _z_bytes_t,
        encoding: *mut _z_encoding_t,
        replier_id: _z_entity_global_id_t,
    );
}
unsafe extern "C" {
    pub fn _z_reply_move(dst: *mut _z_reply_t, src: *mut _z_reply_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_reply_clear(src: *mut _z_reply_t);
}
unsafe extern "C" {
    pub fn _z_reply_free(hello: *mut *mut _z_reply_t);
}
unsafe extern "C" {
    pub fn _z_reply_copy(dst: *mut _z_reply_t, src: *const _z_reply_t) -> z_result_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_pending_reply_t {
    pub _reply: _z_reply_t,
    pub _tstamp: _z_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_pending_reply_t"][::std::mem::size_of::<_z_pending_reply_t>() - 280usize];
    ["Alignment of _z_pending_reply_t"][::std::mem::align_of::<_z_pending_reply_t>() - 8usize];
    ["Offset of field: _z_pending_reply_t::_reply"]
        [::std::mem::offset_of!(_z_pending_reply_t, _reply) - 0usize];
    ["Offset of field: _z_pending_reply_t::_tstamp"]
        [::std::mem::offset_of!(_z_pending_reply_t, _tstamp) - 248usize];
};
unsafe extern "C" {
    pub fn _z_pending_reply_eq(
        one: *const _z_pending_reply_t,
        two: *const _z_pending_reply_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_pending_reply_clear(res: *mut _z_pending_reply_t);
}
pub type _z_pending_reply_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _z_pending_reply_t, right: *const _z_pending_reply_t) -> bool,
>;
pub type _z_pending_reply_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _z_pending_reply_t,
        right: *const _z_pending_reply_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return type when declaring a subscriber."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscriber_t {
    pub _entity_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscriber_t"][::std::mem::size_of::<_z_subscriber_t>() - 24usize];
    ["Alignment of _z_subscriber_t"][::std::mem::align_of::<_z_subscriber_t>() - 8usize];
    ["Offset of field: _z_subscriber_t::_entity_id"]
        [::std::mem::offset_of!(_z_subscriber_t, _entity_id) - 0usize];
    ["Offset of field: _z_subscriber_t::_zn"]
        [::std::mem::offset_of!(_z_subscriber_t, _zn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_subscriber_clear(sub: *mut _z_subscriber_t);
}
unsafe extern "C" {
    pub fn _z_subscriber_free(sub: *mut *mut _z_subscriber_t);
}
#[doc = " Represents a Zenoh ID.\n\n In general, valid Zenoh IDs are LSB-first 128bit unsigned and non-zero integers.\n\n Members:\n   uint8_t id[16]: The array containing the 16 octets of a Zenoh ID."]
pub type z_id_t = _z_id_t;
#[doc = "  Represents an ID globally identifying an entity in a Zenoh system."]
pub type z_entity_global_id_t = _z_entity_global_id_t;
#[doc = " A zenoh timestamp."]
pub type z_timestamp_t = _z_timestamp_t;
#[doc = " Represents an array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_slice_t {
    #[doc = " Represents an array of bytes."]
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_slice_t"][::std::mem::size_of::<z_owned_slice_t>() - 32usize];
    ["Alignment of z_owned_slice_t"][::std::mem::align_of::<z_owned_slice_t>() - 8usize];
    ["Offset of field: z_owned_slice_t::_val"]
        [::std::mem::offset_of!(z_owned_slice_t, _val) - 0usize];
};
#[doc = " Represents an array of bytes."]
pub type z_loaned_slice_t = _z_slice_t;
#[doc = " Represents an array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_slice_t {
    pub _this: z_owned_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_slice_t"][::std::mem::size_of::<z_moved_slice_t>() - 32usize];
    ["Alignment of z_moved_slice_t"][::std::mem::align_of::<z_moved_slice_t>() - 8usize];
    ["Offset of field: z_moved_slice_t::_this"]
        [::std::mem::offset_of!(z_moved_slice_t, _this) - 0usize];
};
#[doc = " Represents an array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_slice_t {
    #[doc = " Represents an array of bytes."]
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_slice_t"][::std::mem::size_of::<z_view_slice_t>() - 32usize];
    ["Alignment of z_view_slice_t"][::std::mem::align_of::<z_view_slice_t>() - 8usize];
    ["Offset of field: z_view_slice_t::_val"]
        [::std::mem::offset_of!(z_view_slice_t, _val) - 0usize];
};
#[doc = " Represents a container for slices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_bytes_t {
    #[doc = " Represents a container for slices."]
    pub _val: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_bytes_t"][::std::mem::size_of::<z_owned_bytes_t>() - 32usize];
    ["Alignment of z_owned_bytes_t"][::std::mem::align_of::<z_owned_bytes_t>() - 8usize];
    ["Offset of field: z_owned_bytes_t::_val"]
        [::std::mem::offset_of!(z_owned_bytes_t, _val) - 0usize];
};
#[doc = " Represents a container for slices."]
pub type z_loaned_bytes_t = _z_bytes_t;
#[doc = " Represents a container for slices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_bytes_t {
    pub _this: z_owned_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_bytes_t"][::std::mem::size_of::<z_moved_bytes_t>() - 32usize];
    ["Alignment of z_moved_bytes_t"][::std::mem::align_of::<z_moved_bytes_t>() - 8usize];
    ["Offset of field: z_moved_bytes_t::_this"]
        [::std::mem::offset_of!(z_moved_bytes_t, _this) - 0usize];
};
#[doc = " Represents a writer for data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_bytes_writer_t {
    #[doc = " Represents a writer for data."]
    pub _val: _z_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_bytes_writer_t"][::std::mem::size_of::<z_owned_bytes_writer_t>() - 40usize];
    ["Alignment of z_owned_bytes_writer_t"]
        [::std::mem::align_of::<z_owned_bytes_writer_t>() - 8usize];
    ["Offset of field: z_owned_bytes_writer_t::_val"]
        [::std::mem::offset_of!(z_owned_bytes_writer_t, _val) - 0usize];
};
#[doc = " Represents a writer for data."]
pub type z_loaned_bytes_writer_t = _z_bytes_writer_t;
#[doc = " Represents a writer for data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_bytes_writer_t {
    pub _this: z_owned_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_bytes_writer_t"][::std::mem::size_of::<z_moved_bytes_writer_t>() - 40usize];
    ["Alignment of z_moved_bytes_writer_t"]
        [::std::mem::align_of::<z_moved_bytes_writer_t>() - 8usize];
    ["Offset of field: z_moved_bytes_writer_t::_this"]
        [::std::mem::offset_of!(z_moved_bytes_writer_t, _this) - 0usize];
};
#[doc = " A reader for data."]
pub type z_bytes_reader_t = _z_bytes_reader_t;
#[doc = " An iterator over slices of data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_bytes_slice_iterator_t {
    pub _bytes: *const _z_bytes_t,
    pub _slice_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_bytes_slice_iterator_t"]
        [::std::mem::size_of::<z_bytes_slice_iterator_t>() - 16usize];
    ["Alignment of z_bytes_slice_iterator_t"]
        [::std::mem::align_of::<z_bytes_slice_iterator_t>() - 8usize];
    ["Offset of field: z_bytes_slice_iterator_t::_bytes"]
        [::std::mem::offset_of!(z_bytes_slice_iterator_t, _bytes) - 0usize];
    ["Offset of field: z_bytes_slice_iterator_t::_slice_idx"]
        [::std::mem::offset_of!(z_bytes_slice_iterator_t, _slice_idx) - 8usize];
};
#[doc = " Represents a string without null-terminator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_string_t {
    #[doc = " Represents a string without null-terminator."]
    pub _val: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_string_t"][::std::mem::size_of::<z_owned_string_t>() - 32usize];
    ["Alignment of z_owned_string_t"][::std::mem::align_of::<z_owned_string_t>() - 8usize];
    ["Offset of field: z_owned_string_t::_val"]
        [::std::mem::offset_of!(z_owned_string_t, _val) - 0usize];
};
#[doc = " Represents a string without null-terminator."]
pub type z_loaned_string_t = _z_string_t;
#[doc = " Represents a string without null-terminator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_string_t {
    pub _this: z_owned_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_string_t"][::std::mem::size_of::<z_moved_string_t>() - 32usize];
    ["Alignment of z_moved_string_t"][::std::mem::align_of::<z_moved_string_t>() - 8usize];
    ["Offset of field: z_moved_string_t::_this"]
        [::std::mem::offset_of!(z_moved_string_t, _this) - 0usize];
};
#[doc = " Represents a string without null-terminator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_string_t {
    #[doc = " Represents a string without null-terminator."]
    pub _val: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_string_t"][::std::mem::size_of::<z_view_string_t>() - 32usize];
    ["Alignment of z_view_string_t"][::std::mem::align_of::<z_view_string_t>() - 8usize];
    ["Offset of field: z_view_string_t::_val"]
        [::std::mem::offset_of!(z_view_string_t, _val) - 0usize];
};
#[doc = " Represents a key expression in Zenoh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_keyexpr_t {
    #[doc = " Represents a key expression in Zenoh."]
    pub _val: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_keyexpr_t"][::std::mem::size_of::<z_owned_keyexpr_t>() - 48usize];
    ["Alignment of z_owned_keyexpr_t"][::std::mem::align_of::<z_owned_keyexpr_t>() - 8usize];
    ["Offset of field: z_owned_keyexpr_t::_val"]
        [::std::mem::offset_of!(z_owned_keyexpr_t, _val) - 0usize];
};
#[doc = " Represents a key expression in Zenoh."]
pub type z_loaned_keyexpr_t = _z_keyexpr_t;
#[doc = " Represents a key expression in Zenoh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_keyexpr_t {
    pub _this: z_owned_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_keyexpr_t"][::std::mem::size_of::<z_moved_keyexpr_t>() - 48usize];
    ["Alignment of z_moved_keyexpr_t"][::std::mem::align_of::<z_moved_keyexpr_t>() - 8usize];
    ["Offset of field: z_moved_keyexpr_t::_this"]
        [::std::mem::offset_of!(z_moved_keyexpr_t, _this) - 0usize];
};
#[doc = " Represents a key expression in Zenoh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_keyexpr_t {
    #[doc = " Represents a key expression in Zenoh."]
    pub _val: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_keyexpr_t"][::std::mem::size_of::<z_view_keyexpr_t>() - 48usize];
    ["Alignment of z_view_keyexpr_t"][::std::mem::align_of::<z_view_keyexpr_t>() - 8usize];
    ["Offset of field: z_view_keyexpr_t::_val"]
        [::std::mem::offset_of!(z_view_keyexpr_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_config_t {
    #[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
    pub _val: _z_config_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_config_t"][::std::mem::size_of::<z_owned_config_t>() - 32usize];
    ["Alignment of z_owned_config_t"][::std::mem::align_of::<z_owned_config_t>() - 8usize];
    ["Offset of field: z_owned_config_t::_val"]
        [::std::mem::offset_of!(z_owned_config_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
pub type z_loaned_config_t = _z_config_t;
#[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_config_t {
    pub _this: z_owned_config_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_config_t"][::std::mem::size_of::<z_moved_config_t>() - 32usize];
    ["Alignment of z_moved_config_t"][::std::mem::align_of::<z_moved_config_t>() - 8usize];
    ["Offset of field: z_moved_config_t::_this"]
        [::std::mem::offset_of!(z_moved_config_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_session_t {
    #[doc = " Represents a Zenoh Session."]
    pub _rc: _z_session_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_session_t"][::std::mem::size_of::<z_owned_session_t>() - 16usize];
    ["Alignment of z_owned_session_t"][::std::mem::align_of::<z_owned_session_t>() - 8usize];
    ["Offset of field: z_owned_session_t::_rc"]
        [::std::mem::offset_of!(z_owned_session_t, _rc) - 0usize];
};
#[doc = " Represents a Zenoh Session."]
pub type z_loaned_session_t = _z_session_rc_t;
#[doc = " Represents a Zenoh Session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_session_t {
    pub _this: z_owned_session_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_session_t"][::std::mem::size_of::<z_moved_session_t>() - 16usize];
    ["Alignment of z_moved_session_t"][::std::mem::align_of::<z_moved_session_t>() - 8usize];
    ["Offset of field: z_moved_session_t::_this"]
        [::std::mem::offset_of!(z_moved_session_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Subscriber entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_subscriber_t {
    #[doc = " Represents a Zenoh Subscriber entity."]
    pub _val: _z_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_subscriber_t"][::std::mem::size_of::<z_owned_subscriber_t>() - 24usize];
    ["Alignment of z_owned_subscriber_t"][::std::mem::align_of::<z_owned_subscriber_t>() - 8usize];
    ["Offset of field: z_owned_subscriber_t::_val"]
        [::std::mem::offset_of!(z_owned_subscriber_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Subscriber entity."]
pub type z_loaned_subscriber_t = _z_subscriber_t;
#[doc = " Represents a Zenoh Subscriber entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_subscriber_t {
    pub _this: z_owned_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_subscriber_t"][::std::mem::size_of::<z_moved_subscriber_t>() - 24usize];
    ["Alignment of z_moved_subscriber_t"][::std::mem::align_of::<z_moved_subscriber_t>() - 8usize];
    ["Offset of field: z_moved_subscriber_t::_this"]
        [::std::mem::offset_of!(z_moved_subscriber_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Publisher entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_publisher_t {
    #[doc = " Represents a Zenoh Publisher entity."]
    pub _val: _z_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_publisher_t"][::std::mem::size_of::<z_owned_publisher_t>() - 144usize];
    ["Alignment of z_owned_publisher_t"][::std::mem::align_of::<z_owned_publisher_t>() - 8usize];
    ["Offset of field: z_owned_publisher_t::_val"]
        [::std::mem::offset_of!(z_owned_publisher_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Publisher entity."]
pub type z_loaned_publisher_t = _z_publisher_t;
#[doc = " Represents a Zenoh Publisher entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_publisher_t {
    pub _this: z_owned_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_publisher_t"][::std::mem::size_of::<z_moved_publisher_t>() - 144usize];
    ["Alignment of z_moved_publisher_t"][::std::mem::align_of::<z_moved_publisher_t>() - 8usize];
    ["Offset of field: z_moved_publisher_t::_this"]
        [::std::mem::offset_of!(z_moved_publisher_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Querier entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_querier_t {
    #[doc = " Represents a Zenoh Querier entity."]
    pub _val: _z_querier_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_querier_t"][::std::mem::size_of::<z_owned_querier_t>() - 160usize];
    ["Alignment of z_owned_querier_t"][::std::mem::align_of::<z_owned_querier_t>() - 8usize];
    ["Offset of field: z_owned_querier_t::_val"]
        [::std::mem::offset_of!(z_owned_querier_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Querier entity."]
pub type z_loaned_querier_t = _z_querier_t;
#[doc = " Represents a Zenoh Querier entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_querier_t {
    pub _this: z_owned_querier_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_querier_t"][::std::mem::size_of::<z_moved_querier_t>() - 160usize];
    ["Alignment of z_moved_querier_t"][::std::mem::align_of::<z_moved_querier_t>() - 8usize];
    ["Offset of field: z_moved_querier_t::_this"]
        [::std::mem::offset_of!(z_moved_querier_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Matching listener entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_matching_listener_t {
    #[doc = " Represents a Zenoh Matching listener entity."]
    pub _val: _z_matching_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_matching_listener_t"]
        [::std::mem::size_of::<z_owned_matching_listener_t>() - 24usize];
    ["Alignment of z_owned_matching_listener_t"]
        [::std::mem::align_of::<z_owned_matching_listener_t>() - 8usize];
    ["Offset of field: z_owned_matching_listener_t::_val"]
        [::std::mem::offset_of!(z_owned_matching_listener_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Matching listener entity."]
pub type z_loaned_matching_listener_t = _z_matching_listener_t;
#[doc = " Represents a Zenoh Matching listener entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_matching_listener_t {
    pub _this: z_owned_matching_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_matching_listener_t"]
        [::std::mem::size_of::<z_moved_matching_listener_t>() - 24usize];
    ["Alignment of z_moved_matching_listener_t"]
        [::std::mem::align_of::<z_moved_matching_listener_t>() - 8usize];
    ["Offset of field: z_moved_matching_listener_t::_this"]
        [::std::mem::offset_of!(z_moved_matching_listener_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Queryable entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_queryable_t {
    #[doc = " Represents a Zenoh Queryable entity."]
    pub _val: _z_queryable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_queryable_t"][::std::mem::size_of::<z_owned_queryable_t>() - 24usize];
    ["Alignment of z_owned_queryable_t"][::std::mem::align_of::<z_owned_queryable_t>() - 8usize];
    ["Offset of field: z_owned_queryable_t::_val"]
        [::std::mem::offset_of!(z_owned_queryable_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Queryable entity."]
pub type z_loaned_queryable_t = _z_queryable_t;
#[doc = " Represents a Zenoh Queryable entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_queryable_t {
    pub _this: z_owned_queryable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_queryable_t"][::std::mem::size_of::<z_moved_queryable_t>() - 24usize];
    ["Alignment of z_moved_queryable_t"][::std::mem::align_of::<z_moved_queryable_t>() - 8usize];
    ["Offset of field: z_moved_queryable_t::_this"]
        [::std::mem::offset_of!(z_moved_queryable_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_query_t {
    #[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
    pub _rc: _z_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_query_t"][::std::mem::size_of::<z_owned_query_t>() - 16usize];
    ["Alignment of z_owned_query_t"][::std::mem::align_of::<z_owned_query_t>() - 8usize];
    ["Offset of field: z_owned_query_t::_rc"]
        [::std::mem::offset_of!(z_owned_query_t, _rc) - 0usize];
};
#[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
pub type z_loaned_query_t = _z_query_rc_t;
#[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_query_t {
    pub _this: z_owned_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_query_t"][::std::mem::size_of::<z_moved_query_t>() - 16usize];
    ["Alignment of z_moved_query_t"][::std::mem::align_of::<z_moved_query_t>() - 8usize];
    ["Offset of field: z_moved_query_t::_this"]
        [::std::mem::offset_of!(z_moved_query_t, _this) - 0usize];
};
#[doc = " Represents the encoding of a payload, in a MIME-like format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_encoding_t {
    #[doc = " Represents the encoding of a payload, in a MIME-like format."]
    pub _val: _z_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_encoding_t"][::std::mem::size_of::<z_owned_encoding_t>() - 40usize];
    ["Alignment of z_owned_encoding_t"][::std::mem::align_of::<z_owned_encoding_t>() - 8usize];
    ["Offset of field: z_owned_encoding_t::_val"]
        [::std::mem::offset_of!(z_owned_encoding_t, _val) - 0usize];
};
#[doc = " Represents the encoding of a payload, in a MIME-like format."]
pub type z_loaned_encoding_t = _z_encoding_t;
#[doc = " Represents the encoding of a payload, in a MIME-like format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_encoding_t {
    pub _this: z_owned_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_encoding_t"][::std::mem::size_of::<z_moved_encoding_t>() - 40usize];
    ["Alignment of z_moved_encoding_t"][::std::mem::align_of::<z_moved_encoding_t>() - 8usize];
    ["Offset of field: z_moved_encoding_t::_this"]
        [::std::mem::offset_of!(z_moved_encoding_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh reply error."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_reply_err_t {
    #[doc = " Represents a Zenoh reply error."]
    pub _val: _z_value_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_reply_err_t"][::std::mem::size_of::<z_owned_reply_err_t>() - 72usize];
    ["Alignment of z_owned_reply_err_t"][::std::mem::align_of::<z_owned_reply_err_t>() - 8usize];
    ["Offset of field: z_owned_reply_err_t::_val"]
        [::std::mem::offset_of!(z_owned_reply_err_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh reply error."]
pub type z_loaned_reply_err_t = _z_value_t;
#[doc = " Represents a Zenoh reply error."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_reply_err_t {
    pub _this: z_owned_reply_err_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_reply_err_t"][::std::mem::size_of::<z_moved_reply_err_t>() - 72usize];
    ["Alignment of z_moved_reply_err_t"][::std::mem::align_of::<z_moved_reply_err_t>() - 8usize];
    ["Offset of field: z_moved_reply_err_t::_this"]
        [::std::mem::offset_of!(z_moved_reply_err_t, _this) - 0usize];
};
#[doc = " Represents sample source information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_source_info_t {
    #[doc = " Represents sample source information."]
    pub _val: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_source_info_t"][::std::mem::size_of::<z_owned_source_info_t>() - 24usize];
    ["Alignment of z_owned_source_info_t"]
        [::std::mem::align_of::<z_owned_source_info_t>() - 4usize];
    ["Offset of field: z_owned_source_info_t::_val"]
        [::std::mem::offset_of!(z_owned_source_info_t, _val) - 0usize];
};
#[doc = " Represents sample source information."]
pub type z_loaned_source_info_t = _z_source_info_t;
#[doc = " Represents sample source information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_source_info_t {
    pub _this: z_owned_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_source_info_t"][::std::mem::size_of::<z_moved_source_info_t>() - 24usize];
    ["Alignment of z_moved_source_info_t"]
        [::std::mem::align_of::<z_moved_source_info_t>() - 4usize];
    ["Offset of field: z_moved_source_info_t::_this"]
        [::std::mem::offset_of!(z_moved_source_info_t, _this) - 0usize];
};
#[doc = " A struct that indicates if there exist Subscribers matching the Publisher's key expression or Queryables matching\n Querier's key expression and target.\n Members:\n   bool matching: true if there exist matching Zenoh entities, false otherwise."]
pub type z_matching_status_t = _z_matching_status_t;
#[doc = " Represents the configuration used to configure a subscriber upon declaration :c:func:`z_declare_subscriber`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_subscriber_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_subscriber_options_t"][::std::mem::size_of::<z_subscriber_options_t>() - 1usize];
    ["Alignment of z_subscriber_options_t"]
        [::std::mem::align_of::<z_subscriber_options_t>() - 1usize];
    ["Offset of field: z_subscriber_options_t::__dummy"]
        [::std::mem::offset_of!(z_subscriber_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a zenoh upon opening :c:func:`z_open`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_open_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_open_options_t"][::std::mem::size_of::<z_open_options_t>() - 1usize];
    ["Alignment of z_open_options_t"][::std::mem::align_of::<z_open_options_t>() - 1usize];
    ["Offset of field: z_open_options_t::__dummy"]
        [::std::mem::offset_of!(z_open_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a zenoh upon closing :c:func:`z_close`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_close_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_close_options_t"][::std::mem::size_of::<z_close_options_t>() - 1usize];
    ["Alignment of z_close_options_t"][::std::mem::align_of::<z_close_options_t>() - 1usize];
    ["Offset of field: z_close_options_t::__dummy"]
        [::std::mem::offset_of!(z_close_options_t, __dummy) - 0usize];
};
#[doc = " Represents the reply consolidation mode to apply on replies to a :c:func:`z_get`.\n\n Members:\n   z_consolidation_mode_t mode: the consolidation mode, see :c:type:`z_consolidation_mode_t`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_consolidation_t {
    pub mode: z_consolidation_mode_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_consolidation_t"][::std::mem::size_of::<z_query_consolidation_t>() - 4usize];
    ["Alignment of z_query_consolidation_t"]
        [::std::mem::align_of::<z_query_consolidation_t>() - 4usize];
    ["Offset of field: z_query_consolidation_t::mode"]
        [::std::mem::offset_of!(z_query_consolidation_t, mode) - 0usize];
};
#[doc = " Represents the configuration used to configure a publisher upon declaration with :c:func:`z_declare_publisher`.\n\n Members:\n   z_moved_encoding_t *encoding: Default encoding for messages put by this publisher.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing messages from this\n     publisher.\n   z_priority_t priority: The priority of messages issued by this publisher.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_options_t"][::std::mem::size_of::<z_publisher_options_t>() - 24usize];
    ["Alignment of z_publisher_options_t"]
        [::std::mem::align_of::<z_publisher_options_t>() - 8usize];
    ["Offset of field: z_publisher_options_t::encoding"]
        [::std::mem::offset_of!(z_publisher_options_t, encoding) - 0usize];
    ["Offset of field: z_publisher_options_t::congestion_control"]
        [::std::mem::offset_of!(z_publisher_options_t, congestion_control) - 8usize];
    ["Offset of field: z_publisher_options_t::priority"]
        [::std::mem::offset_of!(z_publisher_options_t, priority) - 12usize];
    ["Offset of field: z_publisher_options_t::is_express"]
        [::std::mem::offset_of!(z_publisher_options_t, is_express) - 16usize];
};
#[doc = " Options passed to the :c:func:`z_declare_querier()` function.\n\n Members:\n   z_moved_encoding_t *encoding: Default encoding for values sent by this querier.\n   z_query_target_t target: The Queryables that should be target of the querier queries.\n   z_query_consolidation_t consolidation: The replies consolidation strategy to apply on replies to the querier\n    queries.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing the querier queries.\n   bool is_express: If set to ``true``, the querier queries will not be batched. This usually has a positive impact on\n \t   latency but negative impact on throughput.\n   z_priority_t priority: The priority of the querier queries.\n   uint64_t timeout_ms: The timeout for the querier queries in milliseconds. 0 means default query timeout from zenoh\n     configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_querier_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub target: z_query_target_t,
    pub consolidation: z_query_consolidation_t,
    pub congestion_control: z_congestion_control_t,
    pub is_express: bool,
    pub priority: z_priority_t,
    pub timeout_ms: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_querier_options_t"][::std::mem::size_of::<z_querier_options_t>() - 40usize];
    ["Alignment of z_querier_options_t"][::std::mem::align_of::<z_querier_options_t>() - 8usize];
    ["Offset of field: z_querier_options_t::encoding"]
        [::std::mem::offset_of!(z_querier_options_t, encoding) - 0usize];
    ["Offset of field: z_querier_options_t::target"]
        [::std::mem::offset_of!(z_querier_options_t, target) - 8usize];
    ["Offset of field: z_querier_options_t::consolidation"]
        [::std::mem::offset_of!(z_querier_options_t, consolidation) - 12usize];
    ["Offset of field: z_querier_options_t::congestion_control"]
        [::std::mem::offset_of!(z_querier_options_t, congestion_control) - 16usize];
    ["Offset of field: z_querier_options_t::is_express"]
        [::std::mem::offset_of!(z_querier_options_t, is_express) - 20usize];
    ["Offset of field: z_querier_options_t::priority"]
        [::std::mem::offset_of!(z_querier_options_t, priority) - 24usize];
    ["Offset of field: z_querier_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_querier_options_t, timeout_ms) - 32usize];
};
#[doc = " Options passed to the :c:func:`z_querier_get()` function.\n\n Members:\n   z_moved_bytes_t *payload: An optional payload to attach to the query.\n   z_moved_encoding_t *encoding: An optional encoding of the query payload and or attachment.\n   z_moved_bytes_t *attachment: An optional attachment to attach to the query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_querier_get_options_t {
    pub payload: *mut z_moved_bytes_t,
    pub encoding: *mut z_moved_encoding_t,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_querier_get_options_t"][::std::mem::size_of::<z_querier_get_options_t>() - 24usize];
    ["Alignment of z_querier_get_options_t"]
        [::std::mem::align_of::<z_querier_get_options_t>() - 8usize];
    ["Offset of field: z_querier_get_options_t::payload"]
        [::std::mem::offset_of!(z_querier_get_options_t, payload) - 0usize];
    ["Offset of field: z_querier_get_options_t::encoding"]
        [::std::mem::offset_of!(z_querier_get_options_t, encoding) - 8usize];
    ["Offset of field: z_querier_get_options_t::attachment"]
        [::std::mem::offset_of!(z_querier_get_options_t, attachment) - 16usize];
};
#[doc = " Represents the configuration used to configure a queryable upon declaration :c:func:`z_declare_queryable`.\n\n Members:\n   bool complete: The completeness of the queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_queryable_options_t {
    pub complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_queryable_options_t"][::std::mem::size_of::<z_queryable_options_t>() - 1usize];
    ["Alignment of z_queryable_options_t"]
        [::std::mem::align_of::<z_queryable_options_t>() - 1usize];
    ["Offset of field: z_queryable_options_t::complete"]
        [::std::mem::offset_of!(z_queryable_options_t, complete) - 0usize];
};
#[doc = " Represents the configuration used to configure a query reply sent via :c:func:`z_query_reply`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the response.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_options_t"][::std::mem::size_of::<z_query_reply_options_t>() - 40usize];
    ["Alignment of z_query_reply_options_t"]
        [::std::mem::align_of::<z_query_reply_options_t>() - 8usize];
    ["Offset of field: z_query_reply_options_t::encoding"]
        [::std::mem::offset_of!(z_query_reply_options_t, encoding) - 0usize];
    ["Offset of field: z_query_reply_options_t::congestion_control"]
        [::std::mem::offset_of!(z_query_reply_options_t, congestion_control) - 8usize];
    ["Offset of field: z_query_reply_options_t::priority"]
        [::std::mem::offset_of!(z_query_reply_options_t, priority) - 12usize];
    ["Offset of field: z_query_reply_options_t::timestamp"]
        [::std::mem::offset_of!(z_query_reply_options_t, timestamp) - 16usize];
    ["Offset of field: z_query_reply_options_t::is_express"]
        [::std::mem::offset_of!(z_query_reply_options_t, is_express) - 24usize];
    ["Offset of field: z_query_reply_options_t::attachment"]
        [::std::mem::offset_of!(z_query_reply_options_t, attachment) - 32usize];
};
#[doc = " Represents the configuration used to configure a query reply delete sent via :c:func:`z_query_reply_del`.\n\n Members:\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the response.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_del_options_t {
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_del_options_t"]
        [::std::mem::size_of::<z_query_reply_del_options_t>() - 32usize];
    ["Alignment of z_query_reply_del_options_t"]
        [::std::mem::align_of::<z_query_reply_del_options_t>() - 8usize];
    ["Offset of field: z_query_reply_del_options_t::congestion_control"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, congestion_control) - 0usize];
    ["Offset of field: z_query_reply_del_options_t::priority"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, priority) - 4usize];
    ["Offset of field: z_query_reply_del_options_t::timestamp"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, timestamp) - 8usize];
    ["Offset of field: z_query_reply_del_options_t::is_express"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, is_express) - 16usize];
    ["Offset of field: z_query_reply_del_options_t::attachment"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, attachment) - 24usize];
};
#[doc = " Represents the configuration used to configure a query reply error sent via :c:func:`z_query_reply_err`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_err_options_t {
    pub encoding: *mut z_moved_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_err_options_t"]
        [::std::mem::size_of::<z_query_reply_err_options_t>() - 8usize];
    ["Alignment of z_query_reply_err_options_t"]
        [::std::mem::align_of::<z_query_reply_err_options_t>() - 8usize];
    ["Offset of field: z_query_reply_err_options_t::encoding"]
        [::std::mem::offset_of!(z_query_reply_err_options_t, encoding) - 0usize];
};
#[doc = " Represents the configuration used to configure a put operation sent via :c:func:`z_put`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the publication.\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_put_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_put_options_t"][::std::mem::size_of::<z_put_options_t>() - 40usize];
    ["Alignment of z_put_options_t"][::std::mem::align_of::<z_put_options_t>() - 8usize];
    ["Offset of field: z_put_options_t::encoding"]
        [::std::mem::offset_of!(z_put_options_t, encoding) - 0usize];
    ["Offset of field: z_put_options_t::congestion_control"]
        [::std::mem::offset_of!(z_put_options_t, congestion_control) - 8usize];
    ["Offset of field: z_put_options_t::priority"]
        [::std::mem::offset_of!(z_put_options_t, priority) - 12usize];
    ["Offset of field: z_put_options_t::timestamp"]
        [::std::mem::offset_of!(z_put_options_t, timestamp) - 16usize];
    ["Offset of field: z_put_options_t::is_express"]
        [::std::mem::offset_of!(z_put_options_t, is_express) - 24usize];
    ["Offset of field: z_put_options_t::attachment"]
        [::std::mem::offset_of!(z_put_options_t, attachment) - 32usize];
};
#[doc = " Represents the configuration used to configure a delete operation sent via :c:func:`z_delete`.\n\n Members:\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when router.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_delete_options_t {
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub timestamp: *mut z_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_delete_options_t"][::std::mem::size_of::<z_delete_options_t>() - 24usize];
    ["Alignment of z_delete_options_t"][::std::mem::align_of::<z_delete_options_t>() - 8usize];
    ["Offset of field: z_delete_options_t::congestion_control"]
        [::std::mem::offset_of!(z_delete_options_t, congestion_control) - 0usize];
    ["Offset of field: z_delete_options_t::priority"]
        [::std::mem::offset_of!(z_delete_options_t, priority) - 4usize];
    ["Offset of field: z_delete_options_t::is_express"]
        [::std::mem::offset_of!(z_delete_options_t, is_express) - 8usize];
    ["Offset of field: z_delete_options_t::timestamp"]
        [::std::mem::offset_of!(z_delete_options_t, timestamp) - 16usize];
};
#[doc = " Represents the configuration used to configure a put operation by a previously declared publisher,\n sent via :c:func:`z_publisher_put`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_moved_bytes_t* attachment: An optional attachment to the publication.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_put_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub timestamp: *mut z_timestamp_t,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_put_options_t"]
        [::std::mem::size_of::<z_publisher_put_options_t>() - 24usize];
    ["Alignment of z_publisher_put_options_t"]
        [::std::mem::align_of::<z_publisher_put_options_t>() - 8usize];
    ["Offset of field: z_publisher_put_options_t::encoding"]
        [::std::mem::offset_of!(z_publisher_put_options_t, encoding) - 0usize];
    ["Offset of field: z_publisher_put_options_t::timestamp"]
        [::std::mem::offset_of!(z_publisher_put_options_t, timestamp) - 8usize];
    ["Offset of field: z_publisher_put_options_t::attachment"]
        [::std::mem::offset_of!(z_publisher_put_options_t, attachment) - 16usize];
};
#[doc = " Represents the configuration used to configure a delete operation by a previously declared publisher,\n sent via :c:func:`z_publisher_delete`.\n\n Members:\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_delete_options_t {
    pub timestamp: *mut z_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_delete_options_t"]
        [::std::mem::size_of::<z_publisher_delete_options_t>() - 8usize];
    ["Alignment of z_publisher_delete_options_t"]
        [::std::mem::align_of::<z_publisher_delete_options_t>() - 8usize];
    ["Offset of field: z_publisher_delete_options_t::timestamp"]
        [::std::mem::offset_of!(z_publisher_delete_options_t, timestamp) - 0usize];
};
#[doc = " Represents the configuration used to configure a get operation sent via :c:func:`z_get`.\n\n Members:\n   z_moved_bytes_t* payload: The payload to include in the query.\n   z_moved_encoding_t* encoding: Payload encoding.\n   z_query_consolidation_t consolidation: The replies consolidation strategy to apply on replies.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing the query.\n   z_priority_t priority: The priority of the query.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_query_target_t target: The queryables that should be targeted by this get.\n   z_moved_bytes_t* attachment: An optional attachment to the query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_get_options_t {
    pub payload: *mut z_moved_bytes_t,
    pub encoding: *mut z_moved_encoding_t,
    pub consolidation: z_query_consolidation_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub target: z_query_target_t,
    pub timeout_ms: u64,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_get_options_t"][::std::mem::size_of::<z_get_options_t>() - 56usize];
    ["Alignment of z_get_options_t"][::std::mem::align_of::<z_get_options_t>() - 8usize];
    ["Offset of field: z_get_options_t::payload"]
        [::std::mem::offset_of!(z_get_options_t, payload) - 0usize];
    ["Offset of field: z_get_options_t::encoding"]
        [::std::mem::offset_of!(z_get_options_t, encoding) - 8usize];
    ["Offset of field: z_get_options_t::consolidation"]
        [::std::mem::offset_of!(z_get_options_t, consolidation) - 16usize];
    ["Offset of field: z_get_options_t::congestion_control"]
        [::std::mem::offset_of!(z_get_options_t, congestion_control) - 20usize];
    ["Offset of field: z_get_options_t::priority"]
        [::std::mem::offset_of!(z_get_options_t, priority) - 24usize];
    ["Offset of field: z_get_options_t::is_express"]
        [::std::mem::offset_of!(z_get_options_t, is_express) - 28usize];
    ["Offset of field: z_get_options_t::target"]
        [::std::mem::offset_of!(z_get_options_t, target) - 32usize];
    ["Offset of field: z_get_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_get_options_t, timeout_ms) - 40usize];
    ["Offset of field: z_get_options_t::attachment"]
        [::std::mem::offset_of!(z_get_options_t, attachment) - 48usize];
};
#[doc = " Represents the configuration used to configure a read task started via :c:func:`zp_start_read_task`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_task_read_options_t {
    pub task_attributes: *mut z_task_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_task_read_options_t"][::std::mem::size_of::<zp_task_read_options_t>() - 8usize];
    ["Alignment of zp_task_read_options_t"]
        [::std::mem::align_of::<zp_task_read_options_t>() - 8usize];
    ["Offset of field: zp_task_read_options_t::task_attributes"]
        [::std::mem::offset_of!(zp_task_read_options_t, task_attributes) - 0usize];
};
#[doc = " Represents the configuration used to configure a lease task started via :c:func:`zp_start_lease_task`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_task_lease_options_t {
    pub task_attributes: *mut z_task_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_task_lease_options_t"][::std::mem::size_of::<zp_task_lease_options_t>() - 8usize];
    ["Alignment of zp_task_lease_options_t"]
        [::std::mem::align_of::<zp_task_lease_options_t>() - 8usize];
    ["Offset of field: zp_task_lease_options_t::task_attributes"]
        [::std::mem::offset_of!(zp_task_lease_options_t, task_attributes) - 0usize];
};
#[doc = " Represents the configuration used to configure a read operation started via :c:func:`zp_read`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_read_options_t {
    pub single_read: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_read_options_t"][::std::mem::size_of::<zp_read_options_t>() - 1usize];
    ["Alignment of zp_read_options_t"][::std::mem::align_of::<zp_read_options_t>() - 1usize];
    ["Offset of field: zp_read_options_t::single_read"]
        [::std::mem::offset_of!(zp_read_options_t, single_read) - 0usize];
};
#[doc = " Represents the configuration used to configure a send keep alive operation started via :c:func:`zp_send_keep_alive`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_send_keep_alive_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_send_keep_alive_options_t"]
        [::std::mem::size_of::<zp_send_keep_alive_options_t>() - 1usize];
    ["Alignment of zp_send_keep_alive_options_t"]
        [::std::mem::align_of::<zp_send_keep_alive_options_t>() - 1usize];
    ["Offset of field: zp_send_keep_alive_options_t::__dummy"]
        [::std::mem::offset_of!(zp_send_keep_alive_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a send join operation started via :c:func:`zp_send_join`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_send_join_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_send_join_options_t"][::std::mem::size_of::<zp_send_join_options_t>() - 1usize];
    ["Alignment of zp_send_join_options_t"]
        [::std::mem::align_of::<zp_send_join_options_t>() - 1usize];
    ["Offset of field: zp_send_join_options_t::__dummy"]
        [::std::mem::offset_of!(zp_send_join_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a publisher upon declaration with :c:func:`z_declare_publisher`.\n\n Members:\n   uint64_t timeout_ms: The maximum duration in ms the scouting can take.\n   z_what_t what: Type of entities to scout for."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_scout_options_t {
    pub timeout_ms: u32,
    pub what: z_what_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_scout_options_t"][::std::mem::size_of::<z_scout_options_t>() - 8usize];
    ["Alignment of z_scout_options_t"][::std::mem::align_of::<z_scout_options_t>() - 4usize];
    ["Offset of field: z_scout_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_scout_options_t, timeout_ms) - 0usize];
    ["Offset of field: z_scout_options_t::what"]
        [::std::mem::offset_of!(z_scout_options_t, what) - 4usize];
};
#[doc = " Represents missed samples.\n\n Members:\n   source: The source of missed samples.\n   nb: The number of missed samples.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_miss_t {
    pub source: z_entity_global_id_t,
    pub nb: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_miss_t"][::std::mem::size_of::<ze_miss_t>() - 24usize];
    ["Alignment of ze_miss_t"][::std::mem::align_of::<ze_miss_t>() - 4usize];
    ["Offset of field: ze_miss_t::source"][::std::mem::offset_of!(ze_miss_t, source) - 0usize];
    ["Offset of field: ze_miss_t::nb"][::std::mem::offset_of!(ze_miss_t, nb) - 20usize];
};
#[doc = " Represents a data sample."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_sample_t {
    #[doc = " Represents a data sample."]
    pub _val: _z_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_sample_t"][::std::mem::size_of::<z_owned_sample_t>() - 224usize];
    ["Alignment of z_owned_sample_t"][::std::mem::align_of::<z_owned_sample_t>() - 8usize];
    ["Offset of field: z_owned_sample_t::_val"]
        [::std::mem::offset_of!(z_owned_sample_t, _val) - 0usize];
};
#[doc = " Represents a data sample."]
pub type z_loaned_sample_t = _z_sample_t;
#[doc = " Represents a data sample."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_sample_t {
    pub _this: z_owned_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_sample_t"][::std::mem::size_of::<z_moved_sample_t>() - 224usize];
    ["Alignment of z_moved_sample_t"][::std::mem::align_of::<z_moved_sample_t>() - 8usize];
    ["Offset of field: z_moved_sample_t::_this"]
        [::std::mem::offset_of!(z_moved_sample_t, _this) - 0usize];
};
#[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_hello_t {
    #[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
    pub _val: _z_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_hello_t"][::std::mem::size_of::<z_owned_hello_t>() - 56usize];
    ["Alignment of z_owned_hello_t"][::std::mem::align_of::<z_owned_hello_t>() - 8usize];
    ["Offset of field: z_owned_hello_t::_val"]
        [::std::mem::offset_of!(z_owned_hello_t, _val) - 0usize];
};
#[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
pub type z_loaned_hello_t = _z_hello_t;
#[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_hello_t {
    pub _this: z_owned_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_hello_t"][::std::mem::size_of::<z_moved_hello_t>() - 56usize];
    ["Alignment of z_moved_hello_t"][::std::mem::align_of::<z_moved_hello_t>() - 8usize];
    ["Offset of field: z_moved_hello_t::_this"]
        [::std::mem::offset_of!(z_moved_hello_t, _this) - 0usize];
};
#[doc = " Represents the reply to a query."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_owned_reply_t {
    #[doc = " Represents the reply to a query."]
    pub _val: _z_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_reply_t"][::std::mem::size_of::<z_owned_reply_t>() - 248usize];
    ["Alignment of z_owned_reply_t"][::std::mem::align_of::<z_owned_reply_t>() - 8usize];
    ["Offset of field: z_owned_reply_t::_val"]
        [::std::mem::offset_of!(z_owned_reply_t, _val) - 0usize];
};
#[doc = " Represents the reply to a query."]
pub type z_loaned_reply_t = _z_reply_t;
#[doc = " Represents the reply to a query."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_moved_reply_t {
    pub _this: z_owned_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_reply_t"][::std::mem::size_of::<z_moved_reply_t>() - 248usize];
    ["Alignment of z_moved_reply_t"][::std::mem::align_of::<z_moved_reply_t>() - 8usize];
    ["Offset of field: z_moved_reply_t::_this"]
        [::std::mem::offset_of!(z_moved_reply_t, _this) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_string_array_t {
    #[doc = " Represents an array of non null-terminated string."]
    pub _val: _z_string_svec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_string_array_t"][::std::mem::size_of::<z_owned_string_array_t>() - 32usize];
    ["Alignment of z_owned_string_array_t"]
        [::std::mem::align_of::<z_owned_string_array_t>() - 8usize];
    ["Offset of field: z_owned_string_array_t::_val"]
        [::std::mem::offset_of!(z_owned_string_array_t, _val) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
pub type z_loaned_string_array_t = _z_string_svec_t;
#[doc = " Represents an array of non null-terminated string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_string_array_t {
    pub _this: z_owned_string_array_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_string_array_t"][::std::mem::size_of::<z_moved_string_array_t>() - 32usize];
    ["Alignment of z_moved_string_array_t"]
        [::std::mem::align_of::<z_moved_string_array_t>() - 8usize];
    ["Offset of field: z_moved_string_array_t::_this"]
        [::std::mem::offset_of!(z_moved_string_array_t, _this) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
pub type z_closure_drop_callback_t = _z_drop_handler_t;
pub type z_closure_sample_callback_t = _z_closure_sample_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_sample_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_sample_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_sample_t"][::std::mem::size_of::<_z_closure_sample_t>() - 24usize];
    ["Alignment of _z_closure_sample_t"][::std::mem::align_of::<_z_closure_sample_t>() - 8usize];
    ["Offset of field: _z_closure_sample_t::context"]
        [::std::mem::offset_of!(_z_closure_sample_t, context) - 0usize];
    ["Offset of field: _z_closure_sample_t::call"]
        [::std::mem::offset_of!(_z_closure_sample_t, call) - 8usize];
    ["Offset of field: _z_closure_sample_t::drop"]
        [::std::mem::offset_of!(_z_closure_sample_t, drop) - 16usize];
};
#[doc = " Represents the sample closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_sample_t {
    #[doc = " Represents the sample closure."]
    pub _val: _z_closure_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_sample_t"]
        [::std::mem::size_of::<z_owned_closure_sample_t>() - 24usize];
    ["Alignment of z_owned_closure_sample_t"]
        [::std::mem::align_of::<z_owned_closure_sample_t>() - 8usize];
    ["Offset of field: z_owned_closure_sample_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_sample_t, _val) - 0usize];
};
#[doc = " Represents the sample closure."]
pub type z_loaned_closure_sample_t = _z_closure_sample_t;
#[doc = " Represents the sample closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_sample_t {
    pub _this: z_owned_closure_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_sample_t"]
        [::std::mem::size_of::<z_moved_closure_sample_t>() - 24usize];
    ["Alignment of z_moved_closure_sample_t"]
        [::std::mem::align_of::<z_moved_closure_sample_t>() - 8usize];
    ["Offset of field: z_moved_closure_sample_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_sample_t, _this) - 0usize];
};
#[doc = " Represents the sample closure."]
pub type z_closure_query_callback_t = _z_closure_query_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_query_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_query_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_query_t"][::std::mem::size_of::<_z_closure_query_t>() - 24usize];
    ["Alignment of _z_closure_query_t"][::std::mem::align_of::<_z_closure_query_t>() - 8usize];
    ["Offset of field: _z_closure_query_t::context"]
        [::std::mem::offset_of!(_z_closure_query_t, context) - 0usize];
    ["Offset of field: _z_closure_query_t::call"]
        [::std::mem::offset_of!(_z_closure_query_t, call) - 8usize];
    ["Offset of field: _z_closure_query_t::drop"]
        [::std::mem::offset_of!(_z_closure_query_t, drop) - 16usize];
};
#[doc = " Represents the query callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_query_t {
    #[doc = " Represents the query callback closure."]
    pub _val: _z_closure_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_query_t"][::std::mem::size_of::<z_owned_closure_query_t>() - 24usize];
    ["Alignment of z_owned_closure_query_t"]
        [::std::mem::align_of::<z_owned_closure_query_t>() - 8usize];
    ["Offset of field: z_owned_closure_query_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_query_t, _val) - 0usize];
};
#[doc = " Represents the query callback closure."]
pub type z_loaned_closure_query_t = _z_closure_query_t;
#[doc = " Represents the query callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_query_t {
    pub _this: z_owned_closure_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_query_t"][::std::mem::size_of::<z_moved_closure_query_t>() - 24usize];
    ["Alignment of z_moved_closure_query_t"]
        [::std::mem::align_of::<z_moved_closure_query_t>() - 8usize];
    ["Offset of field: z_moved_closure_query_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_query_t, _this) - 0usize];
};
#[doc = " Represents the query callback closure."]
pub type z_closure_reply_callback_t = _z_closure_reply_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_reply_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_reply_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_reply_t"][::std::mem::size_of::<_z_closure_reply_t>() - 24usize];
    ["Alignment of _z_closure_reply_t"][::std::mem::align_of::<_z_closure_reply_t>() - 8usize];
    ["Offset of field: _z_closure_reply_t::context"]
        [::std::mem::offset_of!(_z_closure_reply_t, context) - 0usize];
    ["Offset of field: _z_closure_reply_t::call"]
        [::std::mem::offset_of!(_z_closure_reply_t, call) - 8usize];
    ["Offset of field: _z_closure_reply_t::drop"]
        [::std::mem::offset_of!(_z_closure_reply_t, drop) - 16usize];
};
#[doc = " Represents the query reply callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_reply_t {
    #[doc = " Represents the query reply callback closure."]
    pub _val: _z_closure_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_reply_t"][::std::mem::size_of::<z_owned_closure_reply_t>() - 24usize];
    ["Alignment of z_owned_closure_reply_t"]
        [::std::mem::align_of::<z_owned_closure_reply_t>() - 8usize];
    ["Offset of field: z_owned_closure_reply_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_reply_t, _val) - 0usize];
};
#[doc = " Represents the query reply callback closure."]
pub type z_loaned_closure_reply_t = _z_closure_reply_t;
#[doc = " Represents the query reply callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_reply_t {
    pub _this: z_owned_closure_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_reply_t"][::std::mem::size_of::<z_moved_closure_reply_t>() - 24usize];
    ["Alignment of z_moved_closure_reply_t"]
        [::std::mem::align_of::<z_moved_closure_reply_t>() - 8usize];
    ["Offset of field: z_moved_closure_reply_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_reply_t, _this) - 0usize];
};
#[doc = " Represents the query reply callback closure."]
pub type z_closure_hello_callback_t = ::std::option::Option<
    unsafe extern "C" fn(hello: *mut z_loaned_hello_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_hello_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_hello_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_hello_t"][::std::mem::size_of::<_z_closure_hello_t>() - 24usize];
    ["Alignment of _z_closure_hello_t"][::std::mem::align_of::<_z_closure_hello_t>() - 8usize];
    ["Offset of field: _z_closure_hello_t::context"]
        [::std::mem::offset_of!(_z_closure_hello_t, context) - 0usize];
    ["Offset of field: _z_closure_hello_t::call"]
        [::std::mem::offset_of!(_z_closure_hello_t, call) - 8usize];
    ["Offset of field: _z_closure_hello_t::drop"]
        [::std::mem::offset_of!(_z_closure_hello_t, drop) - 16usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_hello_t {
    #[doc = " Represents the Zenoh ID callback closure."]
    pub _val: _z_closure_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_hello_t"][::std::mem::size_of::<z_owned_closure_hello_t>() - 24usize];
    ["Alignment of z_owned_closure_hello_t"]
        [::std::mem::align_of::<z_owned_closure_hello_t>() - 8usize];
    ["Offset of field: z_owned_closure_hello_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_hello_t, _val) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_loaned_closure_hello_t = _z_closure_hello_t;
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_hello_t {
    pub _this: z_owned_closure_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_hello_t"][::std::mem::size_of::<z_moved_closure_hello_t>() - 24usize];
    ["Alignment of z_moved_closure_hello_t"]
        [::std::mem::align_of::<z_moved_closure_hello_t>() - 8usize];
    ["Offset of field: z_moved_closure_hello_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_hello_t, _this) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_closure_zid_callback_t = ::std::option::Option<
    unsafe extern "C" fn(id: *const z_id_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_zid_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_zid_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_zid_t"][::std::mem::size_of::<_z_closure_zid_t>() - 24usize];
    ["Alignment of _z_closure_zid_t"][::std::mem::align_of::<_z_closure_zid_t>() - 8usize];
    ["Offset of field: _z_closure_zid_t::context"]
        [::std::mem::offset_of!(_z_closure_zid_t, context) - 0usize];
    ["Offset of field: _z_closure_zid_t::call"]
        [::std::mem::offset_of!(_z_closure_zid_t, call) - 8usize];
    ["Offset of field: _z_closure_zid_t::drop"]
        [::std::mem::offset_of!(_z_closure_zid_t, drop) - 16usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_zid_t {
    #[doc = " Represents the Zenoh ID callback closure."]
    pub _val: _z_closure_zid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_zid_t"][::std::mem::size_of::<z_owned_closure_zid_t>() - 24usize];
    ["Alignment of z_owned_closure_zid_t"]
        [::std::mem::align_of::<z_owned_closure_zid_t>() - 8usize];
    ["Offset of field: z_owned_closure_zid_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_zid_t, _val) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_loaned_closure_zid_t = _z_closure_zid_t;
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_zid_t {
    pub _this: z_owned_closure_zid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_zid_t"][::std::mem::size_of::<z_moved_closure_zid_t>() - 24usize];
    ["Alignment of z_moved_closure_zid_t"]
        [::std::mem::align_of::<z_moved_closure_zid_t>() - 8usize];
    ["Offset of field: z_moved_closure_zid_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_zid_t, _this) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_closure_matching_status_callback_t = _z_closure_matching_status_callback_t;
pub type z_closure_matching_status_t = _z_closure_matching_status_t;
#[doc = " Represents the matching status callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_matching_status_t {
    #[doc = " Represents the matching status callback closure."]
    pub _val: _z_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_matching_status_t"]
        [::std::mem::size_of::<z_owned_closure_matching_status_t>() - 24usize];
    ["Alignment of z_owned_closure_matching_status_t"]
        [::std::mem::align_of::<z_owned_closure_matching_status_t>() - 8usize];
    ["Offset of field: z_owned_closure_matching_status_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_matching_status_t, _val) - 0usize];
};
#[doc = " Represents the matching status callback closure."]
pub type z_loaned_closure_matching_status_t = _z_closure_matching_status_t;
#[doc = " Represents the matching status callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_matching_status_t {
    pub _this: z_owned_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_matching_status_t"]
        [::std::mem::size_of::<z_moved_closure_matching_status_t>() - 24usize];
    ["Alignment of z_moved_closure_matching_status_t"]
        [::std::mem::align_of::<z_moved_closure_matching_status_t>() - 8usize];
    ["Offset of field: z_moved_closure_matching_status_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_matching_status_t, _this) - 0usize];
};
#[doc = " Represents the matching status callback closure."]
pub type ze_closure_miss_callback_t = ::std::option::Option<
    unsafe extern "C" fn(miss: *const ze_miss_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_closure_miss_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: ze_closure_miss_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_closure_miss_t"][::std::mem::size_of::<_ze_closure_miss_t>() - 24usize];
    ["Alignment of _ze_closure_miss_t"][::std::mem::align_of::<_ze_closure_miss_t>() - 8usize];
    ["Offset of field: _ze_closure_miss_t::context"]
        [::std::mem::offset_of!(_ze_closure_miss_t, context) - 0usize];
    ["Offset of field: _ze_closure_miss_t::call"]
        [::std::mem::offset_of!(_ze_closure_miss_t, call) - 8usize];
    ["Offset of field: _ze_closure_miss_t::drop"]
        [::std::mem::offset_of!(_ze_closure_miss_t, drop) - 16usize];
};
#[doc = " Represents the sample miss callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_closure_miss_t {
    #[doc = " Represents the sample miss callback closure."]
    pub _val: _ze_closure_miss_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_closure_miss_t"][::std::mem::size_of::<ze_owned_closure_miss_t>() - 24usize];
    ["Alignment of ze_owned_closure_miss_t"]
        [::std::mem::align_of::<ze_owned_closure_miss_t>() - 8usize];
    ["Offset of field: ze_owned_closure_miss_t::_val"]
        [::std::mem::offset_of!(ze_owned_closure_miss_t, _val) - 0usize];
};
#[doc = " Represents the sample miss callback closure."]
pub type ze_loaned_closure_miss_t = _ze_closure_miss_t;
#[doc = " Represents the sample miss callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_closure_miss_t {
    pub _this: ze_owned_closure_miss_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_closure_miss_t"][::std::mem::size_of::<ze_moved_closure_miss_t>() - 24usize];
    ["Alignment of ze_moved_closure_miss_t"]
        [::std::mem::align_of::<ze_moved_closure_miss_t>() - 8usize];
    ["Offset of field: ze_moved_closure_miss_t::_this"]
        [::std::mem::offset_of!(ze_moved_closure_miss_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_liveliness_token_t {
    pub _id: u32,
    pub _key: _z_keyexpr_t,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_liveliness_token_t"][::std::mem::size_of::<_z_liveliness_token_t>() - 72usize];
    ["Alignment of _z_liveliness_token_t"]
        [::std::mem::align_of::<_z_liveliness_token_t>() - 8usize];
    ["Offset of field: _z_liveliness_token_t::_id"]
        [::std::mem::offset_of!(_z_liveliness_token_t, _id) - 0usize];
    ["Offset of field: _z_liveliness_token_t::_key"]
        [::std::mem::offset_of!(_z_liveliness_token_t, _key) - 8usize];
    ["Offset of field: _z_liveliness_token_t::_zn"]
        [::std::mem::offset_of!(_z_liveliness_token_t, _zn) - 56usize];
};
unsafe extern "C" {
    pub fn _z_liveliness_token_null() -> _z_liveliness_token_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_liveliness_token_t {
    pub _val: _z_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_liveliness_token_t"]
        [::std::mem::size_of::<z_owned_liveliness_token_t>() - 72usize];
    ["Alignment of z_owned_liveliness_token_t"]
        [::std::mem::align_of::<z_owned_liveliness_token_t>() - 8usize];
    ["Offset of field: z_owned_liveliness_token_t::_val"]
        [::std::mem::offset_of!(z_owned_liveliness_token_t, _val) - 0usize];
};
pub type z_loaned_liveliness_token_t = _z_liveliness_token_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_liveliness_token_t {
    pub _this: z_owned_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_liveliness_token_t"]
        [::std::mem::size_of::<z_moved_liveliness_token_t>() - 72usize];
    ["Alignment of z_moved_liveliness_token_t"]
        [::std::mem::align_of::<z_moved_liveliness_token_t>() - 8usize];
    ["Offset of field: z_moved_liveliness_token_t::_this"]
        [::std::mem::offset_of!(z_moved_liveliness_token_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_liveliness_token_null(obj: *mut z_owned_liveliness_token_t);
}
unsafe extern "C" {
    pub fn z_internal_liveliness_token_check(obj: *const z_owned_liveliness_token_t) -> bool;
}
unsafe extern "C" {
    pub fn z_liveliness_token_loan(
        obj: *const z_owned_liveliness_token_t,
    ) -> *const z_loaned_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_loan_mut(
        obj: *mut z_owned_liveliness_token_t,
    ) -> *mut z_loaned_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_move(
        obj: *mut z_owned_liveliness_token_t,
    ) -> *mut z_moved_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_take(
        obj: *mut z_owned_liveliness_token_t,
        src: *mut z_moved_liveliness_token_t,
    );
}
unsafe extern "C" {
    pub fn z_liveliness_token_drop(obj: *mut z_moved_liveliness_token_t);
}
unsafe extern "C" {
    pub fn z_liveliness_token_take_from_loaned(
        dst: *mut z_owned_liveliness_token_t,
        src: *mut z_loaned_liveliness_token_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_clone(
        obj: *mut z_owned_liveliness_token_t,
        src: *const z_loaned_liveliness_token_t,
    ) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_declare_token()`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_token_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_token_options_t"]
        [::std::mem::size_of::<z_liveliness_token_options_t>() - 1usize];
    ["Alignment of z_liveliness_token_options_t"]
        [::std::mem::align_of::<z_liveliness_token_options_t>() - 1usize];
    ["Offset of field: z_liveliness_token_options_t::__dummy"]
        [::std::mem::offset_of!(z_liveliness_token_options_t, __dummy) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs default value for :c:type:`z_liveliness_token_options_t`."]
    pub fn z_liveliness_token_options_default(
        options: *mut z_liveliness_token_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs and declares a liveliness token on the network.\n\n Liveliness token subscribers on an intersecting key expression will receive a PUT sample when connectivity\n is achieved, and a DELETE sample if it's lost.\n\n Parameters:\n   zs: A Zenos session to declare the liveliness token.\n   token: An uninitialized memory location where liveliness token will be constructed.\n   keyexpr: A keyexpr to declare a liveliess token for.\n   options: Liveliness token declaration options.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_token(
        zs: *const z_loaned_session_t,
        token: *mut z_owned_liveliness_token_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_liveliness_token_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclare a liveliness token, notifying subscribers of its destruction.\n\n Parameters:\n   token: Moved :c:type:`z_owned_liveliness_token_t` to undeclare.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_undeclare_token(token: *mut z_moved_liveliness_token_t) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_declare_subscriber()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_subscriber_options_t {
    pub history: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_subscriber_options_t"]
        [::std::mem::size_of::<z_liveliness_subscriber_options_t>() - 1usize];
    ["Alignment of z_liveliness_subscriber_options_t"]
        [::std::mem::align_of::<z_liveliness_subscriber_options_t>() - 1usize];
    ["Offset of field: z_liveliness_subscriber_options_t::history"]
        [::std::mem::offset_of!(z_liveliness_subscriber_options_t, history) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constucts default value for :c:type:`z_liveliness_subscriber_options_t`."]
    pub fn z_liveliness_subscriber_options_default(
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a subscriber on liveliness tokens that intersect `keyexpr`.\n\n Parameters:\n   zs: The Zenoh session.\n   sub: An uninitialized memory location where subscriber will be constructed.\n   keyexpr: The key expression to subscribe to.\n   callback: The callback function that will be called each time a liveliness token status is changed.\n   options: The options to be passed to the liveliness subscriber declaration.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_subscriber(
        zs: *const z_loaned_session_t,
        sub: *mut z_owned_subscriber_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background subscriber on liveliness tokens that intersect `keyexpr`.\n Subscriber callback will be called to process the messages, until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: The Zenoh session.\n   keyexpr: The key expression to subscribe to.\n   callback: The callback function that will be called each time a liveliness token status is changed.\n   options: The options to be passed to the liveliness subscriber declaration.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_background_subscriber(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_get()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_get_options_t {
    pub timeout_ms: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_get_options_t"]
        [::std::mem::size_of::<z_liveliness_get_options_t>() - 8usize];
    ["Alignment of z_liveliness_get_options_t"]
        [::std::mem::align_of::<z_liveliness_get_options_t>() - 8usize];
    ["Offset of field: z_liveliness_get_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_liveliness_get_options_t, timeout_ms) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs default value :c:type:`z_liveliness_get_options_t`."]
    pub fn z_liveliness_get_options_default(options: *mut z_liveliness_get_options_t)
        -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Queries liveliness tokens currently on the network with a key expression intersecting with `keyexpr`.\n\n Parameters:\n   zs: The Zenoh session.\n   keyexpr: The key expression to query liveliness tokens for.\n   callback: The callback function that will be called for each received reply.\n   options: Additional options for the liveliness get operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_get(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_liveliness_get_options_t,
    ) -> z_result_t;
}
#[doc = " Represents the set of options that can be applied to an advaned publishers cache.\n The cache allows advanced subscribers to recover history and/or lost samples.\n\n Members:\n   bool is_enabled: Must be set to ``true``, to enable the cache.\n   size_t max_samples: Number of samples to keep for each resource.\n   z_congestion_control_t congestion_control: The congestion control to apply to replies.\n   z_priority_t priority: The priority of replies.\n   bool is_express: If set to ``true``, this cache replies will not be batched. This usually\n     has a positive impact on latency but negative impact on throughput."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_advanced_publisher_cache_options_t {
    pub is_enabled: bool,
    pub max_samples: usize,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub _liveliness: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_advanced_publisher_cache_options_t"]
        [::std::mem::size_of::<ze_advanced_publisher_cache_options_t>() - 32usize];
    ["Alignment of ze_advanced_publisher_cache_options_t"]
        [::std::mem::align_of::<ze_advanced_publisher_cache_options_t>() - 8usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::is_enabled"]
        [::std::mem::offset_of!(ze_advanced_publisher_cache_options_t, is_enabled) - 0usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::max_samples"]
        [::std::mem::offset_of!(ze_advanced_publisher_cache_options_t, max_samples) - 8usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::congestion_control"][::std::mem::offset_of!(
        ze_advanced_publisher_cache_options_t,
        congestion_control
    ) - 16usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::priority"]
        [::std::mem::offset_of!(ze_advanced_publisher_cache_options_t, priority) - 20usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::is_express"]
        [::std::mem::offset_of!(ze_advanced_publisher_cache_options_t, is_express) - 24usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::_liveliness"]
        [::std::mem::offset_of!(ze_advanced_publisher_cache_options_t, _liveliness) - 25usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_cache_t {
    pub _cache: _z_sample_ring_t,
    pub _outbox: *mut _z_sample_t,
    pub _outbox_cap: usize,
    pub _mutex: _z_mutex_t,
    pub _outbox_mutex: _z_mutex_t,
    pub _queryable: z_owned_queryable_t,
    pub _liveliness: z_owned_liveliness_token_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub _is_express: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_cache_t"][::std::mem::size_of::<_ze_advanced_cache_t>() - 176usize];
    ["Alignment of _ze_advanced_cache_t"][::std::mem::align_of::<_ze_advanced_cache_t>() - 8usize];
    ["Offset of field: _ze_advanced_cache_t::_cache"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _cache) - 0usize];
    ["Offset of field: _ze_advanced_cache_t::_outbox"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _outbox) - 40usize];
    ["Offset of field: _ze_advanced_cache_t::_outbox_cap"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _outbox_cap) - 48usize];
    ["Offset of field: _ze_advanced_cache_t::_mutex"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _mutex) - 56usize];
    ["Offset of field: _ze_advanced_cache_t::_outbox_mutex"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _outbox_mutex) - 60usize];
    ["Offset of field: _ze_advanced_cache_t::_queryable"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _queryable) - 64usize];
    ["Offset of field: _ze_advanced_cache_t::_liveliness"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _liveliness) - 88usize];
    ["Offset of field: _ze_advanced_cache_t::_congestion_control"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _congestion_control) - 160usize];
    ["Offset of field: _ze_advanced_cache_t::_priority"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _priority) - 164usize];
    ["Offset of field: _ze_advanced_cache_t::_is_express"]
        [::std::mem::offset_of!(_ze_advanced_cache_t, _is_express) - 168usize];
};
pub const memory_order_memory_order_relaxed: memory_order = 0;
pub const memory_order_memory_order_consume: memory_order = 1;
pub const memory_order_memory_order_acquire: memory_order = 2;
pub const memory_order_memory_order_release: memory_order = 3;
pub const memory_order_memory_order_acq_rel: memory_order = 4;
pub const memory_order_memory_order_seq_cst: memory_order = 5;
pub type memory_order = ::std::os::raw::c_uint;
pub type atomic_bool = bool;
pub type atomic_char = ::std::os::raw::c_char;
pub type atomic_schar = ::std::os::raw::c_schar;
pub type atomic_uchar = ::std::os::raw::c_uchar;
pub type atomic_short = ::std::os::raw::c_short;
pub type atomic_ushort = ::std::os::raw::c_ushort;
pub type atomic_int = ::std::os::raw::c_int;
pub type atomic_uint = ::std::os::raw::c_uint;
pub type atomic_long = ::std::os::raw::c_long;
pub type atomic_ulong = ::std::os::raw::c_ulong;
pub type atomic_llong = ::std::os::raw::c_longlong;
pub type atomic_ullong = ::std::os::raw::c_ulonglong;
pub type atomic_char16_t = ::std::os::raw::c_ushort;
pub type atomic_char32_t = ::std::os::raw::c_uint;
pub type atomic_wchar_t = ::std::os::raw::c_int;
pub type atomic_int_least8_t = ::std::os::raw::c_schar;
pub type atomic_uint_least8_t = ::std::os::raw::c_uchar;
pub type atomic_int_least16_t = ::std::os::raw::c_short;
pub type atomic_uint_least16_t = ::std::os::raw::c_ushort;
pub type atomic_int_least32_t = ::std::os::raw::c_int;
pub type atomic_uint_least32_t = ::std::os::raw::c_uint;
pub type atomic_int_least64_t = ::std::os::raw::c_long;
pub type atomic_uint_least64_t = ::std::os::raw::c_ulong;
pub type atomic_int_fast8_t = ::std::os::raw::c_schar;
pub type atomic_uint_fast8_t = ::std::os::raw::c_uchar;
pub type atomic_int_fast16_t = ::std::os::raw::c_short;
pub type atomic_uint_fast16_t = ::std::os::raw::c_ushort;
pub type atomic_int_fast32_t = ::std::os::raw::c_int;
pub type atomic_uint_fast32_t = ::std::os::raw::c_uint;
pub type atomic_int_fast64_t = ::std::os::raw::c_long;
pub type atomic_uint_fast64_t = ::std::os::raw::c_ulong;
pub type atomic_intptr_t = ::std::os::raw::c_long;
pub type atomic_uintptr_t = ::std::os::raw::c_ulong;
pub type atomic_size_t = ::std::os::raw::c_ulong;
pub type atomic_ptrdiff_t = ::std::os::raw::c_long;
pub type atomic_intmax_t = ::std::os::raw::c_long;
pub type atomic_uintmax_t = ::std::os::raw::c_ulong;
unsafe extern "C" {
    pub fn atomic_thread_fence(arg1: memory_order);
}
unsafe extern "C" {
    pub fn atomic_signal_fence(arg1: memory_order);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub __val: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _bindgen_ty_1"][::std::mem::size_of::<_bindgen_ty_1>() - 1usize];
    ["Alignment of _bindgen_ty_1"][::std::mem::align_of::<_bindgen_ty_1>() - 1usize];
    ["Offset of field: _bindgen_ty_1::__val"]
        [::std::mem::offset_of!(_bindgen_ty_1, __val) - 0usize];
};
pub type atomic_flag = _bindgen_ty_1;
unsafe extern "C" {
    pub fn atomic_flag_test_and_set(arg1: *mut atomic_flag) -> bool;
}
unsafe extern "C" {
    pub fn atomic_flag_test_and_set_explicit(arg1: *mut atomic_flag, arg2: memory_order) -> bool;
}
unsafe extern "C" {
    pub fn atomic_flag_clear(arg1: *mut atomic_flag);
}
unsafe extern "C" {
    pub fn atomic_flag_clear_explicit(arg1: *mut atomic_flag, arg2: memory_order);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_seqnumber_t {
    pub _seq: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_seqnumber_t"][::std::mem::size_of::<_z_seqnumber_t>() - 4usize];
    ["Alignment of _z_seqnumber_t"][::std::mem::align_of::<_z_seqnumber_t>() - 4usize];
    ["Offset of field: _z_seqnumber_t::_seq"]
        [::std::mem::offset_of!(_z_seqnumber_t, _seq) - 0usize];
};
unsafe extern "C" {
    pub fn _z_seqnumber_init(seq: *mut _z_seqnumber_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_seqnumber_fetch(seq: *mut _z_seqnumber_t, value: *mut u32) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_seqnumber_fetch_and_increment(
        seq: *mut _z_seqnumber_t,
        value: *mut u32,
    ) -> z_result_t;
}
pub const _ze_advanced_publisher_sequencing_t__ZE_ADVANCED_PUBLISHER_SEQUENCING_NONE:
    _ze_advanced_publisher_sequencing_t = 0;
pub const _ze_advanced_publisher_sequencing_t__ZE_ADVANCED_PUBLISHER_SEQUENCING_TIMESTAMP:
    _ze_advanced_publisher_sequencing_t = 1;
pub const _ze_advanced_publisher_sequencing_t__ZE_ADVANCED_PUBLISHER_SEQUENCING_SEQUENCE_NUMBER:
    _ze_advanced_publisher_sequencing_t = 2;
pub type _ze_advanced_publisher_sequencing_t = ::std::os::raw::c_uint;
pub const ze_advanced_publisher_heartbeat_mode_t_ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_NONE:
    ze_advanced_publisher_heartbeat_mode_t = 0;
pub const ze_advanced_publisher_heartbeat_mode_t_ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_PERIODIC:
    ze_advanced_publisher_heartbeat_mode_t = 1;
pub const ze_advanced_publisher_heartbeat_mode_t_ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_SPORADIC:
    ze_advanced_publisher_heartbeat_mode_t = 2;
#[doc = " Whatami values, defined as a bitmask.\n\n Enumerators:\n   ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_NONE: Disable heartbeat-based last sample miss detection.\n   ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_PERIODIC: Allow last sample miss detection through periodic\n     heartbeat. Periodically send the last published Sample's sequence number to allow last sample recovery.\n   ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_SPORADIC: Allow last sample miss detection through sporadic\n     heartbeat. Each period, the last published Sample's sequence number is sent with\n     `Z_CONGESTION_CONTROL_DROP` but only if it changed since last period.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
pub type ze_advanced_publisher_heartbeat_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_state_t {
    pub _seqnumber: _z_seqnumber_t,
    pub _heartbeat_mode: ze_advanced_publisher_heartbeat_mode_t,
    pub _zn: _z_session_weak_t,
    pub _publisher: z_owned_publisher_t,
    pub _state_publisher_task_id: u32,
    pub _last_published_sn: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_state_t"]
        [::std::mem::size_of::<_ze_advanced_publisher_state_t>() - 176usize];
    ["Alignment of _ze_advanced_publisher_state_t"]
        [::std::mem::align_of::<_ze_advanced_publisher_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_seqnumber"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_t, _seqnumber) - 0usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_heartbeat_mode"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_t, _heartbeat_mode) - 4usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_zn"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_t, _zn) - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_publisher"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_t, _publisher) - 24usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_state_publisher_task_id"][::std::mem::offset_of!(
        _ze_advanced_publisher_state_t,
        _state_publisher_task_id
    ) - 168usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_last_published_sn"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_t, _last_published_sn) - 172usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_publisher_state_clear(state: *mut _ze_advanced_publisher_state_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_state_rc_t {
    pub _val: *mut _ze_advanced_publisher_state_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_state_rc_t"]
        [::std::mem::size_of::<_ze_advanced_publisher_state_rc_t>() - 16usize];
    ["Alignment of _ze_advanced_publisher_state_rc_t"]
        [::std::mem::align_of::<_ze_advanced_publisher_state_rc_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_rc_t::_val"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_rc_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_publisher_state_rc_t::_cnt"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_state_weak_t {
    pub _val: *mut _ze_advanced_publisher_state_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_state_weak_t"]
        [::std::mem::size_of::<_ze_advanced_publisher_state_weak_t>() - 16usize];
    ["Alignment of _ze_advanced_publisher_state_weak_t"]
        [::std::mem::align_of::<_ze_advanced_publisher_state_weak_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_weak_t::_val"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_weak_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_publisher_state_weak_t::_cnt"]
        [::std::mem::offset_of!(_ze_advanced_publisher_state_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_t {
    pub _publisher: z_owned_publisher_t,
    pub _cache: *mut _ze_advanced_cache_t,
    pub _has_liveliness: bool,
    pub _liveliness: z_owned_liveliness_token_t,
    pub _sequencing: _ze_advanced_publisher_sequencing_t,
    pub _state: _ze_advanced_publisher_state_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_t"]
        [::std::mem::size_of::<_ze_advanced_publisher_t>() - 256usize];
    ["Alignment of _ze_advanced_publisher_t"]
        [::std::mem::align_of::<_ze_advanced_publisher_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_t::_publisher"]
        [::std::mem::offset_of!(_ze_advanced_publisher_t, _publisher) - 0usize];
    ["Offset of field: _ze_advanced_publisher_t::_cache"]
        [::std::mem::offset_of!(_ze_advanced_publisher_t, _cache) - 144usize];
    ["Offset of field: _ze_advanced_publisher_t::_has_liveliness"]
        [::std::mem::offset_of!(_ze_advanced_publisher_t, _has_liveliness) - 152usize];
    ["Offset of field: _ze_advanced_publisher_t::_liveliness"]
        [::std::mem::offset_of!(_ze_advanced_publisher_t, _liveliness) - 160usize];
    ["Offset of field: _ze_advanced_publisher_t::_sequencing"]
        [::std::mem::offset_of!(_ze_advanced_publisher_t, _sequencing) - 232usize];
    ["Offset of field: _ze_advanced_publisher_t::_state"]
        [::std::mem::offset_of!(_ze_advanced_publisher_t, _state) - 240usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_advanced_publisher_t {
    pub _val: _ze_advanced_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_advanced_publisher_t"]
        [::std::mem::size_of::<ze_owned_advanced_publisher_t>() - 256usize];
    ["Alignment of ze_owned_advanced_publisher_t"]
        [::std::mem::align_of::<ze_owned_advanced_publisher_t>() - 8usize];
    ["Offset of field: ze_owned_advanced_publisher_t::_val"]
        [::std::mem::offset_of!(ze_owned_advanced_publisher_t, _val) - 0usize];
};
pub type ze_loaned_advanced_publisher_t = _ze_advanced_publisher_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_advanced_publisher_t {
    pub _this: ze_owned_advanced_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_advanced_publisher_t"]
        [::std::mem::size_of::<ze_moved_advanced_publisher_t>() - 256usize];
    ["Alignment of ze_moved_advanced_publisher_t"]
        [::std::mem::align_of::<ze_moved_advanced_publisher_t>() - 8usize];
    ["Offset of field: ze_moved_advanced_publisher_t::_this"]
        [::std::mem::offset_of!(ze_moved_advanced_publisher_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn ze_internal_advanced_publisher_null(obj: *mut ze_owned_advanced_publisher_t);
}
unsafe extern "C" {
    pub fn ze_internal_advanced_publisher_check(obj: *const ze_owned_advanced_publisher_t) -> bool;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_loan(
        obj: *const ze_owned_advanced_publisher_t,
    ) -> *const ze_loaned_advanced_publisher_t;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_loan_mut(
        obj: *mut ze_owned_advanced_publisher_t,
    ) -> *mut ze_loaned_advanced_publisher_t;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_move(
        obj: *mut ze_owned_advanced_publisher_t,
    ) -> *mut ze_moved_advanced_publisher_t;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_take(
        obj: *mut ze_owned_advanced_publisher_t,
        src: *mut ze_moved_advanced_publisher_t,
    );
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_drop(obj: *mut ze_moved_advanced_publisher_t);
}
#[doc = " A map entry.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sortedmap_entry_t {
    pub _key: *mut ::std::os::raw::c_void,
    pub _val: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sortedmap_entry_t"][::std::mem::size_of::<_z_sortedmap_entry_t>() - 16usize];
    ["Alignment of _z_sortedmap_entry_t"][::std::mem::align_of::<_z_sortedmap_entry_t>() - 8usize];
    ["Offset of field: _z_sortedmap_entry_t::_key"]
        [::std::mem::offset_of!(_z_sortedmap_entry_t, _key) - 0usize];
    ["Offset of field: _z_sortedmap_entry_t::_val"]
        [::std::mem::offset_of!(_z_sortedmap_entry_t, _val) - 8usize];
};
#[doc = " A sorted map.\n\n Members:\n   _z_list_t *_vals: a linked list containing the values\n   z_element_cmp_f _f_cmp: the function used to compare keys"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sortedmap_t {
    pub _vals: *mut _z_list_t,
    pub _f_cmp: z_element_cmp_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sortedmap_t"][::std::mem::size_of::<_z_sortedmap_t>() - 16usize];
    ["Alignment of _z_sortedmap_t"][::std::mem::align_of::<_z_sortedmap_t>() - 8usize];
    ["Offset of field: _z_sortedmap_t::_vals"]
        [::std::mem::offset_of!(_z_sortedmap_t, _vals) - 0usize];
    ["Offset of field: _z_sortedmap_t::_f_cmp"]
        [::std::mem::offset_of!(_z_sortedmap_t, _f_cmp) - 8usize];
};
#[doc = " Iterator for a generic key-value hashmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sortedmap_iterator_t {
    pub _entry: *mut _z_sortedmap_entry_t,
    pub _map: *const _z_sortedmap_t,
    pub _list_ptr: *mut _z_list_t,
    pub _initialized: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sortedmap_iterator_t"][::std::mem::size_of::<_z_sortedmap_iterator_t>() - 32usize];
    ["Alignment of _z_sortedmap_iterator_t"]
        [::std::mem::align_of::<_z_sortedmap_iterator_t>() - 8usize];
    ["Offset of field: _z_sortedmap_iterator_t::_entry"]
        [::std::mem::offset_of!(_z_sortedmap_iterator_t, _entry) - 0usize];
    ["Offset of field: _z_sortedmap_iterator_t::_map"]
        [::std::mem::offset_of!(_z_sortedmap_iterator_t, _map) - 8usize];
    ["Offset of field: _z_sortedmap_iterator_t::_list_ptr"]
        [::std::mem::offset_of!(_z_sortedmap_iterator_t, _list_ptr) - 16usize];
    ["Offset of field: _z_sortedmap_iterator_t::_initialized"]
        [::std::mem::offset_of!(_z_sortedmap_iterator_t, _initialized) - 24usize];
};
unsafe extern "C" {
    pub fn _z_sortedmap_init(map: *mut _z_sortedmap_t, f_cmp: z_element_cmp_f);
}
unsafe extern "C" {
    pub fn _z_sortedmap_make(f_cmp: z_element_cmp_f) -> _z_sortedmap_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_insert(
        map: *mut _z_sortedmap_t,
        key: *mut ::std::os::raw::c_void,
        val: *mut ::std::os::raw::c_void,
        f: z_element_free_f,
        replace: bool,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_sortedmap_get(
        map: *const _z_sortedmap_t,
        key: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_sortedmap_pop_first(map: *mut _z_sortedmap_t) -> *mut _z_sortedmap_entry_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_remove(
        map: *mut _z_sortedmap_t,
        key: *const ::std::os::raw::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_sortedmap_len(map: *const _z_sortedmap_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_sortedmap_is_empty(map: *const _z_sortedmap_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_sortedmap_copy(
        dst: *mut _z_sortedmap_t,
        src: *const _z_sortedmap_t,
        f_c: z_element_clone_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_clone(
        src: *const _z_sortedmap_t,
        f_c: z_element_clone_f,
        f_f: z_element_free_f,
    ) -> _z_sortedmap_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_clear(map: *mut _z_sortedmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_sortedmap_free(map: *mut *mut _z_sortedmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_make(map: *const _z_sortedmap_t) -> _z_sortedmap_iterator_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_next(iter: *mut _z_sortedmap_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_key(
        iter: *const _z_sortedmap_iterator_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_value(
        iter: *const _z_sortedmap_iterator_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub type _z_uint32_eq_f =
    ::std::option::Option<unsafe extern "C" fn(left: *const u32, right: *const u32) -> bool>;
pub type _z_uint32_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const u32, right: *const u32) -> ::std::os::raw::c_int,
>;
#[doc = " A map entry.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_uint32__z_sample_sortedmap_entry_t = _z_sortedmap_entry_t;
#[doc = " A sorted map.\n\n Members:\n   _z_list_t *_vals: a linked list containing the values\n   z_element_cmp_f _f_cmp: the function used to compare keys"]
pub type _z_uint32__z_sample_sortedmap_t = _z_sortedmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_uint32__z_sample_sortedmap_iterator_t = _z_sortedmap_iterator_t;
#[doc = " A map entry.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_timestamp__z_sample_sortedmap_entry_t = _z_sortedmap_entry_t;
#[doc = " A sorted map.\n\n Members:\n   _z_list_t *_vals: a linked list containing the values\n   z_element_cmp_f _f_cmp: the function used to compare keys"]
pub type _z_timestamp__z_sample_sortedmap_t = _z_sortedmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_timestamp__z_sample_sortedmap_iterator_t = _z_sortedmap_iterator_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_sequenced_state_t {
    pub _zn: _z_session_weak_t,
    pub _has_last_delivered: bool,
    pub _last_delivered: u32,
    pub _pending_queries: u64,
    pub _pending_samples: _z_uint32__z_sample_sortedmap_t,
    pub _periodic_query_id: u32,
    pub _query_keyexpr: z_owned_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_sequenced_state_t"]
        [::std::mem::size_of::<_ze_advanced_subscriber_sequenced_state_t>() - 104usize];
    ["Alignment of _ze_advanced_subscriber_sequenced_state_t"]
        [::std::mem::align_of::<_ze_advanced_subscriber_sequenced_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_zn"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_sequenced_state_t, _zn) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_has_last_delivered"][::std::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _has_last_delivered
    )
        - 16usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_last_delivered"][::std::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _last_delivered
    ) - 20usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_pending_queries"][::std::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _pending_queries
    ) - 24usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_pending_samples"][::std::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _pending_samples
    ) - 32usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_periodic_query_id"][::std::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _periodic_query_id
    ) - 48usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_query_keyexpr"][::std::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _query_keyexpr
    ) - 56usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_sequenced_state_clear(
        s: *mut _ze_advanced_subscriber_sequenced_state_t,
    );
}
pub type _ze_advanced_subscriber_sequenced_state_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_sequenced_state_t,
        right: *const _ze_advanced_subscriber_sequenced_state_t,
    ) -> bool,
>;
pub type _ze_advanced_subscriber_sequenced_state_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_sequenced_state_t,
        right: *const _ze_advanced_subscriber_sequenced_state_t,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_timestamped_state_t {
    pub _has_last_delivered: bool,
    pub _last_delivered: _z_timestamp_t,
    pub _pending_queries: u64,
    pub _pending_samples: _z_timestamp__z_sample_sortedmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_timestamped_state_t"]
        [::std::mem::size_of::<_ze_advanced_subscriber_timestamped_state_t>() - 64usize];
    ["Alignment of _ze_advanced_subscriber_timestamped_state_t"]
        [::std::mem::align_of::<_ze_advanced_subscriber_timestamped_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_has_last_delivered"][::std::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _has_last_delivered
    )
        - 0usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_last_delivered"][::std::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _last_delivered
    ) - 8usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_pending_queries"][::std::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _pending_queries
    ) - 40usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_pending_samples"][::std::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _pending_samples
    ) - 48usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_timestamped_state_clear(
        s: *mut _ze_advanced_subscriber_timestamped_state_t,
    );
}
pub type _ze_advanced_subscriber_timestamped_state_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_timestamped_state_t,
        right: *const _ze_advanced_subscriber_timestamped_state_t,
    ) -> bool,
>;
pub type _ze_advanced_subscriber_timestamped_state_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_timestamped_state_t,
        right: *const _ze_advanced_subscriber_timestamped_state_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_entry_t =
    _z_hashmap_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_t = _z_hashmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_iterator_t =
    _z_hashmap_iterator_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_id__ze_advanced_subscriber_timestamped_state_hashmap_entry_t = _z_hashmap_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_id__ze_advanced_subscriber_timestamped_state_hashmap_t = _z_hashmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_id__ze_advanced_subscriber_timestamped_state_hashmap_iterator_t = _z_hashmap_iterator_t;
pub type _ze_closure_miss_eq_f = ::std::option::Option<
    unsafe extern "C" fn(left: *const _ze_closure_miss_t, right: *const _ze_closure_miss_t) -> bool,
>;
pub type _ze_closure_miss_cmp_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_closure_miss_t,
        right: *const _ze_closure_miss_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _ze_closure_miss_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _ze_closure_miss_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _ze_closure_miss_intmap_iterator_t = _z_int_void_map_iterator_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_state_t {
    pub _mutex: z_owned_mutex_t,
    pub _next_id: usize,
    pub _global_pending_queries: u64,
    pub _sequenced_states: _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_t,
    pub _timestamped_states: _z_id__ze_advanced_subscriber_timestamped_state_hashmap_t,
    pub _zn: _z_session_weak_t,
    pub _keyexpr: z_owned_keyexpr_t,
    pub _retransmission: bool,
    pub _has_period: bool,
    pub _period_ms: u64,
    pub _history_depth: usize,
    pub _history_age: u64,
    pub _query_target: z_query_target_t,
    pub _query_timeout: u64,
    pub _callback: _z_closure_sample_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _ctx: *mut ::std::os::raw::c_void,
    pub _miss_handlers: _ze_closure_miss_intmap_t,
    pub _has_token: bool,
    pub _token: z_owned_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_state_t"]
        [::std::mem::size_of::<_ze_advanced_subscriber_state_t>() - 336usize];
    ["Alignment of _ze_advanced_subscriber_state_t"]
        [::std::mem::align_of::<_ze_advanced_subscriber_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_mutex"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _mutex) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_next_id"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _next_id) - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_global_pending_queries"][::std::mem::offset_of!(
        _ze_advanced_subscriber_state_t,
        _global_pending_queries
    ) - 16usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_sequenced_states"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _sequenced_states) - 24usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_timestamped_states"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _timestamped_states) - 56usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_zn"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _zn) - 88usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_keyexpr"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _keyexpr) - 104usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_retransmission"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _retransmission) - 152usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_has_period"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _has_period) - 153usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_period_ms"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _period_ms) - 160usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_history_depth"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _history_depth) - 168usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_history_age"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _history_age) - 176usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_query_target"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _query_target) - 184usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_query_timeout"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _query_timeout) - 192usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_callback"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _callback) - 200usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_dropper"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _dropper) - 208usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_ctx"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _ctx) - 216usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_miss_handlers"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _miss_handlers) - 224usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_has_token"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _has_token) - 256usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_token"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_t, _token) - 264usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_state_null() -> _ze_advanced_subscriber_state_t;
}
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_state_clear(state: *mut _ze_advanced_subscriber_state_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_state_rc_t {
    pub _val: *mut _ze_advanced_subscriber_state_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_state_rc_t"]
        [::std::mem::size_of::<_ze_advanced_subscriber_state_rc_t>() - 16usize];
    ["Alignment of _ze_advanced_subscriber_state_rc_t"]
        [::std::mem::align_of::<_ze_advanced_subscriber_state_rc_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_rc_t::_val"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_rc_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_state_rc_t::_cnt"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_state_weak_t {
    pub _val: *mut _ze_advanced_subscriber_state_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_state_weak_t"]
        [::std::mem::size_of::<_ze_advanced_subscriber_state_weak_t>() - 16usize];
    ["Alignment of _ze_advanced_subscriber_state_weak_t"]
        [::std::mem::align_of::<_ze_advanced_subscriber_state_weak_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_weak_t::_val"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_weak_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_state_weak_t::_cnt"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_state_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_t {
    pub _subscriber: z_owned_subscriber_t,
    pub _has_liveliness_subscriber: bool,
    pub _liveliness_subscriber: z_owned_subscriber_t,
    pub _has_heartbeat_subscriber: bool,
    pub _heartbeat_subscriber: z_owned_subscriber_t,
    pub _state: _ze_advanced_subscriber_state_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_t"]
        [::std::mem::size_of::<_ze_advanced_subscriber_t>() - 104usize];
    ["Alignment of _ze_advanced_subscriber_t"]
        [::std::mem::align_of::<_ze_advanced_subscriber_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_t::_subscriber"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_t, _subscriber) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_t::_has_liveliness_subscriber"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_t, _has_liveliness_subscriber) - 24usize];
    ["Offset of field: _ze_advanced_subscriber_t::_liveliness_subscriber"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_t, _liveliness_subscriber) - 32usize];
    ["Offset of field: _ze_advanced_subscriber_t::_has_heartbeat_subscriber"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_t, _has_heartbeat_subscriber) - 56usize];
    ["Offset of field: _ze_advanced_subscriber_t::_heartbeat_subscriber"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_t, _heartbeat_subscriber) - 64usize];
    ["Offset of field: _ze_advanced_subscriber_t::_state"]
        [::std::mem::offset_of!(_ze_advanced_subscriber_t, _state) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_advanced_subscriber_t {
    pub _val: _ze_advanced_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_advanced_subscriber_t"]
        [::std::mem::size_of::<ze_owned_advanced_subscriber_t>() - 104usize];
    ["Alignment of ze_owned_advanced_subscriber_t"]
        [::std::mem::align_of::<ze_owned_advanced_subscriber_t>() - 8usize];
    ["Offset of field: ze_owned_advanced_subscriber_t::_val"]
        [::std::mem::offset_of!(ze_owned_advanced_subscriber_t, _val) - 0usize];
};
pub type ze_loaned_advanced_subscriber_t = _ze_advanced_subscriber_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_advanced_subscriber_t {
    pub _this: ze_owned_advanced_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_advanced_subscriber_t"]
        [::std::mem::size_of::<ze_moved_advanced_subscriber_t>() - 104usize];
    ["Alignment of ze_moved_advanced_subscriber_t"]
        [::std::mem::align_of::<ze_moved_advanced_subscriber_t>() - 8usize];
    ["Offset of field: ze_moved_advanced_subscriber_t::_this"]
        [::std::mem::offset_of!(ze_moved_advanced_subscriber_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn ze_internal_advanced_subscriber_null(obj: *mut ze_owned_advanced_subscriber_t);
}
unsafe extern "C" {
    pub fn ze_internal_advanced_subscriber_check(
        obj: *const ze_owned_advanced_subscriber_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_loan(
        obj: *const ze_owned_advanced_subscriber_t,
    ) -> *const ze_loaned_advanced_subscriber_t;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_loan_mut(
        obj: *mut ze_owned_advanced_subscriber_t,
    ) -> *mut ze_loaned_advanced_subscriber_t;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_move(
        obj: *mut ze_owned_advanced_subscriber_t,
    ) -> *mut ze_moved_advanced_subscriber_t;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_take(
        obj: *mut ze_owned_advanced_subscriber_t,
        src: *mut ze_moved_advanced_subscriber_t,
    );
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_drop(obj: *mut ze_moved_advanced_subscriber_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sample_miss_listener_t {
    pub _id: usize,
    pub _statesref: _ze_advanced_subscriber_state_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_sample_miss_listener_t"]
        [::std::mem::size_of::<_ze_sample_miss_listener_t>() - 24usize];
    ["Alignment of _ze_sample_miss_listener_t"]
        [::std::mem::align_of::<_ze_sample_miss_listener_t>() - 8usize];
    ["Offset of field: _ze_sample_miss_listener_t::_id"]
        [::std::mem::offset_of!(_ze_sample_miss_listener_t, _id) - 0usize];
    ["Offset of field: _ze_sample_miss_listener_t::_statesref"]
        [::std::mem::offset_of!(_ze_sample_miss_listener_t, _statesref) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_sample_miss_listener_t {
    pub _val: _ze_sample_miss_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_sample_miss_listener_t"]
        [::std::mem::size_of::<ze_owned_sample_miss_listener_t>() - 24usize];
    ["Alignment of ze_owned_sample_miss_listener_t"]
        [::std::mem::align_of::<ze_owned_sample_miss_listener_t>() - 8usize];
    ["Offset of field: ze_owned_sample_miss_listener_t::_val"]
        [::std::mem::offset_of!(ze_owned_sample_miss_listener_t, _val) - 0usize];
};
pub type ze_loaned_sample_miss_listener_t = _ze_sample_miss_listener_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_sample_miss_listener_t {
    pub _this: ze_owned_sample_miss_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_sample_miss_listener_t"]
        [::std::mem::size_of::<ze_moved_sample_miss_listener_t>() - 24usize];
    ["Alignment of ze_moved_sample_miss_listener_t"]
        [::std::mem::align_of::<ze_moved_sample_miss_listener_t>() - 8usize];
    ["Offset of field: ze_moved_sample_miss_listener_t::_this"]
        [::std::mem::offset_of!(ze_moved_sample_miss_listener_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn ze_internal_sample_miss_listener_null(obj: *mut ze_owned_sample_miss_listener_t);
}
unsafe extern "C" {
    pub fn ze_internal_sample_miss_listener_check(
        obj: *const ze_owned_sample_miss_listener_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_loan(
        obj: *const ze_owned_sample_miss_listener_t,
    ) -> *const ze_loaned_sample_miss_listener_t;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_loan_mut(
        obj: *mut ze_owned_sample_miss_listener_t,
    ) -> *mut ze_loaned_sample_miss_listener_t;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_move(
        obj: *mut ze_owned_sample_miss_listener_t,
    ) -> *mut ze_moved_sample_miss_listener_t;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_take(
        obj: *mut ze_owned_sample_miss_listener_t,
        src: *mut ze_moved_sample_miss_listener_t,
    );
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_drop(obj: *mut ze_moved_sample_miss_listener_t);
}
unsafe extern "C" {
    #[doc = " Just some bytes.\n\n Constant alias for string: `\"zenoh/bytes\"`.\n\n This encoding supposes that the payload was created with c:func:`z_bytes_from_buf`, c:func:`z_bytes_from_slice` or\n similar functions and its data can be accessed via c:func:`z_bytes_to_slice`."]
    pub fn z_encoding_zenoh_bytes() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_ZENOH_BYTES: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A UTF-8 string.\n Constant alias for string: `\"zenoh/string\"`.\n\n This encoding supposes that the payload was created with c:func:`z_bytes_from_str`, c:func:`z_bytes_from_string` or\n similar functions and its data can be accessed via c:func:`z_bytes_to_string`."]
    pub fn z_encoding_zenoh_string() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_ZENOH_STRING: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Zenoh serialized data.\n Constant alias for string: `\"zenoh/serialized\"`.\n\n This encoding supposes that the payload was created with serialization functions.\n The `schema` field may contain the details of serialziation format."]
    pub fn z_encoding_zenoh_serialized() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_ZENOH_SERIALIZED: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific stream of bytes.\n Constant alias for string: `\"application/octet-stream\"`."]
    pub fn z_encoding_application_octet_stream() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_OCTET_STREAM: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A textual file.\n Constant alias for string: `\"text/plain\"`."]
    pub fn z_encoding_text_plain() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_PLAIN: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON data intended to be consumed by an application.\n Constant alias for string: `\"application/json\"`."]
    pub fn z_encoding_application_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSON: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON data intended to be human readable.\n Constant alias for string: `\"text/json\"`."]
    pub fn z_encoding_text_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_JSON: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Common Data Representation (CDR)-encoded data.\n Constant alias for string: `\"application/cdr\"`."]
    pub fn z_encoding_application_cdr() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_CDR: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Concise Binary Object Representation (CBOR)-encoded data.\n Constant alias for string: `\"application/cbor\"`."]
    pub fn z_encoding_application_cbor() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_CBOR: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " YAML data intended to be consumed by an application.\n Constant alias for string: `\"application/yaml\"`."]
    pub fn z_encoding_application_yaml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_YAML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " YAML data intended to be human readable.\n Constant alias for string: `\"text/yaml\"`."]
    pub fn z_encoding_text_yaml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_YAML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON5 encoded data that are human readable.\n Constant alias for string: `\"text/json5\"`."]
    pub fn z_encoding_text_json5() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_JSON5: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Python object serialized using `pickle <https://docs.python.org/3/library/pickle.html>`_.\n Constant alias for string: `\"application/python-serialized-object\"`."]
    pub fn z_encoding_application_python_serialized_object() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_PYTHON_SERIALIZED_OBJECT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific protobuf-encoded data.\n Constant alias for string: `\"application/protobuf\"`."]
    pub fn z_encoding_application_protobuf() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_PROTOBUF: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Java serialized object.\n Constant alias for string: `\"application/java-serialized-object\"`."]
    pub fn z_encoding_application_java_serialized_object() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JAVA_SERIALIZED_OBJECT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An `openmetrics <https://github.com/OpenObservability/OpenMetrics>`_ data, commonly used by\n `Prometheus <https://prometheus.io/>`_.\n Constant alias for string: `\"application/openmetrics-text\"`."]
    pub fn z_encoding_application_openmetrics_text() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_OPENMETRICS_TEXT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Portable Network Graphics (PNG) image.\n Constant alias for string: `\"image/png\"`."]
    pub fn z_encoding_image_png() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_PNG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Joint Photographic Experts Group (JPEG) image.\n Constant alias for string: `\"image/jpeg\"`."]
    pub fn z_encoding_image_jpeg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_JPEG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Graphics Interchange Format (GIF) image.\n Constant alias for string: `\"image/gif\"`."]
    pub fn z_encoding_image_gif() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_GIF: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A BitMap (BMP) image.\n Constant alias for string: `\"image/bmp\"`."]
    pub fn z_encoding_image_bmp() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_BMP: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Web Portable (WebP) image.\n Constant alias for string: `\"image/webp\"`."]
    pub fn z_encoding_image_webp() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_WEBP: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An XML file intended to be consumed by an application.\n Constant alias for string: `\"application/xml\"`."]
    pub fn z_encoding_application_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_XML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An encoded list of tuples, each consisting of a name and a value.\n Constant alias for string: `\"application/x-www-form-urlencoded\"`."]
    pub fn z_encoding_application_x_www_form_urlencoded() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_X_WWW_FORM_URLENCODED: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An HTML file.\n Constant alias for string: `\"text/html\"`."]
    pub fn z_encoding_text_html() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_HTML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An XML file that is human-readable.\n Constant alias for string: `\"text/xml\"`."]
    pub fn z_encoding_text_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_XML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A CSS file.\n Constant alias for string: `\"text/css\"`."]
    pub fn z_encoding_text_css() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_CSS: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JavaScript file.\n Constant alias for string: `\"text/javascript\"`."]
    pub fn z_encoding_text_javascript() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_JAVASCRIPT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Markdown file.\n Constant alias for string: `\"text/markdown\"`."]
    pub fn z_encoding_text_markdown() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_MARKDOWN: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A CSV file.\n Constant alias for string: `\"text/csv\"`."]
    pub fn z_encoding_text_csv() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_CSV: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific SQL query.\n Constant alias for string: `\"application/sql\"`."]
    pub fn z_encoding_application_sql() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_SQL: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Constrained Application Protocol (CoAP) data intended for CoAP-to-HTTP and HTTP-to-CoAP proxies.\n Constant alias for string: `\"application/coap-payload\"`."]
    pub fn z_encoding_application_coap_payload() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_COAP_PAYLOAD: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Defines a JSON document structure for expressing a sequence of operations to apply to a JSON document.\n Constant alias for string: `\"application/json-patch+json\"`."]
    pub fn z_encoding_application_json_patch_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSON_PATCH_JSON: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8.\n Constant alias for string: `\"application/json-seq\"`."]
    pub fn z_encoding_application_json_seq() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSON_SEQ: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSONPath defines a string syntax for selecting and extracting JSON values from within a given JSON value.\n Constant alias for string: `\"application/jsonpath\"`."]
    pub fn z_encoding_application_jsonpath() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSONPATH: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSON Web Token (JWT).\n Constant alias for string: `\"application/jwt\"`."]
    pub fn z_encoding_application_jwt() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JWT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific MPEG-4 encoded data, either audio or video.\n Constant alias for string: `\"application/mp4\"`."]
    pub fn z_encoding_application_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_MP4: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A SOAP 1.2 message serialized as XML 1.0.\n Constant alias for string: `\"application/soap+xml\"`."]
    pub fn z_encoding_application_soap_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_SOAP_XML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A YANG-encoded data commonly used by the Network Configuration Protocol (NETCONF).\n Constant alias for string: `\"application/yang\"`."]
    pub fn z_encoding_application_yang() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_YANG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A MPEG-4 Advanced Audio Coding (AAC) media.\n Constant alias for string: `\"audio/aac\"`."]
    pub fn z_encoding_audio_aac() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_AAC: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Free Lossless Audio Codec (FLAC) media.\n Constant alias for string: `\"audio/flac\"`."]
    pub fn z_encoding_audio_flac() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_FLAC: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An audio codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.\n Constant alias for string: `\"audio/mp4\"`."]
    pub fn z_encoding_audio_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_MP4: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An Ogg-encapsulated audio stream.\n Constant alias for string: `\"audio/ogg\"`."]
    pub fn z_encoding_audio_ogg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_OGG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Vorbis-encoded audio stream.\n Constant alias for string: `\"audio/vorbis\"`."]
    pub fn z_encoding_audio_vorbis() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_VORBIS: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h261-encoded video stream.\n Constant alias for string: `\"video/h261\"`."]
    pub fn z_encoding_video_h261() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H261: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h263-encoded video stream.\n Constant alias for string: `\"video/h263\"`."]
    pub fn z_encoding_video_h263() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H263: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h264-encoded video stream.\n Constant alias for string: `\"video/h264\"`."]
    pub fn z_encoding_video_h264() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H264: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h265-encoded video stream.\n Constant alias for string: `\"video/h265\"`."]
    pub fn z_encoding_video_h265() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H265: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h266-encoded video stream.\n Constant alias for string: `\"video/h266\"`."]
    pub fn z_encoding_video_h266() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H266: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A video codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.\n Constant alias for string: `\"video/mp4\"`."]
    pub fn z_encoding_video_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_MP4: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An Ogg-encapsulated video stream.\n Constant alias for string: `\"video/ogg\"`."]
    pub fn z_encoding_video_ogg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_OGG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An uncompressed, studio-quality video stream.\n Constant alias for string: `\"video/raw\"`."]
    pub fn z_encoding_video_raw() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_RAW: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A VP8-encoded video stream.\n Constant alias for string: `\"video/vp8\"`."]
    pub fn z_encoding_video_vp8() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_VP8: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A VP9-encoded video stream.\n Constant alias for string: `\"video/vp9\"`."]
    pub fn z_encoding_video_vp9() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_VP9: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Returns a loaned default `z_loaned_encoding_t`."]
    pub fn z_encoding_loan_default() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_string_t` by wrapping a ``const char *`` string.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n   value: Pointer to a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_string_from_str(
        str_: *mut z_view_string_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_string_t` by wrapping a ``const char *`` substring.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n   value: Pointer to a null terminated string.\n   len: Size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_string_from_substr(
        str_: *mut z_view_string_t,
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a null-terminated string.\n It is a loaned key expression that aliases ``name``.\n This function will fail if the string is not in canon form.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_str(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a null-terminated string.\n It is a loaned key expression that aliases ``name``.\n Input key expression is not checked for correctness.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string."]
    pub fn z_view_keyexpr_from_str_unchecked(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_keyexpr_t` from a null-terminated string with auto canonization.\n It is a loaned key expression that aliases ``name``.\n The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying len.\n May SEGFAULT if `name` is NULL or lies in read-only memory (as values initialized with string literals do).\n `name` must outlive the constructed key expression.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_str_autocanonize(
        keyexpr: *mut z_view_keyexpr_t,
        name: *mut ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` by aliasing a substring.\n It is a loaned key expression that aliases ``name``.\n This function will fail if the string is not in canon form.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_substr(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_keyexpr_t` from a substring with auto canonization.\n It is a loaned key expression that aliases ``name``.\n The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying len.\n May SEGFAULT if `name` is NULL or lies in read-only memory (as values initialized with string literals do).\n `name` must outlive the constructed key expression.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Pointer to the size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_substr_autocanonize(
        keyexpr: *mut z_view_keyexpr_t,
        name: *mut ::std::os::raw::c_char,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a substring.\n It is a loaned key expression that aliases ``name``.\n Input key expression is not checked for correctness.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Size of the string."]
    pub fn z_view_keyexpr_from_substr_unchecked(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Gets a string view from a :c:type:`z_keyexpr_t`.\n\n Parameters:\n   keyexpr: Pointer to a loaned instance of :c:type:`z_keyexpr_t`.\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_as_view_string(
        keyexpr: *const z_loaned_keyexpr_t,
        str_: *mut z_view_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs key expression by concatenation of key expression in `left` with a string in `right`.\n\n To avoid odd behaviors, concatenating a key expression starting with `*` to one ending with `*` is forbidden by this\n operation, as this would extremely likely cause bugs.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` to keyexpr to concatenate to.\n   right: Pointer to the start of the substring that will be concatenated.\n   len: Length of the substring to concatenate.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_concat(
        key: *mut z_owned_keyexpr_t,
        left: *const z_loaned_keyexpr_t,
        right: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs key expression by performing path-joining (automatically inserting '/'). The resulting key expression is\n automatically canonized.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` to the left part of the resulting key expression.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` to the right part of the resulting key expression.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_join(
        key: *mut z_owned_keyexpr_t,
        left: *const z_loaned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends the suffix portion of a key expression to another key expression (automatically inserting '/').\n\n Only the suffix portion of the key expression is preserved. All other components of the resulting key\n expression will be discarded.\n The resulting key expression is automatically canonized.\n\n Parameters:\n   prefix: Pointer to :c:type:`z_owned_keyexpr_t` to the key expression to append to.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` whose suffix will be appended.\n\n Return:\n   ``0`` if the append was successful; a ``negative value`` otherwise."]
    pub fn _z_keyexpr_append_suffix(
        prefix: *mut z_owned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends a string segment to a key expression (automatically inserting '/'). The resulting key expression is\n automatically canonized.\n\n Parameters:\n   prefix: Pointer to :c:type:`z_owned_keyexpr_t` to the key expression to append to.\n   right: Pointer to a character array representing the string to append.\n   len: Length of the string segment in ``right`` to append.\n\n Return:\n   ``0`` if append successful, ``negative value`` otherwise."]
    pub fn _z_keyexpr_append_substr(
        prefix: *mut z_owned_keyexpr_t,
        right: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends multiple null-terminated strings to a key expression (automatically inserting '/' between each component).\n The resulting key expression is automatically canonized.\n\n Parameters:\n   prefix: Pointer to :c:type:`z_owned_keyexpr_t` representing the key expression to append to.\n   strs: Array of ``count`` null-terminated strings to append, in order.\n   count: Number of strings in the array.\n\n Return:\n   ``0`` if all appends were successful, ``negative value`` if any append failed."]
    pub fn _z_keyexpr_append_str_array(
        prefix: *mut z_owned_keyexpr_t,
        strs: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the relation between `left` and `right` from the `left`'s point of view.\n\n Note that this is slower than `z_keyexpr_intersects` and `keyexpr_includes`, so you should favor these methods for\n most applications.\n\n Parameters:\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` representing left key expression.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` representing right key expression.\n\n Return:\n   Relation between `left` and `right` from the `left`'s point of view."]
    pub fn z_keyexpr_relation_to(
        left: *const z_loaned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_keyexpr_intersection_level_t;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr is valid and in canonical form.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a non-null terminated string.\n   len: Number of characters in ``start``.\n\n Return:\n   ``0`` if the passed string is a valid (and canon) key expression, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_is_canon(start: *const ::std::os::raw::c_char, len: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Canonizes of a given keyexpr in string representation.\n The canonization is performed over the passed string, possibly shortening it by modifying ``len``.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a non-null terminated string.\n   len: Number of characters in ``start``.\n\n Return:\n   ``0`` if canonization successful, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_canonize(start: *mut ::std::os::raw::c_char, len: *mut usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Canonizes of a given keyexpr in string representation.\n The canonization is performed over the passed string, possibly shortening it by setting null at the end.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a null terminated string.\n\n Return:\n   ``0`` if canonization successful, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_canonize_null_terminated(start: *mut ::std::os::raw::c_char) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr contains another keyexpr in its set.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if ``l`` includes ``r``, i.e. the set defined by ``l`` contains every key belonging to the set\n   defined by ``r``. Otherwise, returns ``false``."]
    pub fn z_keyexpr_includes(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr intersects with another keyexpr.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if keyexprs intersect, i.e. there exists at least one key which is contained in both of the\n   sets defined by ``l`` and ``r``. Otherwise, returns ``false``."]
    pub fn z_keyexpr_intersects(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t)
        -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if two keyexpr are equal.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if both ``l`` and ``r`` are equal. Otherwise, returns  ``false``."]
    pub fn z_keyexpr_equals(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a new, zenoh-allocated, default configuration.\n It consists in a default set of properties for zenoh session configuration.\n\n Parameters:\n   config: Pointer to uninitialized :c:type:`z_owned_config_t`.\n\n Return:\n   ``0`` in case of success, or a ``negative value`` otherwise."]
    pub fn z_config_default(config: *mut z_owned_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the property with the given integer key from the configuration.\n\n Parameters:\n   config: Pointer to a :c:type:`z_loaned_config_t` to get the property from.\n   key: Integer key of the requested property.\n\n Return:\n   The requested property value."]
    pub fn zp_config_get(
        config: *const z_loaned_config_t,
        key: u8,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts or replaces the property with the given integer key in the configuration.\n\n Parameters:\n   config: Pointer to a :c:type:`z_loaned_config_t` to modify.\n   key: Integer key of the property to be inserted.\n   value: Property value to be inserted.\n\n Return:\n   ``0`` if insertion is successful, ``negative value`` otherwise."]
    pub fn zp_config_insert(
        config: *mut z_loaned_config_t,
        key: u8,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_encoding_t` from a null terminated string.\n\n Parameters:\n   encoding: Pointer to an uninitialized :c:type:`z_owned_encoding_t`.\n   s: Pointer to the null terminated string to use.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_from_str(
        encoding: *mut z_owned_encoding_t,
        s: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_encoding_t` from a null terminated string.\n\n Parameters:\n   encoding: Pointer to an uninitialized :c:type:`z_owned_encoding_t`.\n   s: Pointer to the string to use.\n   len: Number of characters from the string s to use.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_from_substr(
        encoding: *mut z_owned_encoding_t,
        s: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sets a schema to this encoding from a null-terminated string. Zenoh does not define what a schema is and its\n semantics is left to the implementer. E.g. a common schema for `text/plain` encoding is `utf-8`.\n\n Parameters:\n   encoding: Pointer to initialized :c:type:`z_loaned_encoding_t`.\n   schema: Pointer to the null terminated string to use as a schema.\n\n Return:\n   ``0`` in case of success,``negative value`` otherwise."]
    pub fn z_encoding_set_schema_from_str(
        encoding: *mut z_loaned_encoding_t,
        schema: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sets a schema to this encoding from a substring. Zenoh does not define what a schema is and its semantics is left\n to the implementer. E.g. a common schema for `text/plain` encoding is `utf-8`.\n\n Parameters:\n   encoding: Pointer to initialized :c:type:`z_loaned_encoding_t`.\n   schema: Pointer to the substring start.\n   len: Number of characters to consider.\n\n Return:\n   ``0`` if in case of success,``negative value`` otherwise."]
    pub fn z_encoding_set_schema_from_substr(
        encoding: *mut z_loaned_encoding_t,
        schema: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a string from a :c:type:`z_loaned_encoding_t`.\n\n Parameters:\n   encoding: Pointer to the :c:type:`z_loaned_encoding_t` to use.\n   string: Pointer to an uninitialized :c:type:`z_owned_string_t` to store the string.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_to_string(
        encoding: *const z_loaned_encoding_t,
        string: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if two encodings are equal.\n\n Parameters:\n   left: Pointer to the first :c:type:`z_loaned_encoding_t` to compare.\n   right: Pointer to the second :c:type:`z_loaned_encoding_t` to compare.\n\n Return:\n   ``true`` if `left` equals `right`, ``false`` otherwise."]
    pub fn z_encoding_equals(
        left: *const z_loaned_encoding_t,
        right: *const z_loaned_encoding_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the bytes data from a reply error payload by aliasing it.\n\n Parameters:\n   reply_err: Pointer to a :c:type:`z_loaned_reply_err_t` to get data from.\n\n Return:\n   Pointer to the data as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_reply_err_payload(reply_err: *const z_loaned_reply_err_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a reply error encoding by aliasing it.\n\n Parameters:\n   reply_err: Pointer to the :c:type:`z_loaned_reply_err_t` to get the encoding from.\n\n Return:\n   Pointer to the encoding as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_reply_err_encoding(
        reply_err: *const z_loaned_reply_err_t,
    ) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_slice_t` by copying a buffer into it.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`.\n   data: Pointer to the data that will be copied into slice.\n   len: Number of bytes to copy.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_slice_copy_from_buf(
        slice: *mut z_owned_slice_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_slice_t` by transferring ownership over a data to it.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`.\n   data: Pointer to the data to be owned by `slice`.\n   len: Number of bytes in `data`.\n   deleter: A thread-safe delete function to free the `data`. Will be called once when `slice` is dropped.\n     Can be NULL in the case where `data` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_slice_from_buf(
        slice: *mut z_owned_slice_t,
        data: *mut u8,
        len: usize,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_slice_t`.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_view_slice_t`.\n   data: Pointer to the data to be pointed by `slice`.\n   len: Number of bytes in `data`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_view_slice_from_buf(
        slice: *mut z_view_slice_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds an empty :c:type:`z_owned_slice_t`.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`."]
    pub fn z_slice_empty(slice: *mut z_owned_slice_t);
}
unsafe extern "C" {
    #[doc = " Gets date pointer of a bytes array.\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to get data from.\n\n Return:\n   The data pointer."]
    pub fn z_slice_data(slice: *const z_loaned_slice_t) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Gets the total number of bytes in a bytes array.\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to get length from.\n\n Return:\n   The number of bytes."]
    pub fn z_slice_len(slice: *const z_loaned_slice_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Checks if slice is empty\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to check.\n\n Return:\n   ``true`` if the container is empty, ``false`` otherwise."]
    pub fn z_slice_is_empty(slice: *const z_loaned_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_slice_t`\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n   dst: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the decoded slice.\n\n Return:\n   ``0`` if decode is successful, or a ``negative value`` otherwise."]
    pub fn z_bytes_to_slice(
        bytes: *const z_loaned_bytes_t,
        dst: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_string_t`\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the decoded string.\n\n Return:\n   ``0`` if decode is successful, or a ``negative value`` otherwise."]
    pub fn z_bytes_to_string(
        bytes: *const z_loaned_bytes_t,
        str_: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a slice into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded slice.\n   slice: Pointer to the slice to convert. The slice will be consumed upon function return.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *mut z_moved_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a slice into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded slice.\n   slice: Pointer to the slice to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the data to convert. Ownership is transferred to the `bytes`.\n   len: Number of bytes to consider.\n   deleter: A thread-safe delete function to free the `data`. Will be called once when `bytes` is dropped.\n     Can be NULL in the case where `data` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_buf(
        bytes: *mut z_owned_bytes_t,
        data: *mut u8,
        len: usize,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the data to convert.\n   len: Number of bytes to consider.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_buf(
        bytes: *mut z_owned_bytes_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts statically allocated constant data into a :c:type:`z_owned_bytes_t` by aliasing.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the statically allocated constant data to encode.\n   len: Number of bytes to consider.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_static_buf(
        bytes: *mut z_owned_bytes_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a string into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   s: Pointer to the string to convert. The string will be consumed upon function return.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_string(bytes: *mut z_owned_bytes_t, s: *mut z_moved_string_t)
        -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a string into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   s: Pointer to the string to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_string(
        bytes: *mut z_owned_bytes_t,
        s: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a null-terminated string into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the string to converts. Ownership is transferred to the `bytes`.\n   deleter: A thread-safe delete function to free the `value`. Will be called once when `bytes` is dropped.\n     Can be NULL in the case where `value` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_str(
        bytes: *mut z_owned_bytes_t,
        value: *mut ::std::os::raw::c_char,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                value: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a null-terminated string into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the string to converts.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a statically allocated constant null-terminated string into a :c:type:`z_owned_bytes_t` by aliasing.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the statically allocated constant string to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_static_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs an empty payload.\n\n Parameters:\n   bytes: Pointer to an unitialized :c:type:`z_loaned_bytes_t` instance."]
    pub fn z_bytes_empty(bytes: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Returns total number of bytes in the container.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n\n Return:\n   Number of the bytes in the container."]
    pub fn z_bytes_len(bytes: *const z_loaned_bytes_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Checks if container is empty\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n\n Return:\n   ``true`` if conainer is empty,  ``false`` otherwise."]
    pub fn z_bytes_is_empty(bytes: *const z_loaned_bytes_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns an iterator on raw bytes slices contained in the `z_loaned_bytes_t`.\n\n Zenoh may store data in non-contiguous regions of memory, this iterator\n then allows to access raw data directly without any attempt of deserializing it.\n Please note that no guarantee is provided on the internal memory layout.\n The only provided guarantee is on the bytes order that is preserved.\n\n Parameters:\n   bytes: Data to iterate over.\n\n Return:\n   The constructed :c:type:`z_bytes_slice_iterator_t`."]
    pub fn z_bytes_get_slice_iterator(bytes: *const z_loaned_bytes_t) -> z_bytes_slice_iterator_t;
}
unsafe extern "C" {
    #[doc = " Constructs :c:type:`z_view_slice_t` providing view to the next slice.\n\n Parameters:\n   iter: An iterator over slices of serialized data.\n   out: An uninitialized :c:type:`z_view_slice_t` that will contain next slice.\n\n Return:\n   ``false`` when iterator reaches the end,  ``true`` otherwise."]
    pub fn z_bytes_slice_iterator_next(
        iter: *mut z_bytes_slice_iterator_t,
        out: *mut z_view_slice_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns a reader for the `bytes`.\n\n The `bytes` should outlive the reader and should not be modified, while reader is in use.\n\n Parameters:\n   bytes: Data to read.\n\n Return:\n   The constructed :c:type:`z_bytes_reader_t`."]
    pub fn z_bytes_get_reader(bytes: *const z_loaned_bytes_t) -> z_bytes_reader_t;
}
unsafe extern "C" {
    #[doc = " Reads data into specified destination.\n\n Parameters:\n   reader: Data reader to read from.\n   dst: Buffer where the read data is written.\n   len: Maximum number of bytes to read.\n\n Return:\n   Number of bytes read. If return value is smaller than `len`, it means that the end of the data was reached."]
    pub fn z_bytes_reader_read(reader: *mut z_bytes_reader_t, dst: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Sets the `reader` position indicator for the payload to the value pointed to by offset.\n The new position is exactly `offset` bytes measured from the beginning of the payload if origin is `SEEK_SET`,\n from the current reader position if origin is `SEEK_CUR`, and from the end of the payload if origin is `SEEK_END`.\n\n Parameters:\n   reader: Data reader to reposition.\n   offset: New position ffset in bytes.\n   origin: Origin for the new position.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_reader_seek(
        reader: *mut z_bytes_reader_t,
        offset: i64,
        origin: ::std::os::raw::c_int,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the read position indicator.\n\n Parameters:\n   reader: Data reader to get position of.\n\n Return:\n   Read position indicator on success or -1L if failure occurs."]
    pub fn z_bytes_reader_tell(reader: *mut z_bytes_reader_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets number of bytes that can still be read.\n\n Parameters:\n   reader: Data reader.\n\n Return:\n   Number of bytes that can still be read."]
    pub fn z_bytes_reader_remaining(reader: *const z_bytes_reader_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Constructs an empty writer for payload.\n\n Parameters:\n   writer: An uninitialized memory location where writer is to be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_writer_empty(writer: *mut z_owned_bytes_writer_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Finishes writing and returns underlying bytes.\n\n Parameters:\n   writer: A data writer.\n   bytes: An uninitialized memory location where bytes is to be constructed."]
    pub fn z_bytes_writer_finish(writer: *mut z_moved_bytes_writer_t, bytes: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Writes `len` bytes from `src` into underlying :c:type:`z_loaned_bytes_t`.\n\n Parameters:\n   writer: A data writer.\n   src: Buffer to write from.\n   len: Number of bytes to write.\n\n Return:\n   ``0`` if write is successful, ``negative value`` otherwise."]
    pub fn z_bytes_writer_write_all(
        writer: *mut z_loaned_bytes_writer_t,
        src: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends bytes.\n This allows to compose a serialized data out of multiple `z_owned_bytes_t` that may point to different memory\n regions. Said in other terms, it allows to create a linear view on different memory regions without copy.\n\n Parameters:\n   writer: A data writer.\n   bytes: A data to append.\n\n Return:\n   ``0`` if write is successful, ``negative value`` otherwise."]
    pub fn z_bytes_writer_append(
        writer: *mut z_loaned_bytes_writer_t,
        bytes: *mut z_moved_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Create timestamp.\n\n Parameters:\n   ts: An uninitialized :c:type:`z_timestamp_t`.\n   zs: Pointer to a :c:type:`z_loaned_session_t` to get the id from.\n\n Return:\n   ``0`` if encode is successful, ``negative value`` otherwise (for example if RTC is not available on the system)."]
    pub fn z_timestamp_new(ts: *mut z_timestamp_t, zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns NTP64 time associated with this timestamp.\n\n Parameters:\n   ts: Pointer to the valid :c:type:`z_timestamp_t`.\n\n Return:\n   NTP64 time value"]
    pub fn z_timestamp_ntp64_time(ts: *const z_timestamp_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Returns id associated with this timestamp.\n\n Parameters:\n   ts: Pointer to the valid :c:type:`z_timestamp_t`.\n\n Return:\n   Associated id represented by c:type:`z_id_t`"]
    pub fn z_timestamp_id(ts: *const z_timestamp_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Creates an entity global id.\n\n Parameters:\n   gid: An uninitialized :c:type:`z_entity_global_id_t`.\n   zid: Pointer to a :c:type:`z_id_t` zenoh id.\n   eid: :c:type:`uint32_t` entity id."]
    pub fn z_entity_global_id_new(
        gid: *mut z_entity_global_id_t,
        zid: *const z_id_t,
        eid: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the entity id of the entity global id.\n\n Parameters:\n   gid: Pointer to the valid :c:type:`z_entity_global_id_t`.\n\n Return:\n   Entity id represented by c:type:`uint32_t`."]
    pub fn z_entity_global_id_eid(gid: *const z_entity_global_id_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Returns the zenoh id of entity global id.\n\n Parameters:\n   gid: Pointer to the valid :c:type:`z_entity_global_id_t`.\n\n Return:\n   Zenoh id represented by c:type:`z_id_t`."]
    pub fn z_entity_global_id_zid(gid: *const z_entity_global_id_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new source info.\n\n Parameters:\n   info: An uninitialized :c:type:`z_owned_source_info_t`.\n   source_id: Pointer to a :c:type:`z_entity_global_id_t` global entity id.\n   source_sn: :c:type:`uint32_t` sequence number.\n\n Return:\n   ``0`` if construction is successful, ``negative value`` otherwise.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_new(
        info: *mut z_owned_source_info_t,
        source_id: *const z_entity_global_id_t,
        source_sn: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the sequence number associated with this source info.\n\n Parameters:\n   info: Pointer to the :c:type:`z_loaned_source_info_t` to get the parameters from.\n\n Return:\n   :c:type:`uint32_t` sequence number.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_sn(info: *const z_loaned_source_info_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Returns the sequence number associated with this source info.\n\n Parameters:\n   info: Pointer to the :c:type:`z_loaned_source_info_t` to get the parameters from.\n\n Return:\n   Global entity ID as a :c:type:`z_entity_global_id_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_id(info: *const z_loaned_source_info_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Builds a default query target.\n\n Return:\n   The constructed :c:type:`z_query_target_t`."]
    pub fn z_query_target_default() -> z_query_target_t;
}
unsafe extern "C" {
    #[doc = " Builds an automatic query consolidation :c:type:`z_query_consolidation_t`.\n\n A query consolidation strategy will automatically be selected depending on the query selector.\n If selector contains time range properties, no consolidation is performed.\n Otherwise the :c:func:`z_query_consolidation_latest` strategy is used.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_auto() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a default :c:type:`z_query_consolidation_t`.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_default() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a latest query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy optimizes bandwidth on all links in the system but will provide a very poor latency.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_latest() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a monotonic query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy offers the best latency. Replies are directly transmitted to the application when received\n without needing to wait for all replies. This mode does not guarantee that there will be no duplicates.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_monotonic() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a no query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy is useful when querying timeseries data bases or when using quorums.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_none() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Gets a query parameters field.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the parameters from.\n   parameters: Pointer to an uninitialized :c:type:`z_view_string_t` to contain the parameters."]
    pub fn z_query_parameters(query: *const z_loaned_query_t, parameters: *mut z_view_string_t);
}
unsafe extern "C" {
    #[doc = " Gets a query payload by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the value from.\n\n Return:\n   Pointer to the payload as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_query_payload(query: *const z_loaned_query_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a query encoding by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the value from.\n\n Return:\n   Pointer to the encoding as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_query_encoding(query: *const z_loaned_query_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Gets a query attachment value by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the attachment from.\n\n Return:\n   Pointer to the attachment as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_query_attachment(query: *const z_loaned_query_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a query keyexpr by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a:c:type:`z_keyexpr_t`."]
    pub fn z_query_keyexpr(query: *const z_loaned_query_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Builds a new sample closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_sample_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_sample(
        closure: *mut z_owned_closure_sample_t,
        call: z_closure_sample_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a sample closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_sample_t` to call.\n   sample: Pointer to the :c:type:`z_loaned_sample_t` to pass to the closure."]
    pub fn z_closure_sample_call(
        closure: *const z_loaned_closure_sample_t,
        sample: *mut z_loaned_sample_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new query closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_query_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_query(
        closure: *mut z_owned_closure_query_t,
        call: z_closure_query_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a query closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_query_t` to call.\n   query: Pointer to the :c:type:`z_loaned_query_t` to pass to the closure."]
    pub fn z_closure_query_call(
        closure: *const z_loaned_closure_query_t,
        query: *mut z_loaned_query_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new reply closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_reply_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_reply(
        closure: *mut z_owned_closure_reply_t,
        call: z_closure_reply_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a reply closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_reply_t` to call.\n   reply: Pointer to the :c:type:`z_loaned_reply_t` to pass to the closure."]
    pub fn z_closure_reply_call(
        closure: *const z_loaned_closure_reply_t,
        reply: *mut z_loaned_reply_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new hello closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_hello_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_hello(
        closure: *mut z_owned_closure_hello_t,
        call: z_closure_hello_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a hello closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_hello_t` to call.\n   hello: Pointer to the :c:type:`z_loaned_hello_t` to pass to the closure."]
    pub fn z_closure_hello_call(
        closure: *const z_loaned_closure_hello_t,
        hello: *mut z_loaned_hello_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new zid closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_zid_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_zid(
        closure: *mut z_owned_closure_zid_t,
        call: z_closure_zid_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a zid closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_zid_t` to call.\n   zid: Pointer to the :c:type:`z_id_t` to pass to the closure."]
    pub fn z_closure_zid_call(closure: *const z_loaned_closure_zid_t, id: *const z_id_t);
}
unsafe extern "C" {
    #[doc = " Builds a new matching status closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_matching_status_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_matching_status(
        closure: *mut z_owned_closure_matching_status_t,
        call: z_closure_matching_status_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a matching status closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_matching_status_t` to call.\n   status: Pointer to the :c:type:`z_matching_status_t` to pass to the closure."]
    pub fn z_closure_matching_status_call(
        closure: *const z_loaned_closure_matching_status_t,
        status: *const z_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new sample miss closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`ze_owned_closure_miss_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn ze_closure_miss(
        closure: *mut ze_owned_closure_miss_t,
        call: ze_closure_miss_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a sample miss closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`ze_loaned_closure_miss_t` to call.\n   status: Pointer to the :c:type:`ze_miss_t` to pass to the closure.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn ze_closure_miss_call(closure: *const ze_loaned_closure_miss_t, miss: *const ze_miss_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_null(obj: *mut z_owned_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_check(obj: *const z_owned_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_loan(obj: *const z_owned_string_t) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_loan_mut(obj: *mut z_owned_string_t) -> *mut z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_move(obj: *mut z_owned_string_t) -> *mut z_moved_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_take(obj: *mut z_owned_string_t, src: *mut z_moved_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_drop(obj: *mut z_moved_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_take_from_loaned(
        dst: *mut z_owned_string_t,
        src: *mut z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_clone(obj: *mut z_owned_string_t, src: *const z_loaned_string_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_keyexpr_null(obj: *mut z_owned_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_keyexpr_check(obj: *const z_owned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_loan(obj: *const z_owned_keyexpr_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_loan_mut(obj: *mut z_owned_keyexpr_t) -> *mut z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_move(obj: *mut z_owned_keyexpr_t) -> *mut z_moved_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_take(obj: *mut z_owned_keyexpr_t, src: *mut z_moved_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_drop(obj: *mut z_moved_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_take_from_loaned(
        dst: *mut z_owned_keyexpr_t,
        src: *mut z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_clone(
        obj: *mut z_owned_keyexpr_t,
        src: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_config_null(obj: *mut z_owned_config_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_config_check(obj: *const z_owned_config_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_loan(obj: *const z_owned_config_t) -> *const z_loaned_config_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_loan_mut(obj: *mut z_owned_config_t) -> *mut z_loaned_config_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_move(obj: *mut z_owned_config_t) -> *mut z_moved_config_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_take(obj: *mut z_owned_config_t, src: *mut z_moved_config_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_drop(obj: *mut z_moved_config_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_take_from_loaned(
        dst: *mut z_owned_config_t,
        src: *mut z_loaned_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_clone(obj: *mut z_owned_config_t, src: *const z_loaned_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_session_null(obj: *mut z_owned_session_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_session_check(obj: *const z_owned_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_loan(obj: *const z_owned_session_t) -> *const z_loaned_session_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_loan_mut(obj: *mut z_owned_session_t) -> *mut z_loaned_session_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_move(obj: *mut z_owned_session_t) -> *mut z_moved_session_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_take(obj: *mut z_owned_session_t, src: *mut z_moved_session_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_drop(obj: *mut z_moved_session_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_subscriber_null(obj: *mut z_owned_subscriber_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_subscriber_check(obj: *const z_owned_subscriber_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_loan(obj: *const z_owned_subscriber_t) -> *const z_loaned_subscriber_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_loan_mut(obj: *mut z_owned_subscriber_t) -> *mut z_loaned_subscriber_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_move(obj: *mut z_owned_subscriber_t) -> *mut z_moved_subscriber_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_take(obj: *mut z_owned_subscriber_t, src: *mut z_moved_subscriber_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_drop(obj: *mut z_moved_subscriber_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_publisher_null(obj: *mut z_owned_publisher_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_publisher_check(obj: *const z_owned_publisher_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_loan(obj: *const z_owned_publisher_t) -> *const z_loaned_publisher_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_loan_mut(obj: *mut z_owned_publisher_t) -> *mut z_loaned_publisher_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_move(obj: *mut z_owned_publisher_t) -> *mut z_moved_publisher_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_take(obj: *mut z_owned_publisher_t, src: *mut z_moved_publisher_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_drop(obj: *mut z_moved_publisher_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_querier_null(obj: *mut z_owned_querier_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_querier_check(obj: *const z_owned_querier_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_loan(obj: *const z_owned_querier_t) -> *const z_loaned_querier_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_loan_mut(obj: *mut z_owned_querier_t) -> *mut z_loaned_querier_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_move(obj: *mut z_owned_querier_t) -> *mut z_moved_querier_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_take(obj: *mut z_owned_querier_t, src: *mut z_moved_querier_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_drop(obj: *mut z_moved_querier_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_matching_listener_null(obj: *mut z_owned_matching_listener_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_matching_listener_check(obj: *const z_owned_matching_listener_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_loan(
        obj: *const z_owned_matching_listener_t,
    ) -> *const z_loaned_matching_listener_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_loan_mut(
        obj: *mut z_owned_matching_listener_t,
    ) -> *mut z_loaned_matching_listener_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_move(
        obj: *mut z_owned_matching_listener_t,
    ) -> *mut z_moved_matching_listener_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_take(
        obj: *mut z_owned_matching_listener_t,
        src: *mut z_moved_matching_listener_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_drop(obj: *mut z_moved_matching_listener_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_queryable_null(obj: *mut z_owned_queryable_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_queryable_check(obj: *const z_owned_queryable_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_loan(obj: *const z_owned_queryable_t) -> *const z_loaned_queryable_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_loan_mut(obj: *mut z_owned_queryable_t) -> *mut z_loaned_queryable_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_move(obj: *mut z_owned_queryable_t) -> *mut z_moved_queryable_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_take(obj: *mut z_owned_queryable_t, src: *mut z_moved_queryable_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_drop(obj: *mut z_moved_queryable_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_hello_null(obj: *mut z_owned_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_hello_check(obj: *const z_owned_hello_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_loan(obj: *const z_owned_hello_t) -> *const z_loaned_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_loan_mut(obj: *mut z_owned_hello_t) -> *mut z_loaned_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_move(obj: *mut z_owned_hello_t) -> *mut z_moved_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_take(obj: *mut z_owned_hello_t, src: *mut z_moved_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_drop(obj: *mut z_moved_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_take_from_loaned(
        dst: *mut z_owned_hello_t,
        src: *mut z_loaned_hello_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_clone(obj: *mut z_owned_hello_t, src: *const z_loaned_hello_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_null(obj: *mut z_owned_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_check(obj: *const z_owned_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_loan(obj: *const z_owned_reply_t) -> *const z_loaned_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_loan_mut(obj: *mut z_owned_reply_t) -> *mut z_loaned_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_move(obj: *mut z_owned_reply_t) -> *mut z_moved_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_take(obj: *mut z_owned_reply_t, src: *mut z_moved_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_drop(obj: *mut z_moved_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_take_from_loaned(
        dst: *mut z_owned_reply_t,
        src: *mut z_loaned_reply_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_clone(obj: *mut z_owned_reply_t, src: *const z_loaned_reply_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_array_null(obj: *mut z_owned_string_array_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_array_check(obj: *const z_owned_string_array_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_loan(
        obj: *const z_owned_string_array_t,
    ) -> *const z_loaned_string_array_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_loan_mut(
        obj: *mut z_owned_string_array_t,
    ) -> *mut z_loaned_string_array_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_move(obj: *mut z_owned_string_array_t) -> *mut z_moved_string_array_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_take(obj: *mut z_owned_string_array_t, src: *mut z_moved_string_array_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_drop(obj: *mut z_moved_string_array_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_take_from_loaned(
        dst: *mut z_owned_string_array_t,
        src: *mut z_loaned_string_array_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_clone(
        obj: *mut z_owned_string_array_t,
        src: *const z_loaned_string_array_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_sample_null(obj: *mut z_owned_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_sample_check(obj: *const z_owned_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_loan(obj: *const z_owned_sample_t) -> *const z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_loan_mut(obj: *mut z_owned_sample_t) -> *mut z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_move(obj: *mut z_owned_sample_t) -> *mut z_moved_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_take(obj: *mut z_owned_sample_t, src: *mut z_moved_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_drop(obj: *mut z_moved_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_take_from_loaned(
        dst: *mut z_owned_sample_t,
        src: *mut z_loaned_sample_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_clone(obj: *mut z_owned_sample_t, src: *const z_loaned_sample_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_source_info_null(obj: *mut z_owned_source_info_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_source_info_check(obj: *const z_owned_source_info_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_loan(obj: *const z_owned_source_info_t) -> *const z_loaned_source_info_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_loan_mut(obj: *mut z_owned_source_info_t) -> *mut z_loaned_source_info_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_move(obj: *mut z_owned_source_info_t) -> *mut z_moved_source_info_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_take(obj: *mut z_owned_source_info_t, src: *mut z_moved_source_info_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_drop(obj: *mut z_moved_source_info_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_take_from_loaned(
        dst: *mut z_owned_source_info_t,
        src: *mut z_loaned_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_clone(
        obj: *mut z_owned_source_info_t,
        src: *const z_loaned_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_query_null(obj: *mut z_owned_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_query_check(obj: *const z_owned_query_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_loan(obj: *const z_owned_query_t) -> *const z_loaned_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_loan_mut(obj: *mut z_owned_query_t) -> *mut z_loaned_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_move(obj: *mut z_owned_query_t) -> *mut z_moved_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_take(obj: *mut z_owned_query_t, src: *mut z_moved_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_drop(obj: *mut z_moved_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_take_from_loaned(
        dst: *mut z_owned_query_t,
        src: *mut z_loaned_query_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_clone(obj: *mut z_owned_query_t, src: *const z_loaned_query_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_slice_null(obj: *mut z_owned_slice_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_slice_check(obj: *const z_owned_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_loan(obj: *const z_owned_slice_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_loan_mut(obj: *mut z_owned_slice_t) -> *mut z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_move(obj: *mut z_owned_slice_t) -> *mut z_moved_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_take(obj: *mut z_owned_slice_t, src: *mut z_moved_slice_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_drop(obj: *mut z_moved_slice_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_take_from_loaned(
        dst: *mut z_owned_slice_t,
        src: *mut z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_clone(obj: *mut z_owned_slice_t, src: *const z_loaned_slice_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_null(obj: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_check(obj: *const z_owned_bytes_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_loan(obj: *const z_owned_bytes_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_loan_mut(obj: *mut z_owned_bytes_t) -> *mut z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_move(obj: *mut z_owned_bytes_t) -> *mut z_moved_bytes_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_take(obj: *mut z_owned_bytes_t, src: *mut z_moved_bytes_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_drop(obj: *mut z_moved_bytes_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_take_from_loaned(
        dst: *mut z_owned_bytes_t,
        src: *mut z_loaned_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_clone(obj: *mut z_owned_bytes_t, src: *const z_loaned_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_writer_null(obj: *mut z_owned_bytes_writer_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_writer_check(obj: *const z_owned_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_loan(
        obj: *const z_owned_bytes_writer_t,
    ) -> *const z_loaned_bytes_writer_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_loan_mut(
        obj: *mut z_owned_bytes_writer_t,
    ) -> *mut z_loaned_bytes_writer_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_move(obj: *mut z_owned_bytes_writer_t) -> *mut z_moved_bytes_writer_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_take(obj: *mut z_owned_bytes_writer_t, src: *mut z_moved_bytes_writer_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_drop(obj: *mut z_moved_bytes_writer_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_take_from_loaned(
        dst: *mut z_owned_bytes_writer_t,
        src: *mut z_loaned_bytes_writer_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_err_null(obj: *mut z_owned_reply_err_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_err_check(obj: *const z_owned_reply_err_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_loan(obj: *const z_owned_reply_err_t) -> *const z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_loan_mut(obj: *mut z_owned_reply_err_t) -> *mut z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_move(obj: *mut z_owned_reply_err_t) -> *mut z_moved_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_take(obj: *mut z_owned_reply_err_t, src: *mut z_moved_reply_err_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_drop(obj: *mut z_moved_reply_err_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_take_from_loaned(
        dst: *mut z_owned_reply_err_t,
        src: *mut z_loaned_reply_err_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_clone(
        obj: *mut z_owned_reply_err_t,
        src: *const z_loaned_reply_err_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_encoding_null(obj: *mut z_owned_encoding_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_encoding_check(obj: *const z_owned_encoding_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_loan(obj: *const z_owned_encoding_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_loan_mut(obj: *mut z_owned_encoding_t) -> *mut z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_move(obj: *mut z_owned_encoding_t) -> *mut z_moved_encoding_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_take(obj: *mut z_owned_encoding_t, src: *mut z_moved_encoding_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_drop(obj: *mut z_moved_encoding_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_take_from_loaned(
        dst: *mut z_owned_encoding_t,
        src: *mut z_loaned_encoding_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_clone(
        obj: *mut z_owned_encoding_t,
        src: *const z_loaned_encoding_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_sample_null(closure_sample: *mut z_owned_closure_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_sample_check(val: *const z_owned_closure_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_move(
        val: *mut z_owned_closure_sample_t,
    ) -> *mut z_moved_closure_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_take(
        obj: *mut z_owned_closure_sample_t,
        src: *mut z_moved_closure_sample_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_drop(obj: *mut z_moved_closure_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_loan(
        val: *const z_owned_closure_sample_t,
    ) -> *const z_loaned_closure_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_query_null(closure_query: *mut z_owned_closure_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_query_check(val: *const z_owned_closure_query_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_move(val: *mut z_owned_closure_query_t) -> *mut z_moved_closure_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_take(
        obj: *mut z_owned_closure_query_t,
        src: *mut z_moved_closure_query_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_drop(obj: *mut z_moved_closure_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_loan(
        val: *const z_owned_closure_query_t,
    ) -> *const z_loaned_closure_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_reply_null(closure_reply: *mut z_owned_closure_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_reply_check(val: *const z_owned_closure_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_move(val: *mut z_owned_closure_reply_t) -> *mut z_moved_closure_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_take(
        obj: *mut z_owned_closure_reply_t,
        src: *mut z_moved_closure_reply_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_drop(obj: *mut z_moved_closure_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_loan(
        val: *const z_owned_closure_reply_t,
    ) -> *const z_loaned_closure_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_hello_null(closure_hello: *mut z_owned_closure_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_hello_check(val: *const z_owned_closure_hello_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_move(val: *mut z_owned_closure_hello_t) -> *mut z_moved_closure_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_take(
        obj: *mut z_owned_closure_hello_t,
        src: *mut z_moved_closure_hello_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_drop(obj: *mut z_moved_closure_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_loan(
        val: *const z_owned_closure_hello_t,
    ) -> *const z_loaned_closure_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_zid_null(closure_zid: *mut z_owned_closure_zid_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_zid_check(val: *const z_owned_closure_zid_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_move(val: *mut z_owned_closure_zid_t) -> *mut z_moved_closure_zid_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_take(obj: *mut z_owned_closure_zid_t, src: *mut z_moved_closure_zid_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_drop(obj: *mut z_moved_closure_zid_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_loan(val: *const z_owned_closure_zid_t) -> *const z_loaned_closure_zid_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_matching_status_null(
        closure_matching_status: *mut z_owned_closure_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_matching_status_check(
        val: *const z_owned_closure_matching_status_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_move(
        val: *mut z_owned_closure_matching_status_t,
    ) -> *mut z_moved_closure_matching_status_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_take(
        obj: *mut z_owned_closure_matching_status_t,
        src: *mut z_moved_closure_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_drop(obj: *mut z_moved_closure_matching_status_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_loan(
        val: *const z_owned_closure_matching_status_t,
    ) -> *const z_loaned_closure_matching_status_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn ze_internal_closure_miss_null(closure_miss: *mut ze_owned_closure_miss_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn ze_internal_closure_miss_check(val: *const ze_owned_closure_miss_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn ze_closure_miss_move(val: *mut ze_owned_closure_miss_t) -> *mut ze_moved_closure_miss_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn ze_closure_miss_take(
        obj: *mut ze_owned_closure_miss_t,
        src: *mut ze_moved_closure_miss_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn ze_closure_miss_drop(obj: *mut ze_moved_closure_miss_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn ze_closure_miss_loan(
        val: *const ze_owned_closure_miss_t,
    ) -> *const ze_loaned_closure_miss_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_is_empty(obj: *const z_view_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_loan(keyexpr: *const z_view_keyexpr_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_loan_mut(keyexpr: *mut z_view_keyexpr_t) -> *mut z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_empty(keyexpr: *mut z_view_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_is_empty(obj: *const z_view_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_loan(string: *const z_view_string_t) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_loan_mut(string: *mut z_view_string_t) -> *mut z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_empty(string: *mut z_view_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_is_empty(obj: *const z_view_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_loan(slice: *const z_view_slice_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_loan_mut(slice: *mut z_view_slice_t) -> *mut z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_empty(slice: *mut z_view_slice_t);
}
unsafe extern "C" {
    #[doc = " Gets data from a :c:type:`z_loaned_string_t`.\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get data from.\n\n Return:\n   Pointer to the string data."]
    pub fn z_string_data(str_: *const z_loaned_string_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets string length from a :c:type:`z_loaned_string_t`.\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get length from.\n\n Return:\n   Length of the string."]
    pub fn z_string_len(str_: *const z_loaned_string_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_string_t` by copying a ``const char *`` string.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a null terminated string to be copied.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_copy_from_str(
        str_: *mut z_owned_string_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_string_t` by transferring ownership over a null-terminated string to it.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a null terminated string to be owned by `str`.\n   deleter: A thread-safe delete function to free the `value`. Will be called once when `str` is dropped.\n     Can be NULL in the case where `value` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_from_str(
        str_: *mut z_owned_string_t,
        value: *mut ::std::os::raw::c_char,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                value: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds an empty :c:type:`z_owned_string_t`.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`."]
    pub fn z_string_empty(str_: *mut z_owned_string_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_string_t` by wrapping a substring specified by ``const char *`` and length `len`.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a string.\n   len: String size.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_copy_from_substr(
        str_: *mut z_owned_string_t,
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if string is empty\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to check.\n\n Return:\n  ``true`` if the string is empty, ``false`` otherwise."]
    pub fn z_string_is_empty(str_: *const z_loaned_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns :c:type:`z_loaned_slice_t` for the string\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get a slice.\n\n Return:\n   slice containing string data"]
    pub fn z_string_as_slice(str_: *const z_loaned_string_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Returns default :c:type:`z_priority_t` value"]
    pub fn z_priority_default() -> z_priority_t;
}
unsafe extern "C" {
    #[doc = " Returns id of Zenoh entity that transmitted hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   Id of the Zenoh entity that transmitted hello message."]
    pub fn z_hello_zid(hello: *const z_loaned_hello_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Returns type of Zenoh entity that transmitted hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   Type of the Zenoh entity that transmitted hello message."]
    pub fn z_hello_whatami(hello: *const z_loaned_hello_t) -> z_whatami_t;
}
unsafe extern "C" {
    #[doc = " Returns an array of locators of Zenoh entity that sent hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   :c:type:`z_loaned_string_array_t` containing locators."]
    pub fn zp_hello_locators(hello: *const z_loaned_hello_t) -> *const z_loaned_string_array_t;
}
unsafe extern "C" {
    #[doc = " Constructs an array of locators of Zenoh entity that sent hello message.\n\n Note that it is a method for zenoh-c compatiblity, in zenoh-pico :c:func:`zp_hello_locators`\n can be used.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n   locators_out: An uninitialized memory location where :c:type:`z_owned_string_array_t` will be constructed."]
    pub fn z_hello_locators(
        hello: *const z_loaned_hello_t,
        locators_out: *mut z_owned_string_array_t,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a non-owned non-null-terminated string from the kind of zenoh entity.\n\n The string has static storage (i.e. valid until the end of the program).\n\n Parameters:\n   whatami: A whatami bitmask of zenoh entity kind.\n   str_out: An uninitialized memory location where strring will be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_whatami_to_view_string(
        whatami: z_whatami_t,
        str_out: *mut z_view_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Scouts for other Zenoh entities like routers and/or peers.\n\n Parameters:\n   config: Moved :c:type:`z_owned_config_t` to configure the scouting with.\n   callback: Moved :c:type:`z_owned_closure_hello_t` callback.\n   options: Pointer to a :c:type:`z_scout_options_t` to configure the operation.\n\n Return:\n   ``0`` if scouting was successfully triggered, ``negative value`` otherwise."]
    pub fn z_scout(
        config: *mut z_moved_config_t,
        callback: *mut z_moved_closure_hello_t,
        options: *const z_scout_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_scout_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_scout_options_t`."]
    pub fn z_scout_options_default(options: *mut z_scout_options_t);
}
unsafe extern "C" {
    #[doc = " Opens a Zenoh session.\n\n Parameters:\n   zs: Pointer to an uninitialized :c:type:`z_owned_session_t` to store the session info.\n   config: Moved :c:type:`z_owned_config_t` to configure the session with.\n   options: Pointer to a :c:type:`z_open_options_t` to configure the operation.\n\n Return:\n   ``0`` if open is successful, ``negative value`` otherwise."]
    pub fn z_open(
        zs: *mut z_owned_session_t,
        config: *mut z_moved_config_t,
        options: *const z_open_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Closes a Zenoh session.\n\n Parameters:\n   zs: Loaned :c:type:`z_owned_session_t` to close.\n   options: Pointer to a :c:type:`z_close_options_t` to configure the operation.\n\n Return:\n   ``0`` if close is successful, ``negative value`` otherwise."]
    pub fn z_close(zs: *mut z_loaned_session_t, options: *const z_close_options_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if Zenoh session is closed.\n\n Parameters:\n   zs: Loaned :c:type:`z_owned_session_t`.\n\n Return:\n   ``true`` if session is closed, ``false`` otherwise."]
    pub fn z_session_is_closed(zs: *const z_loaned_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Fetches Zenoh IDs of all connected peers.\n\n The callback will be called once for each ID. It is guaranteed to never be called concurrently,\n and to be dropped before this function exits.\n\n Parameters:\n   zs: Pointer to :c:type:`z_loaned_session_t` to fetch peer id from.\n   callback: Moved :c:type:`z_owned_closure_zid_t` callback.\n\n Return:\n   ``0`` if operation was successfully triggered, ``negative value`` otherwise."]
    pub fn z_info_peers_zid(
        zs: *const z_loaned_session_t,
        callback: *mut z_moved_closure_zid_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Fetches Zenoh IDs of all connected routers.\n\n The callback will be called once for each ID. It is guaranteed to never be called concurrently,\n and to be dropped before this function exits.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to fetch router id from.\n   callback: Moved :c:type:`z_owned_closure_zid_t` callback.\n\n Return:\n   ``0`` if operation was successfully triggered, ``negative value`` otherwise."]
    pub fn z_info_routers_zid(
        zs: *const z_loaned_session_t,
        callback: *mut z_moved_closure_zid_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the local Zenoh ID associated to a given Zenoh session.\n\n If this function returns an array of 16 zeros, this means the session is invalid.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to get the id from.\n\n Return:\n   The local Zenoh ID of the session as :c:type:`z_id_t`."]
    pub fn z_info_zid(zs: *const z_loaned_session_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Converts a Zenoh ID into a string for print purposes.\n\n Parameters:\n   id: Pointer to the id to convert.\n   str: Pointer to uninitialized :c:type:`z_owned_string_t` to store the string.\n\n Return:\n   ``0`` if operation is successful, ``negative value`` otherwise."]
    pub fn z_id_to_string(id: *const z_id_t, str_: *mut z_owned_string_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_sample_keyexpr(sample: *const z_loaned_sample_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Gets the payload of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the payload from.\n\n Return:\n   The payload wrapped as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_sample_payload(sample: *const z_loaned_sample_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets the timestamp of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the timestamp from.\n\n Return:\n   The pointer to timestamp wrapped as a :c:type:`z_timestamp_t`. Returns NULL if no timestamp was set."]
    pub fn z_sample_timestamp(sample: *const z_loaned_sample_t) -> *const z_timestamp_t;
}
unsafe extern "C" {
    #[doc = " Gets the encoding of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the encoding from.\n\n Return:\n   The encoding wrapped as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_sample_encoding(sample: *const z_loaned_sample_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Gets the kind of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the kind from.\n\n Return:\n   The sample kind wrapped as a :c:type:`z_sample_kind_t`."]
    pub fn z_sample_kind(sample: *const z_loaned_sample_t) -> z_sample_kind_t;
}
unsafe extern "C" {
    #[doc = " Got a sample qos congestion control value.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the congestion control from.\n\n Return:\n   The congestion control wrapped as a :c:type:`z_congestion_control_t`."]
    pub fn z_sample_congestion_control(sample: *const z_loaned_sample_t) -> z_congestion_control_t;
}
unsafe extern "C" {
    #[doc = " Got whether sample qos express flag was set or not.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the express flag from.\n\n Return:\n   The express flag value."]
    pub fn z_sample_express(sample: *const z_loaned_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets sample qos priority value.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the qos priority from.\n\n Return:\n   The priority wrapped as a :c:type:`z_priority_t`."]
    pub fn z_sample_priority(sample: *const z_loaned_sample_t) -> z_priority_t;
}
unsafe extern "C" {
    #[doc = " Gets the attachment of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the attachment from.\n\n Return:\n   Pointer to the attachment as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_sample_attachment(sample: *const z_loaned_sample_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_put_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_put_options_t`."]
    pub fn z_put_options_default(options: *mut z_put_options_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_delete_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_delete_options_t`."]
    pub fn z_delete_options_default(options: *mut z_delete_options_t);
}
unsafe extern "C" {
    #[doc = " Puts data for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to put the data through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to put the data for.\n   payload: Moved :c:type:`z_owned_bytes_t` containing the data to put.\n   options: Pointer to a :c:type:`z_put_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_put(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deletes data for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to delete the data through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to delete the data for.\n   options: Pointer to a :c:type:`z_delete_options_t` to configure the operation.\n\n Return:\n   ``0`` if delete operation is successful, ``negative value`` otherwise."]
    pub fn z_delete(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_delete_options_t`."]
    pub fn z_publisher_options_default(options: *mut z_publisher_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a publisher for a given keyexpr.\n\n Data can be put and deleted with this publisher with the help of the\n :c:func:`z_publisher_put` and :c:func:`z_publisher_delete` functions.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the publisher through.\n   pub: Pointer to an uninitialized :c:type:`z_owned_publisher_t`.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the publisher with.\n   options: Pointer to a :c:type:`z_publisher_options_t` to configure the operation.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_publisher(
        zs: *const z_loaned_session_t,
        pub_: *mut z_owned_publisher_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_publisher_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the publisher.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_publisher_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_publisher(pub_: *mut z_moved_publisher_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_put_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_publisher_put_options_t`."]
    pub fn z_publisher_put_options_default(options: *mut z_publisher_put_options_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_delete_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_publisher_delete_options_t`."]
    pub fn z_publisher_delete_options_default(options: *mut z_publisher_delete_options_t);
}
unsafe extern "C" {
    #[doc = " Puts data for the keyexpr bound to the given publisher.\n\n Parameters:\n   pub: Pointer to a :c:type:`z_loaned_publisher_t` from where to put the data.\n   payload: Moved :c:type:`z_owned_bytes_t` containing the data to put.\n   options: Pointer to a :c:type:`z_publisher_put_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_publisher_put(
        pub_: *const z_loaned_publisher_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_publisher_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_publisher_put_impl(
        pub_: *const z_loaned_publisher_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_publisher_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deletes data from the keyexpr bound to the given publisher.\n\n Parameters:\n   pub: Pointer to a :c:type:`z_loaned_publisher_t` from where to delete the data.\n   options: Pointer to a :c:type:`z_publisher_delete_options_t` to configure the delete operation.\n\n Return:\n   ``0`` if delete operation is successful, ``negative value`` otherwise."]
    pub fn z_publisher_delete(
        pub_: *const z_loaned_publisher_t,
        options: *const z_publisher_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_publisher_delete_impl(
        pub_: *const z_loaned_publisher_t,
        options: *const z_publisher_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a publisher.\n\n Parameters:\n   publisher: Pointer to a :c:type:`z_loaned_publisher_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_publisher_keyexpr(publisher: *const z_loaned_publisher_t)
        -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Declares a matching listener, registering a callback for notifying subscribers matching with a given publisher.\n The callback will be run in the background until the corresponding publisher is dropped.\n\n Parameters:\n   publisher: A publisher to associate with matching listener.\n   callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber\n disconnects or when the first subscriber connects).\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_declare_background_matching_listener(
        publisher: *const z_loaned_publisher_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs matching listener, registering a callback for notifying subscribers matching with a given publisher.\n\n Parameters:\n   publisher: A publisher to associate with matching listener.\n   matching_listener: An uninitialized memory location where matching listener will be constructed. The matching\n listener's callback will be automatically dropped when the publisher is dropped. callback: A closure that will be\n called every time the matching status of the publisher changes (If last subscriber disconnects or when the first\n subscriber connects).\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_declare_matching_listener(
        publisher: *const z_loaned_publisher_t,
        matching_listener: *mut z_owned_matching_listener_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets publisher matching status - i.e. if there are any subscribers matching its key expression.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_get_matching_status(
        publisher: *const z_loaned_publisher_t,
        matching_status: *mut z_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the matching listener.\n\n Parameters:\n   listener: Moved :c:type:`z_owned_matching_listener_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_matching_listener(listener: *mut z_moved_matching_listener_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_get_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_get_options_t`."]
    pub fn z_get_options_default(options: *mut z_get_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a distributed query for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to send the query through.\n   keyexpr: Pointer to a  :c:type:`z_loaned_keyexpr_t` to send the query for.\n   parameters: Pointer to the parameters as a null-terminated string.\n   callback: Moved :c:type:`z_owned_closure_reply_t` callback.\n   options: Pointer to a :c:type:`z_get_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_get(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        parameters: *const ::std::os::raw::c_char,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sends a distributed query for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to send the query through.\n   keyexpr: Pointer to a  :c:type:`z_loaned_keyexpr_t` to send the query for.\n   parameters: Pointer to the parameters string.\n   parameters_len: Length of the parameters string.\n   callback: Moved :c:type:`z_owned_closure_reply_t` callback.\n   options: Pointer to a :c:type:`z_get_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_get_with_parameters_substr(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        parameters: *const ::std::os::raw::c_char,
        parameters_len: usize,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = "  Constructs the default value for :c:type:`z_querier_get_options_t`."]
    pub fn z_querier_get_options_default(options: *mut z_querier_get_options_t);
}
unsafe extern "C" {
    #[doc = "  Constructs the default value for :c:type:`z_querier_options_t`."]
    pub fn z_querier_options_default(options: *mut z_querier_options_t);
}
unsafe extern "C" {
    #[doc = " Constructs and declares a querier on the given key expression.\n\n The queries can be send with the help of the `z_querier_get()` function.\n\n Parameters:\n   zs: The Zenoh session.\n   querier: An uninitialized location in memory where querier will be constructed.\n   keyexpr: The key expression to send queries on.\n   options: Additional options for the querier.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_querier(
        zs: *const z_loaned_session_t,
        querier: *mut z_owned_querier_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *mut z_querier_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Frees memory and resets querier to its gravestone state."]
    pub fn z_undeclare_querier(querier: *mut z_moved_querier_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Query data from the matching queryables in the system.\n\n Replies are provided through a callback function.\n\n Parameters:\n   querier: The querier to make query from.\n   parameters: The query's parameters null-terminated string, similar to a url's query segment.\n   callback: The callback function that will be called on reception of replies for this query. It will be\n \t\t\t\tautomatically dropped once all replies are processed.\n   options: Additional options for the get. All owned fields will be consumed.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get(
        querier: *const z_loaned_querier_t,
        parameters: *const ::std::os::raw::c_char,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_querier_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Query data from the matching queryables in the system.\n\n Replies are provided through a callback function.\n\n Parameters:\n   querier: The querier to make query from.\n   parameters: The query's parameters string, similar to a url's query segment.\n   parameters_len: Length of the parameters string\n   callback: The callback function that will be called on reception of replies for this query. It will be\n \t\t\t\tautomatically dropped once all replies are processed.\n   options: Additional options for the get. All owned fields will be consumed.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get_with_parameters_substr(
        querier: *const z_loaned_querier_t,
        parameters: *const ::std::os::raw::c_char,
        parameters_len: usize,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_querier_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = "  Returns the key expression of the querier."]
    pub fn z_querier_keyexpr(querier: *const z_loaned_querier_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Declares a matching listener, registering a callback for notifying queryables matching the given querier key\n expression and target. The callback will be run in the background until the corresponding querier is dropped.\n\n Parameters:\n   querier: A querier to associate with matching listener.\n   callback: A closure that will be called every time the matching status of the querier changes (If last\n             queryable disconnects or when the first queryable connects).\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_declare_background_matching_listener(
        querier: *const z_loaned_querier_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs matching listener, registering a callback for notifying queryables matching with a given querier's\n key expression and target.\n\n Parameters:\n   querier: A querier to associate with matching listener.\n   matching_listener: An uninitialized memory location where matching listener will be constructed. The matching\n                      listener's callback will be automatically dropped when the querier is dropped.\n   callback: A closure that will be called every time the matching status of the querier changes (If last\n             queryable disconnects or when the first queryable connects).\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_declare_matching_listener(
        querier: *const z_loaned_querier_t,
        matching_listener: *mut z_owned_matching_listener_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets querier matching status - i.e. if there are any queryables matching its key expression and target.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get_matching_status(
        querier: *const z_loaned_querier_t,
        matching_status: *mut z_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if queryable answered with an OK, which allows this value to be treated as a sample.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to check.\n\n Return:\n   ``true`` if queryable answered with an OK, ``false`` otherwise."]
    pub fn z_reply_is_ok(reply: *const z_loaned_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the content of an OK reply.\n\n You should always make sure that :c:func:`z_reply_is_ok` returns ``true`` before calling this function.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n   The OK reply content wrapped as a :c:type:`z_loaned_sample_t`."]
    pub fn z_reply_ok(reply: *const z_loaned_reply_t) -> *const z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Gets the contents of an error reply.\n\n You should always make sure that :c:func:`z_reply_is_ok` returns ``false`` before calling this function.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n   The error reply content wrapped as a :c:type:`z_loaned_reply_err_t`."]
    pub fn z_reply_err(reply: *const z_loaned_reply_t) -> *const z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_queryable_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_queryable_options_t`."]
    pub fn z_queryable_options_default(options: *mut z_queryable_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a queryable for a given keyexpr.\n Note that dropping queryable drops its callback.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   queryable: Pointer to an uninitialized :c:type:`z_owned_queryable_t` to contain the queryable.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a :c:type:`z_owned_closure_query_t` callback.\n   options: Pointer to a :c:type:`z_queryable_options_t` to configure the declare.\n\n Return:\n   ``0`` if declare operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_queryable(
        zs: *const z_loaned_session_t,
        queryable: *mut z_owned_queryable_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_query_t,
        options: *const z_queryable_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the queryable.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_queryable_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_queryable(pub_: *mut z_moved_queryable_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background queryable for a given keyexpr. The queryable callback will be called\n to proccess incoming queries until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a :c:type:`z_owned_closure_query_t` callback.\n   options: Pointer to a :c:type:`z_queryable_options_t` to configure the declare.\n\n Return:\n   ``0`` if declare operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_background_queryable(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_query_t,
        options: *const z_queryable_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_options_t`."]
    pub fn z_query_reply_options_default(options: *mut z_query_reply_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the reply with.\n   payload: Pointer to the reply data.\n   options: Pointer to a :c:type:`z_query_reply_options_t` to configure the reply.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply(
        query: *const z_loaned_query_t,
        keyexpr: *const z_loaned_keyexpr_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_query_reply_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_query_reply_sample(
        query: *const z_loaned_query_t,
        sample: *const z_loaned_sample_t,
        options: *const z_query_reply_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_del_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_del_options_t`."]
    pub fn z_query_reply_del_options_default(options: *mut z_query_reply_del_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply delete to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the reply with.\n   options: Pointer to a :c:type:`z_query_reply_del_options_t` to configure the reply.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply_del(
        query: *const z_loaned_query_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_query_reply_del_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_err_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_err_options_t`."]
    pub fn z_query_reply_err_options_default(options: *mut z_query_reply_err_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply error to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   payload: Moved reply error data payload.\n   options: Pointer to a :c:type:`z_query_reply_err_options_t` to configure the reply error.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply_err(
        query: *const z_loaned_query_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_query_reply_err_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a queryable.\n\n Parameters:\n   queryable: Pointer to a :c:type:`z_loaned_queryable_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`. Will return NULL if\n   corresponding session is closed or dropped."]
    pub fn z_queryable_keyexpr(queryable: *const z_loaned_queryable_t)
        -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Builds a new keyexpr.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the null-terminated string of the keyexpr.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_str(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a new keyexpr from a substring.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the start of the substring for keyxpr.\n   len: Length of the substring to consider.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_substr(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_keyexpr_t` from a null-terminated string with auto canonization.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_str_autocanonize(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_keyexpr_t` from a substring with auto canonization.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the start of the substring for keyexpr.\n   len: Length of the substring to consider. After the function return it will be equal to the canonized key\n     expression string length.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_substr_autocanonize(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a keyexpr, so that it is mapped on a numerical id.\n\n This numerical id is used on the network to save bandwidth and ease the retrieval of the concerned resource\n in the routing tables.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the keyexpr through.\n   declared_keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to contain the declared keyexpr.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the keyexpr with.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_keyexpr(
        zs: *const z_loaned_session_t,
        declared_keyexpr: *mut z_owned_keyexpr_t,
        keyexpr: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares a keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to undeclare the data through.\n   keyexpr: Moved :c:type:`z_owned_keyexpr_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_keyexpr(
        zs: *const z_loaned_session_t,
        keyexpr: *mut z_moved_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new empty string array.\n\n Parameters:\n   a: Pointer to an uninitialized :c:type:`z_owned_string_array_t` to store the array of strings."]
    pub fn z_string_array_new(a: *mut z_owned_string_array_t);
}
unsafe extern "C" {
    #[doc = " Appends specified value to the end of the string array by alias.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   value: Pointer to the string to be added.\n\n Return:\n   The new length of the array."]
    pub fn z_string_array_push_by_alias(
        a: *mut z_loaned_string_array_t,
        value: *const z_loaned_string_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Appends specified value to the end of the string array by copying.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   value: Pointer to the string to be added.\n\n Return:\n   The new length of the array."]
    pub fn z_string_array_push_by_copy(
        a: *mut z_loaned_string_array_t,
        value: *const z_loaned_string_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the value at the position of index in the string array.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   k: index value.\n\n Return:\n   `NULL` if the index is out of bounds."]
    pub fn z_string_array_get(
        a: *const z_loaned_string_array_t,
        k: usize,
    ) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements in the array."]
    pub fn z_string_array_len(a: *const z_loaned_string_array_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns ``true`` if the array is empty, ``false`` otherwise."]
    pub fn z_string_array_is_empty(a: *const z_loaned_string_array_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_subscriber_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_subscriber_options_t`."]
    pub fn z_subscriber_options_default(options: *mut z_subscriber_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a subscriber for a given keyexpr.\n Note that dropping subscriber drops its callback.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   sub: Pointer to a :c:type:`z_owned_subscriber_t` to contain the subscriber.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a`z_owned_closure_sample_t` callback.\n   options: Pointer to a :c:type:`z_subscriber_options_t` to configure the operation\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_subscriber(
        zs: *const z_loaned_session_t,
        sub: *mut z_owned_subscriber_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *const z_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the subscriber.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_subscriber_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_subscriber(pub_: *mut z_moved_subscriber_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background subscriber for a given keyexpr. Subscriber callback will be called to process the messages,\n until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a`z_owned_closure_sample_t` callback.\n   options: Pointer to a :c:type:`z_subscriber_options_t` to configure the operation\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_background_subscriber(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *const z_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a subscriber.\n\n Parameters:\n   subscriber: Pointer to a :c:type:`z_loaned_subscriber_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_subscriber_keyexpr(
        subscriber: *const z_loaned_subscriber_t,
    ) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Activate the batching mechanism, any message that would have been sent on the network by a subsequent api call (e.g\n z_put, z_get) will be instead stored until either: the batch is full, flushed with :c:func:`zp_batch_flush`, batching\n is stopped with :c:func:`zp_batch_stop`, a message needs to be sent immediately.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` that will start batching messages.\n\n Return:\n   ``0`` if batching started, ``negative value`` otherwise."]
    pub fn zp_batch_start(zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Send the currently batched messages on the network.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` that will send its batched messages.\n\n Return:\n   ``0`` if batch successfully sent, ``negative value`` otherwise."]
    pub fn zp_batch_flush(zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deactivate the batching mechanism and send the currently batched on the network.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` that will stop batching messages.\n\n Return:\n   ``0`` if batching stopped and batch successfully sent, ``negative value`` otherwise."]
    pub fn zp_batch_stop(zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Multi Thread Tasks helpers **************/\n/**\n Builds a :c:type:`zp_task_read_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_task_read_options_t`."]
    pub fn zp_task_read_options_default(options: *mut zp_task_read_options_t);
}
unsafe extern "C" {
    #[doc = " Starts a task to read from the network and process the received messages.\n\n Note that the task can be implemented in form of thread, process, etc. and its implementation is\n platform-dependent.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to start the task from.\n   options: Pointer to a :c:type:`zp_task_read_options_t` to configure the task.\n\n Return:\n   ``0`` if task started successfully, ``negative value`` otherwise."]
    pub fn zp_start_read_task(
        zs: *mut z_loaned_session_t,
        options: *const zp_task_read_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stops the read task.\n\n This may result in stopping a thread or a process depending on the target platform.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to stop the task from.\n\n Return:\n   ``0`` if task stopped successfully, ``negative value`` otherwise."]
    pub fn zp_stop_read_task(zs: *mut z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`zp_task_lease_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_task_lease_options_t`."]
    pub fn zp_task_lease_options_default(options: *mut zp_task_lease_options_t);
}
unsafe extern "C" {
    #[doc = " Starts a task to handle the session lease.\n\n This task will send ``KeepAlive`` messages when needed and will close the session when the lease is expired.\n When operating over a multicast transport, it also periodically sends the ``Join`` messages.\n Note that the task can be implemented in form of thread, process, etc. and its implementation is\n platform-dependent.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to start the task from.\n   options: Pointer to a :c:type:`zp_task_lease_options_t` to configure the task.\n\n Return:\n   ``0`` if task started successfully, ``negative value`` otherwise."]
    pub fn zp_start_lease_task(
        zs: *mut z_loaned_session_t,
        options: *const zp_task_lease_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stops the lease task.\n\n This may result in stopping a thread or a process depending on the target platform.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to stop the task from.\n\n Return:\n   ``0`` if task stopped successfully, ``negative value`` otherwise."]
    pub fn zp_stop_lease_task(zs: *mut z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Single Thread helpers **************/\n/**\n Builds a :c:type:`zp_read_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_read_options_t`."]
    pub fn zp_read_options_default(options: *mut zp_read_options_t);
}
unsafe extern "C" {
    #[doc = " Executes a single read from the network and process received messages.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to execute the read for.\n   options: Pointer to a :c:type:`zp_read_options_t` to configure the operation.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn zp_read(zs: *const z_loaned_session_t, options: *const zp_read_options_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`zp_send_keep_alive_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_send_keep_alive_options_t`."]
    pub fn zp_send_keep_alive_options_default(options: *mut zp_send_keep_alive_options_t);
}
unsafe extern "C" {
    #[doc = " Executes a single send keep alive procedure.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to execute the send for.\n   options: Pointer to a :c:type:`zp_send_keep_alive_options_t` to configure the operation.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn zp_send_keep_alive(
        zs: *const z_loaned_session_t,
        options: *const zp_send_keep_alive_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`zp_send_join_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_send_join_options_t`."]
    pub fn zp_send_join_options_default(options: *mut zp_send_join_options_t);
}
unsafe extern "C" {
    #[doc = " Executes a single send join procedure.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to execute the send for.\n   options: Pointer to a :c:type:`zp_send_keep_alive_options_t` to configure the operation.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn zp_send_join(
        zs: *const z_loaned_session_t,
        options: *const zp_send_join_options_t,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_t {
    pub _ring: _z_ring_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_t"][::std::mem::size_of::<_z_fifo_t>() - 40usize];
    ["Alignment of _z_fifo_t"][::std::mem::align_of::<_z_fifo_t>() - 8usize];
    ["Offset of field: _z_fifo_t::_ring"][::std::mem::offset_of!(_z_fifo_t, _ring) - 0usize];
};
unsafe extern "C" {
    pub fn _z_fifo_init(fifo: *mut _z_fifo_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_make(capacity: usize) -> _z_fifo_t;
}
unsafe extern "C" {
    pub fn _z_fifo_capacity(r: *const _z_fifo_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_fifo_len(r: *const _z_fifo_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_fifo_is_empty(r: *const _z_fifo_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_fifo_is_full(r: *const _z_fifo_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_fifo_push(
        r: *mut _z_fifo_t,
        e: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_fifo_push_drop(
        r: *mut _z_fifo_t,
        e: *mut ::std::os::raw::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_fifo_pull(r: *mut _z_fifo_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _z_fifo_clone(xs: *const _z_fifo_t, d_f: z_element_clone_f) -> *mut _z_fifo_t;
}
unsafe extern "C" {
    pub fn _z_fifo_clear(v: *mut _z_fifo_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_free(xs: *mut *mut _z_fifo_t, f_f: z_element_free_f);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_mt_t {
    pub _fifo: _z_fifo_t,
    pub is_closed: bool,
    pub _mutex: _z_mutex_t,
    pub _cv_not_full: _z_condvar_t,
    pub _cv_not_empty: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_mt_t"][::std::mem::size_of::<_z_fifo_mt_t>() - 56usize];
    ["Alignment of _z_fifo_mt_t"][::std::mem::align_of::<_z_fifo_mt_t>() - 8usize];
    ["Offset of field: _z_fifo_mt_t::_fifo"][::std::mem::offset_of!(_z_fifo_mt_t, _fifo) - 0usize];
    ["Offset of field: _z_fifo_mt_t::is_closed"]
        [::std::mem::offset_of!(_z_fifo_mt_t, is_closed) - 40usize];
    ["Offset of field: _z_fifo_mt_t::_mutex"]
        [::std::mem::offset_of!(_z_fifo_mt_t, _mutex) - 44usize];
    ["Offset of field: _z_fifo_mt_t::_cv_not_full"]
        [::std::mem::offset_of!(_z_fifo_mt_t, _cv_not_full) - 48usize];
    ["Offset of field: _z_fifo_mt_t::_cv_not_empty"]
        [::std::mem::offset_of!(_z_fifo_mt_t, _cv_not_empty) - 52usize];
};
unsafe extern "C" {
    pub fn _z_fifo_mt_init(fifo: *mut _z_fifo_mt_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_new(capacity: usize) -> *mut _z_fifo_mt_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_close(fifo: *mut _z_fifo_mt_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_clear(fifo: *mut _z_fifo_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_mt_free(fifo: *mut _z_fifo_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_mt_push(
        src: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        element_free: z_element_free_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_pull(
        dst: *mut ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_try_pull(
        dst: *mut ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_mt_t {
    pub _ring: _z_ring_t,
    pub is_closed: bool,
    pub _mutex: _z_mutex_t,
    pub _cv_not_empty: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_mt_t"][::std::mem::size_of::<_z_ring_mt_t>() - 56usize];
    ["Alignment of _z_ring_mt_t"][::std::mem::align_of::<_z_ring_mt_t>() - 8usize];
    ["Offset of field: _z_ring_mt_t::_ring"][::std::mem::offset_of!(_z_ring_mt_t, _ring) - 0usize];
    ["Offset of field: _z_ring_mt_t::is_closed"]
        [::std::mem::offset_of!(_z_ring_mt_t, is_closed) - 40usize];
    ["Offset of field: _z_ring_mt_t::_mutex"]
        [::std::mem::offset_of!(_z_ring_mt_t, _mutex) - 44usize];
    ["Offset of field: _z_ring_mt_t::_cv_not_empty"]
        [::std::mem::offset_of!(_z_ring_mt_t, _cv_not_empty) - 48usize];
};
unsafe extern "C" {
    pub fn _z_ring_mt_init(ring: *mut _z_ring_mt_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_new(capacity: usize) -> *mut _z_ring_mt_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_close(ring: *mut _z_ring_mt_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_clear(ring: *mut _z_ring_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_mt_free(ring: *mut _z_ring_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_mt_push(
        src: *const ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        element_free: z_element_free_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_pull(
        dst: *mut ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_try_pull(
        dst: *mut ::std::os::raw::c_void,
        context: *mut ::std::os::raw::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_sample_t {
    pub collection: _z_ring_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_sample_t"]
        [::std::mem::size_of::<_z_ring_handler_sample_t>() - 56usize];
    ["Alignment of _z_ring_handler_sample_t"]
        [::std::mem::align_of::<_z_ring_handler_sample_t>() - 8usize];
    ["Offset of field: _z_ring_handler_sample_t::collection"]
        [::std::mem::offset_of!(_z_ring_handler_sample_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_sample_rc_t {
    pub _val: *mut _z_ring_handler_sample_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_sample_rc_t"]
        [::std::mem::size_of::<_z_ring_handler_sample_rc_t>() - 16usize];
    ["Alignment of _z_ring_handler_sample_rc_t"]
        [::std::mem::align_of::<_z_ring_handler_sample_rc_t>() - 8usize];
    ["Offset of field: _z_ring_handler_sample_rc_t::_val"]
        [::std::mem::offset_of!(_z_ring_handler_sample_rc_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_sample_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_ring_handler_sample_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_sample_weak_t {
    pub _val: *mut _z_ring_handler_sample_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_sample_weak_t"]
        [::std::mem::size_of::<_z_ring_handler_sample_weak_t>() - 16usize];
    ["Alignment of _z_ring_handler_sample_weak_t"]
        [::std::mem::align_of::<_z_ring_handler_sample_weak_t>() - 8usize];
    ["Offset of field: _z_ring_handler_sample_weak_t::_val"]
        [::std::mem::offset_of!(_z_ring_handler_sample_weak_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_sample_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_ring_handler_sample_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_ring_handler_sample_t {
    pub _rc: _z_ring_handler_sample_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_ring_handler_sample_t"]
        [::std::mem::size_of::<z_owned_ring_handler_sample_t>() - 16usize];
    ["Alignment of z_owned_ring_handler_sample_t"]
        [::std::mem::align_of::<z_owned_ring_handler_sample_t>() - 8usize];
    ["Offset of field: z_owned_ring_handler_sample_t::_rc"]
        [::std::mem::offset_of!(z_owned_ring_handler_sample_t, _rc) - 0usize];
};
pub type z_loaned_ring_handler_sample_t = _z_ring_handler_sample_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_ring_handler_sample_t {
    pub _this: z_owned_ring_handler_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_ring_handler_sample_t"]
        [::std::mem::size_of::<z_moved_ring_handler_sample_t>() - 16usize];
    ["Alignment of z_moved_ring_handler_sample_t"]
        [::std::mem::align_of::<z_moved_ring_handler_sample_t>() - 8usize];
    ["Offset of field: z_moved_ring_handler_sample_t::_this"]
        [::std::mem::offset_of!(z_moved_ring_handler_sample_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_sample_t {
    pub collection: _z_fifo_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_sample_t"]
        [::std::mem::size_of::<_z_fifo_handler_sample_t>() - 56usize];
    ["Alignment of _z_fifo_handler_sample_t"]
        [::std::mem::align_of::<_z_fifo_handler_sample_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_sample_t::collection"]
        [::std::mem::offset_of!(_z_fifo_handler_sample_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_sample_rc_t {
    pub _val: *mut _z_fifo_handler_sample_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_sample_rc_t"]
        [::std::mem::size_of::<_z_fifo_handler_sample_rc_t>() - 16usize];
    ["Alignment of _z_fifo_handler_sample_rc_t"]
        [::std::mem::align_of::<_z_fifo_handler_sample_rc_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_sample_rc_t::_val"]
        [::std::mem::offset_of!(_z_fifo_handler_sample_rc_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_sample_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_fifo_handler_sample_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_sample_weak_t {
    pub _val: *mut _z_fifo_handler_sample_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_sample_weak_t"]
        [::std::mem::size_of::<_z_fifo_handler_sample_weak_t>() - 16usize];
    ["Alignment of _z_fifo_handler_sample_weak_t"]
        [::std::mem::align_of::<_z_fifo_handler_sample_weak_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_sample_weak_t::_val"]
        [::std::mem::offset_of!(_z_fifo_handler_sample_weak_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_sample_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_fifo_handler_sample_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_fifo_handler_sample_t {
    pub _rc: _z_fifo_handler_sample_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_fifo_handler_sample_t"]
        [::std::mem::size_of::<z_owned_fifo_handler_sample_t>() - 16usize];
    ["Alignment of z_owned_fifo_handler_sample_t"]
        [::std::mem::align_of::<z_owned_fifo_handler_sample_t>() - 8usize];
    ["Offset of field: z_owned_fifo_handler_sample_t::_rc"]
        [::std::mem::offset_of!(z_owned_fifo_handler_sample_t, _rc) - 0usize];
};
pub type z_loaned_fifo_handler_sample_t = _z_fifo_handler_sample_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_fifo_handler_sample_t {
    pub _this: z_owned_fifo_handler_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_fifo_handler_sample_t"]
        [::std::mem::size_of::<z_moved_fifo_handler_sample_t>() - 16usize];
    ["Alignment of z_moved_fifo_handler_sample_t"]
        [::std::mem::align_of::<z_moved_fifo_handler_sample_t>() - 8usize];
    ["Offset of field: z_moved_fifo_handler_sample_t::_this"]
        [::std::mem::offset_of!(z_moved_fifo_handler_sample_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_query_t {
    pub collection: _z_ring_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_query_t"][::std::mem::size_of::<_z_ring_handler_query_t>() - 56usize];
    ["Alignment of _z_ring_handler_query_t"]
        [::std::mem::align_of::<_z_ring_handler_query_t>() - 8usize];
    ["Offset of field: _z_ring_handler_query_t::collection"]
        [::std::mem::offset_of!(_z_ring_handler_query_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_query_rc_t {
    pub _val: *mut _z_ring_handler_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_query_rc_t"]
        [::std::mem::size_of::<_z_ring_handler_query_rc_t>() - 16usize];
    ["Alignment of _z_ring_handler_query_rc_t"]
        [::std::mem::align_of::<_z_ring_handler_query_rc_t>() - 8usize];
    ["Offset of field: _z_ring_handler_query_rc_t::_val"]
        [::std::mem::offset_of!(_z_ring_handler_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_query_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_ring_handler_query_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_query_weak_t {
    pub _val: *mut _z_ring_handler_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_query_weak_t"]
        [::std::mem::size_of::<_z_ring_handler_query_weak_t>() - 16usize];
    ["Alignment of _z_ring_handler_query_weak_t"]
        [::std::mem::align_of::<_z_ring_handler_query_weak_t>() - 8usize];
    ["Offset of field: _z_ring_handler_query_weak_t::_val"]
        [::std::mem::offset_of!(_z_ring_handler_query_weak_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_query_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_ring_handler_query_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_ring_handler_query_t {
    pub _rc: _z_ring_handler_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_ring_handler_query_t"]
        [::std::mem::size_of::<z_owned_ring_handler_query_t>() - 16usize];
    ["Alignment of z_owned_ring_handler_query_t"]
        [::std::mem::align_of::<z_owned_ring_handler_query_t>() - 8usize];
    ["Offset of field: z_owned_ring_handler_query_t::_rc"]
        [::std::mem::offset_of!(z_owned_ring_handler_query_t, _rc) - 0usize];
};
pub type z_loaned_ring_handler_query_t = _z_ring_handler_query_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_ring_handler_query_t {
    pub _this: z_owned_ring_handler_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_ring_handler_query_t"]
        [::std::mem::size_of::<z_moved_ring_handler_query_t>() - 16usize];
    ["Alignment of z_moved_ring_handler_query_t"]
        [::std::mem::align_of::<z_moved_ring_handler_query_t>() - 8usize];
    ["Offset of field: z_moved_ring_handler_query_t::_this"]
        [::std::mem::offset_of!(z_moved_ring_handler_query_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_query_t {
    pub collection: _z_fifo_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_query_t"][::std::mem::size_of::<_z_fifo_handler_query_t>() - 56usize];
    ["Alignment of _z_fifo_handler_query_t"]
        [::std::mem::align_of::<_z_fifo_handler_query_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_query_t::collection"]
        [::std::mem::offset_of!(_z_fifo_handler_query_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_query_rc_t {
    pub _val: *mut _z_fifo_handler_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_query_rc_t"]
        [::std::mem::size_of::<_z_fifo_handler_query_rc_t>() - 16usize];
    ["Alignment of _z_fifo_handler_query_rc_t"]
        [::std::mem::align_of::<_z_fifo_handler_query_rc_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_query_rc_t::_val"]
        [::std::mem::offset_of!(_z_fifo_handler_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_query_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_fifo_handler_query_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_query_weak_t {
    pub _val: *mut _z_fifo_handler_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_query_weak_t"]
        [::std::mem::size_of::<_z_fifo_handler_query_weak_t>() - 16usize];
    ["Alignment of _z_fifo_handler_query_weak_t"]
        [::std::mem::align_of::<_z_fifo_handler_query_weak_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_query_weak_t::_val"]
        [::std::mem::offset_of!(_z_fifo_handler_query_weak_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_query_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_fifo_handler_query_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_fifo_handler_query_t {
    pub _rc: _z_fifo_handler_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_fifo_handler_query_t"]
        [::std::mem::size_of::<z_owned_fifo_handler_query_t>() - 16usize];
    ["Alignment of z_owned_fifo_handler_query_t"]
        [::std::mem::align_of::<z_owned_fifo_handler_query_t>() - 8usize];
    ["Offset of field: z_owned_fifo_handler_query_t::_rc"]
        [::std::mem::offset_of!(z_owned_fifo_handler_query_t, _rc) - 0usize];
};
pub type z_loaned_fifo_handler_query_t = _z_fifo_handler_query_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_fifo_handler_query_t {
    pub _this: z_owned_fifo_handler_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_fifo_handler_query_t"]
        [::std::mem::size_of::<z_moved_fifo_handler_query_t>() - 16usize];
    ["Alignment of z_moved_fifo_handler_query_t"]
        [::std::mem::align_of::<z_moved_fifo_handler_query_t>() - 8usize];
    ["Offset of field: z_moved_fifo_handler_query_t::_this"]
        [::std::mem::offset_of!(z_moved_fifo_handler_query_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_reply_t {
    pub collection: _z_ring_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_reply_t"][::std::mem::size_of::<_z_ring_handler_reply_t>() - 56usize];
    ["Alignment of _z_ring_handler_reply_t"]
        [::std::mem::align_of::<_z_ring_handler_reply_t>() - 8usize];
    ["Offset of field: _z_ring_handler_reply_t::collection"]
        [::std::mem::offset_of!(_z_ring_handler_reply_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_reply_rc_t {
    pub _val: *mut _z_ring_handler_reply_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_reply_rc_t"]
        [::std::mem::size_of::<_z_ring_handler_reply_rc_t>() - 16usize];
    ["Alignment of _z_ring_handler_reply_rc_t"]
        [::std::mem::align_of::<_z_ring_handler_reply_rc_t>() - 8usize];
    ["Offset of field: _z_ring_handler_reply_rc_t::_val"]
        [::std::mem::offset_of!(_z_ring_handler_reply_rc_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_reply_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_ring_handler_reply_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_reply_weak_t {
    pub _val: *mut _z_ring_handler_reply_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_reply_weak_t"]
        [::std::mem::size_of::<_z_ring_handler_reply_weak_t>() - 16usize];
    ["Alignment of _z_ring_handler_reply_weak_t"]
        [::std::mem::align_of::<_z_ring_handler_reply_weak_t>() - 8usize];
    ["Offset of field: _z_ring_handler_reply_weak_t::_val"]
        [::std::mem::offset_of!(_z_ring_handler_reply_weak_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_reply_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_ring_handler_reply_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_ring_handler_reply_t {
    pub _rc: _z_ring_handler_reply_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_ring_handler_reply_t"]
        [::std::mem::size_of::<z_owned_ring_handler_reply_t>() - 16usize];
    ["Alignment of z_owned_ring_handler_reply_t"]
        [::std::mem::align_of::<z_owned_ring_handler_reply_t>() - 8usize];
    ["Offset of field: z_owned_ring_handler_reply_t::_rc"]
        [::std::mem::offset_of!(z_owned_ring_handler_reply_t, _rc) - 0usize];
};
pub type z_loaned_ring_handler_reply_t = _z_ring_handler_reply_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_ring_handler_reply_t {
    pub _this: z_owned_ring_handler_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_ring_handler_reply_t"]
        [::std::mem::size_of::<z_moved_ring_handler_reply_t>() - 16usize];
    ["Alignment of z_moved_ring_handler_reply_t"]
        [::std::mem::align_of::<z_moved_ring_handler_reply_t>() - 8usize];
    ["Offset of field: z_moved_ring_handler_reply_t::_this"]
        [::std::mem::offset_of!(z_moved_ring_handler_reply_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_reply_t {
    pub collection: _z_fifo_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_reply_t"][::std::mem::size_of::<_z_fifo_handler_reply_t>() - 56usize];
    ["Alignment of _z_fifo_handler_reply_t"]
        [::std::mem::align_of::<_z_fifo_handler_reply_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_reply_t::collection"]
        [::std::mem::offset_of!(_z_fifo_handler_reply_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_reply_rc_t {
    pub _val: *mut _z_fifo_handler_reply_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_reply_rc_t"]
        [::std::mem::size_of::<_z_fifo_handler_reply_rc_t>() - 16usize];
    ["Alignment of _z_fifo_handler_reply_rc_t"]
        [::std::mem::align_of::<_z_fifo_handler_reply_rc_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_reply_rc_t::_val"]
        [::std::mem::offset_of!(_z_fifo_handler_reply_rc_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_reply_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_fifo_handler_reply_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_reply_weak_t {
    pub _val: *mut _z_fifo_handler_reply_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_reply_weak_t"]
        [::std::mem::size_of::<_z_fifo_handler_reply_weak_t>() - 16usize];
    ["Alignment of _z_fifo_handler_reply_weak_t"]
        [::std::mem::align_of::<_z_fifo_handler_reply_weak_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_reply_weak_t::_val"]
        [::std::mem::offset_of!(_z_fifo_handler_reply_weak_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_reply_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_fifo_handler_reply_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_fifo_handler_reply_t {
    pub _rc: _z_fifo_handler_reply_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_fifo_handler_reply_t"]
        [::std::mem::size_of::<z_owned_fifo_handler_reply_t>() - 16usize];
    ["Alignment of z_owned_fifo_handler_reply_t"]
        [::std::mem::align_of::<z_owned_fifo_handler_reply_t>() - 8usize];
    ["Offset of field: z_owned_fifo_handler_reply_t::_rc"]
        [::std::mem::offset_of!(z_owned_fifo_handler_reply_t, _rc) - 0usize];
};
pub type z_loaned_fifo_handler_reply_t = _z_fifo_handler_reply_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_fifo_handler_reply_t {
    pub _this: z_owned_fifo_handler_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_fifo_handler_reply_t"]
        [::std::mem::size_of::<z_moved_fifo_handler_reply_t>() - 16usize];
    ["Alignment of z_moved_fifo_handler_reply_t"]
        [::std::mem::align_of::<z_moved_fifo_handler_reply_t>() - 8usize];
    ["Offset of field: z_moved_fifo_handler_reply_t::_this"]
        [::std::mem::offset_of!(z_moved_fifo_handler_reply_t, _this) - 0usize];
};
#[doc = " Represents a reader for serialized data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_deserializer_t {
    pub _reader: z_bytes_reader_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_deserializer_t"][::std::mem::size_of::<ze_deserializer_t>() - 32usize];
    ["Alignment of ze_deserializer_t"][::std::mem::align_of::<ze_deserializer_t>() - 8usize];
    ["Offset of field: ze_deserializer_t::_reader"]
        [::std::mem::offset_of!(ze_deserializer_t, _reader) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_serializer_t {
    pub _writer: _z_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_serializer_t"][::std::mem::size_of::<_ze_serializer_t>() - 40usize];
    ["Alignment of _ze_serializer_t"][::std::mem::align_of::<_ze_serializer_t>() - 8usize];
    ["Offset of field: _ze_serializer_t::_writer"]
        [::std::mem::offset_of!(_ze_serializer_t, _writer) - 0usize];
};
#[doc = " Represents a writer for serialized data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_serializer_t {
    #[doc = " Represents a writer for serialized data."]
    pub _val: _ze_serializer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_serializer_t"][::std::mem::size_of::<ze_owned_serializer_t>() - 40usize];
    ["Alignment of ze_owned_serializer_t"]
        [::std::mem::align_of::<ze_owned_serializer_t>() - 8usize];
    ["Offset of field: ze_owned_serializer_t::_val"]
        [::std::mem::offset_of!(ze_owned_serializer_t, _val) - 0usize];
};
#[doc = " Represents a writer for serialized data."]
pub type ze_loaned_serializer_t = _ze_serializer_t;
#[doc = " Represents a writer for serialized data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_serializer_t {
    pub _this: ze_owned_serializer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_serializer_t"][::std::mem::size_of::<ze_moved_serializer_t>() - 40usize];
    ["Alignment of ze_moved_serializer_t"]
        [::std::mem::align_of::<ze_moved_serializer_t>() - 8usize];
    ["Offset of field: ze_moved_serializer_t::_this"]
        [::std::mem::offset_of!(ze_moved_serializer_t, _this) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs an empty serializer.\n\n Parameters:\n   serializer: An uninitialized memory location where serializer is to be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn ze_serializer_empty(serializer: *mut ze_owned_serializer_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Finishes serialization and returns underlying bytes.\n\n Parameters:\n   serializer: A data serializer.\n   bytes: An uninitialized memory location where bytes is to be constructed."]
    pub fn ze_serializer_finish(
        serializer: *mut ze_moved_serializer_t,
        bytes: *mut z_owned_bytes_t,
    );
}
unsafe extern "C" {
    #[doc = " Returns a deserializer for :c:type:`z_loaned_bytes_t`.\n\n The `bytes` should outlive the reader and should not be modified, while reader is in use.\n\n Parameters:\n   bytes: Data to deserialize.\n\n Return:\n   The constructed :c:type:`ze_deserializer_t`."]
    pub fn ze_deserializer_from_bytes(bytes: *const z_loaned_bytes_t) -> ze_deserializer_t;
}
unsafe extern "C" {
    #[doc = " Checks if deserializer parsed all of its data.\n\n Parameters:\n   deserializer: A deserializer instance.\n\n Return:\n   ``True`` if there is no more data to parse, ``false`` otherwise."]
    pub fn ze_deserializer_is_done(deserializer: *const ze_deserializer_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Serializes array of bytes and writes it into an underlying :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   serializer: A serializer instance.\n   val: Pointer to the data to serialize.\n   len: Number of bytes to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_buf(
        serializer: *mut ze_loaned_serializer_t,
        val: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes slice and writes it into an underlying :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   serializer: A serializer instance.\n   val: A slice to serialize.\n   len: Number of bytes to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_slice(
        serializer: *mut ze_loaned_serializer_t,
        val: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes next portion of data and advances the reader position.\n\n Parameters:\n   deserializer: A deserializer instance.\n   val: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the deserialized slice.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserializer_deserialize_slice(
        deserializer: *mut ze_deserializer_t,
        val: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a null-terminated string and writes it into an underlying :c:type:`z_owned_bytes_t`.\n The string should be a valid UTF-8.\n\n Parameters:\n   serializer: A serializer instance.\n   val: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_str(
        serializer: *mut ze_loaned_serializer_t,
        val: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a substring and writes it into an underlying :c:type:`z_owned_bytes_t`.\n The substring should be a valid UTF-8.\n\n Parameters:\n   serializer: A serializer instance.\n   start: Pointer to the start of the substring to serialize.\n   len: Length of the substring to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_substr(
        serializer: *mut ze_loaned_serializer_t,
        start: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a string and writes it into an underlying :c:type:`z_owned_bytes_t`.\n The string should be a valid UTF-8.\n\n Parameters:\n   serializer: A serializer instance.\n   val: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_string(
        serializer: *mut ze_loaned_serializer_t,
        val: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes next portion of data and advances the reader position.\n\n Parameters:\n   deserializer: A deserializer instance.\n   val: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the deserialized string.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserializer_deserialize_string(
        deserializer: *mut ze_deserializer_t,
        val: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Initiate serialization of a sequence of multiple elements.\n\n Parameters:\n   serializer: A serializer instance.\n   len: Length of the sequence. Could be read during deserialization using\n     :c:func:`ze_deserializer_deserialize_sequence_length`.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_sequence_length(
        serializer: *mut ze_loaned_serializer_t,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Initiate deserialization of a sequence of multiple elements.\n\n Parameters:\n   deserializer: A deserializer instance.\n   len: A pointer where the length of the sequence (previously passed via\n     :c:func:`ze_serializer_serialize_sequence_length`) will be written.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserializer_deserialize_sequence_length(
        deserializer: *mut ze_deserializer_t,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes data into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized data.\n   data: Pointer to the data to serialize.\n   len: Number of bytes to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_buf(bytes: *mut z_owned_bytes_t, data: *const u8, len: usize)
        -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a string into a :c:type:`z_owned_bytes_t`.\n\n The string should be a valid UTF-8.\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized string.\n   s: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_string(
        bytes: *mut z_owned_bytes_t,
        s: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a null-terminated string into a :c:type:`z_owned_bytes_t`.\n The string should be a valid UTF-8.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized string.\n   value: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a substring into a :c:type:`z_owned_bytes_t`.\n The substring should be a valid UTF-8.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized string.\n   start: Pointer to the the start of string to serialize.\n   len: Length of the substring to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_substr(
        bytes: *mut z_owned_bytes_t,
        start: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a slice into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized slice.\n   slice: Pointer to the slice to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int8_t` into a :c:type:`z_owned_bytes_t` .\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int8_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int8(bytes: *mut z_owned_bytes_t, val: i8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int16_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int16_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int16(bytes: *mut z_owned_bytes_t, val: i16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int32_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int32_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int32(bytes: *mut z_owned_bytes_t, val: i32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int64_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int64_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int64(bytes: *mut z_owned_bytes_t, val: i64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint8_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint8_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint8(bytes: *mut z_owned_bytes_t, val: u8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint16_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint16_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint16(bytes: *mut z_owned_bytes_t, val: u16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint32_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint32_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint32(bytes: *mut z_owned_bytes_t, val: u32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint64_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint64_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint64(bytes: *mut z_owned_bytes_t, val: u64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `float` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `float` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_float(bytes: *mut z_owned_bytes_t, val: f32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `double` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `double` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_double(bytes: *mut z_owned_bytes_t, val: f64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `bool` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `bool` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_bool(bytes: *mut z_owned_bytes_t, val: bool) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a :c:type:`z_owned_slice_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   str: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the deserialized slice.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_slice(
        bytes: *const z_loaned_bytes_t,
        dst: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a :c:type:`z_owned_string_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the deserialized string.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_string(
        bytes: *const z_loaned_bytes_t,
        str_: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int8_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int8_t` to contain the deserialized.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int8(bytes: *const z_loaned_bytes_t, dst: *mut i8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int16_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int16_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int16(bytes: *const z_loaned_bytes_t, dst: *mut i16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int32_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int32_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int32(bytes: *const z_loaned_bytes_t, dst: *mut i32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int64_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int64_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int64(bytes: *const z_loaned_bytes_t, dst: *mut i64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint8_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint8_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint8(bytes: *const z_loaned_bytes_t, dst: *mut u8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint16_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint16_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint16(bytes: *const z_loaned_bytes_t, dst: *mut u16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint32_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint32_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint32(bytes: *const z_loaned_bytes_t, dst: *mut u32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint64_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint64_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint64(bytes: *const z_loaned_bytes_t, dst: *mut u64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `float`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `float` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_float(bytes: *const z_loaned_bytes_t, dst: *mut f32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `double`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `double` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_double(bytes: *const z_loaned_bytes_t, dst: *mut f64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a boolean.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `bool` to contain the deserialized value.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_bool(bytes: *const z_loaned_bytes_t, dst: *mut bool) -> z_result_t;
}
unsafe extern "C" {
    pub fn ze_internal_serializer_null(obj: *mut ze_owned_serializer_t);
}
unsafe extern "C" {
    pub fn ze_internal_serializer_check(obj: *const ze_owned_serializer_t) -> bool;
}
unsafe extern "C" {
    pub fn ze_serializer_loan(obj: *const ze_owned_serializer_t) -> *const ze_loaned_serializer_t;
}
unsafe extern "C" {
    pub fn ze_serializer_loan_mut(obj: *mut ze_owned_serializer_t) -> *mut ze_loaned_serializer_t;
}
unsafe extern "C" {
    pub fn ze_serializer_move(obj: *mut ze_owned_serializer_t) -> *mut ze_moved_serializer_t;
}
unsafe extern "C" {
    pub fn ze_serializer_take(obj: *mut ze_owned_serializer_t, src: *mut ze_moved_serializer_t);
}
unsafe extern "C" {
    pub fn ze_serializer_drop(obj: *mut ze_moved_serializer_t);
}
unsafe extern "C" {
    pub fn ze_serializer_take_from_loaned(
        dst: *mut ze_owned_serializer_t,
        src: *mut ze_loaned_serializer_t,
    ) -> z_result_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub _address: u8,
}
