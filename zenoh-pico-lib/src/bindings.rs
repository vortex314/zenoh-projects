/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type z_result_t = i8;
pub type StackType_t = u8;
pub type BaseType_t = ::std::os::raw::c_int;
pub type UBaseType_t = ::std::os::raw::c_uint;
pub type TickType_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_LIST_ITEM"][::std::mem::size_of::<xSTATIC_LIST_ITEM>() - 40usize];
    ["Alignment of xSTATIC_LIST_ITEM"][::std::mem::align_of::<xSTATIC_LIST_ITEM>() - 8usize];
    ["Offset of field: xSTATIC_LIST_ITEM::xDummy2"]
        [::std::mem::offset_of!(xSTATIC_LIST_ITEM, xDummy2) - 0usize];
    ["Offset of field: xSTATIC_LIST_ITEM::pvDummy3"]
        [::std::mem::offset_of!(xSTATIC_LIST_ITEM, pvDummy3) - 8usize];
};
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::std::os::raw::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::std::os::raw::c_void,
    pub ucDummy7: [u8; 16usize],
    pub xDummyCoreID: BaseType_t,
    pub pxDummy8: *mut ::std::os::raw::c_void,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut ::std::os::raw::c_void; 2usize],
    pub ulDummy18: [u32; 1usize],
    pub ucDummy19: [u8; 1usize],
    pub uxDummy20: u8,
    pub ucDummy21: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of xSTATIC_TCB"][::std::mem::size_of::<xSTATIC_TCB>() - 168usize];
    ["Alignment of xSTATIC_TCB"][::std::mem::align_of::<xSTATIC_TCB>() - 8usize];
    ["Offset of field: xSTATIC_TCB::pxDummy1"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy1) - 0usize];
    ["Offset of field: xSTATIC_TCB::xDummy3"]
        [::std::mem::offset_of!(xSTATIC_TCB, xDummy3) - 8usize];
    ["Offset of field: xSTATIC_TCB::uxDummy5"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy5) - 88usize];
    ["Offset of field: xSTATIC_TCB::pxDummy6"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy6) - 96usize];
    ["Offset of field: xSTATIC_TCB::ucDummy7"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy7) - 104usize];
    ["Offset of field: xSTATIC_TCB::xDummyCoreID"]
        [::std::mem::offset_of!(xSTATIC_TCB, xDummyCoreID) - 120usize];
    ["Offset of field: xSTATIC_TCB::pxDummy8"]
        [::std::mem::offset_of!(xSTATIC_TCB, pxDummy8) - 128usize];
    ["Offset of field: xSTATIC_TCB::uxDummy12"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy12) - 136usize];
    ["Offset of field: xSTATIC_TCB::pvDummy15"]
        [::std::mem::offset_of!(xSTATIC_TCB, pvDummy15) - 144usize];
    ["Offset of field: xSTATIC_TCB::ulDummy18"]
        [::std::mem::offset_of!(xSTATIC_TCB, ulDummy18) - 160usize];
    ["Offset of field: xSTATIC_TCB::ucDummy19"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy19) - 164usize];
    ["Offset of field: xSTATIC_TCB::uxDummy20"]
        [::std::mem::offset_of!(xSTATIC_TCB, uxDummy20) - 165usize];
    ["Offset of field: xSTATIC_TCB::ucDummy21"]
        [::std::mem::offset_of!(xSTATIC_TCB, ucDummy21) - 166usize];
};
pub type StaticTask_t = xSTATIC_TCB;
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate\n returns (via a pointer parameter) an TaskHandle_t variable that can then\n be used as a parameter to vTaskDelete to delete the task.\n\n \\ingroup Tasks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
#[doc = " Type by which event groups are referenced.  For example, a call to\n xEventGroupCreate() returns an EventGroupHandle_t variable that can then\n be used as a parameter to other event group functions.\n\n \\ingroup EventGroup"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventGroupDef_t {
    _unused: [u8; 0],
}
pub type EventGroupHandle_t = *mut EventGroupDef_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type pthread_mutex_t = __uint32_t;
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_task_attr_t {
    pub name: *const ::std::os::raw::c_char,
    pub priority: UBaseType_t,
    pub stack_depth: usize,
    pub static_allocation: bool,
    pub stack_buffer: *mut StackType_t,
    pub task_buffer: *mut StaticTask_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_task_attr_t"][::std::mem::size_of::<z_task_attr_t>() - 48usize];
    ["Alignment of z_task_attr_t"][::std::mem::align_of::<z_task_attr_t>() - 8usize];
    ["Offset of field: z_task_attr_t::name"][::std::mem::offset_of!(z_task_attr_t, name) - 0usize];
    ["Offset of field: z_task_attr_t::priority"]
        [::std::mem::offset_of!(z_task_attr_t, priority) - 8usize];
    ["Offset of field: z_task_attr_t::stack_depth"]
        [::std::mem::offset_of!(z_task_attr_t, stack_depth) - 16usize];
    ["Offset of field: z_task_attr_t::static_allocation"]
        [::std::mem::offset_of!(z_task_attr_t, static_allocation) - 24usize];
    ["Offset of field: z_task_attr_t::stack_buffer"]
        [::std::mem::offset_of!(z_task_attr_t, stack_buffer) - 32usize];
    ["Offset of field: z_task_attr_t::task_buffer"]
        [::std::mem::offset_of!(z_task_attr_t, task_buffer) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_task_t {
    pub handle: TaskHandle_t,
    pub join_event: EventGroupHandle_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_task_t"][::std::mem::size_of::<_z_task_t>() - 16usize];
    ["Alignment of _z_task_t"][::std::mem::align_of::<_z_task_t>() - 8usize];
    ["Offset of field: _z_task_t::handle"][::std::mem::offset_of!(_z_task_t, handle) - 0usize];
    ["Offset of field: _z_task_t::join_event"]
        [::std::mem::offset_of!(_z_task_t, join_event) - 8usize];
};
pub type _z_mutex_t = pthread_mutex_t;
pub type _z_mutex_rec_t = pthread_mutex_t;
pub type _z_condvar_t = pthread_cond_t;
pub type z_clock_t = timespec;
pub type z_time_t = timeval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_sys_net_socket_t {
    pub __bindgen_anon_1: _z_sys_net_socket_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_sys_net_socket_t__bindgen_ty_1 {
    pub _fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_socket_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_sys_net_socket_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _z_sys_net_socket_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_sys_net_socket_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _z_sys_net_socket_t__bindgen_ty_1::_fd"]
        [::std::mem::offset_of!(_z_sys_net_socket_t__bindgen_ty_1, _fd) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_socket_t"][::std::mem::size_of::<_z_sys_net_socket_t>() - 4usize];
    ["Alignment of _z_sys_net_socket_t"][::std::mem::align_of::<_z_sys_net_socket_t>() - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_sys_net_endpoint_t {
    pub __bindgen_anon_1: _z_sys_net_endpoint_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_sys_net_endpoint_t__bindgen_ty_1 {
    pub _iptcp: *mut addrinfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_endpoint_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_sys_net_endpoint_t__bindgen_ty_1>() - 8usize];
    ["Alignment of _z_sys_net_endpoint_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_sys_net_endpoint_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_sys_net_endpoint_t__bindgen_ty_1::_iptcp"]
        [::std::mem::offset_of!(_z_sys_net_endpoint_t__bindgen_ty_1, _iptcp) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_endpoint_t"][::std::mem::size_of::<_z_sys_net_endpoint_t>() - 8usize];
    ["Alignment of _z_sys_net_endpoint_t"]
        [::std::mem::align_of::<_z_sys_net_endpoint_t>() - 8usize];
};
unsafe extern "C" {
    #[doc = " Generates a random unsigned 8-bit integer."]
    pub fn z_random_u8() -> u8;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 16-bit integer."]
    pub fn z_random_u16() -> u16;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 32-bit integer."]
    pub fn z_random_u32() -> u32;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 64-bit integer."]
    pub fn z_random_u64() -> u64;
}
unsafe extern "C" {
    #[doc = " Fills buffer with random data.\n\n Parameters:\n   buf: Pointer to the buffer that will be filled with random data.\n   len: Number of bytes to fill in the buffer."]
    pub fn z_random_fill(buf: *mut ::std::os::raw::c_void, len: usize);
}
unsafe extern "C" {
    #[doc = " Allocates memory of the specified size.\n\n Parameters:\n   size: The number of bytes to allocate.\n\n Returns:\n   A pointer to the allocated memory, or NULL if the allocation fails."]
    pub fn z_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Reallocates the given memory block to a new size.\n\n Parameters:\n   ptr: Pointer to the previously allocated memory. Can be NULL, in which case it behaves like z_malloc().\n   size: The new size for the memory block in bytes.\n\n Returns:\n   A pointer to the reallocated memory, or NULL if the reallocation fails."]
    pub fn z_realloc(ptr: *mut ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Frees the memory previously allocated by z_malloc or z_realloc.\n\n Parameters:\n   ptr: Pointer to the memory to be freed. If NULL, no action is taken."]
    pub fn z_free(ptr: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_task_t {
    pub _val: _z_task_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_task_t"][::std::mem::size_of::<z_owned_task_t>() - 16usize];
    ["Alignment of z_owned_task_t"][::std::mem::align_of::<z_owned_task_t>() - 8usize];
    ["Offset of field: z_owned_task_t::_val"]
        [::std::mem::offset_of!(z_owned_task_t, _val) - 0usize];
};
pub type z_loaned_task_t = _z_task_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_task_t {
    pub _this: z_owned_task_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_task_t"][::std::mem::size_of::<z_moved_task_t>() - 16usize];
    ["Alignment of z_moved_task_t"][::std::mem::align_of::<z_moved_task_t>() - 8usize];
    ["Offset of field: z_moved_task_t::_this"]
        [::std::mem::offset_of!(z_moved_task_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_task_null(obj: *mut z_owned_task_t);
}
unsafe extern "C" {
    pub fn z_task_take(obj: *mut z_owned_task_t, src: *mut z_moved_task_t);
}
unsafe extern "C" {
    pub fn z_task_loan(obj: *const z_owned_task_t) -> *const z_loaned_task_t;
}
unsafe extern "C" {
    pub fn z_task_loan_mut(obj: *mut z_owned_task_t) -> *mut z_loaned_task_t;
}
unsafe extern "C" {
    pub fn z_task_move(obj: *mut z_owned_task_t) -> *mut z_moved_task_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new task.\n\n Parameters:\n   task: An uninitialized memory location where task will be constructed.\n   attr: Attributes of the task.\n   fun: Function to be executed by the task.\n   arg: Argument that will be passed to the function `fun`.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_init(
        task: *mut z_owned_task_t,
        attr: *mut z_task_attr_t,
        fun: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Joins the task and releases all allocated resources.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be joined.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_join(task: *mut z_moved_task_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Detaches the task and releases all allocated resources.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be detached.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_detach(task: *mut z_moved_task_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Drops the task. Same as :c:func:`z_task_detach`. Use :c:func:`z_task_join` to wait for the task completion.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be dropped.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_drop(task: *mut z_moved_task_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_mutex_t {
    pub _val: _z_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_mutex_t"][::std::mem::size_of::<z_owned_mutex_t>() - 4usize];
    ["Alignment of z_owned_mutex_t"][::std::mem::align_of::<z_owned_mutex_t>() - 4usize];
    ["Offset of field: z_owned_mutex_t::_val"]
        [::std::mem::offset_of!(z_owned_mutex_t, _val) - 0usize];
};
pub type z_loaned_mutex_t = _z_mutex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_mutex_t {
    pub _this: z_owned_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_mutex_t"][::std::mem::size_of::<z_moved_mutex_t>() - 4usize];
    ["Alignment of z_moved_mutex_t"][::std::mem::align_of::<z_moved_mutex_t>() - 4usize];
    ["Offset of field: z_moved_mutex_t::_this"]
        [::std::mem::offset_of!(z_moved_mutex_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_mutex_null(obj: *mut z_owned_mutex_t);
}
unsafe extern "C" {
    pub fn z_mutex_take(obj: *mut z_owned_mutex_t, src: *mut z_moved_mutex_t);
}
unsafe extern "C" {
    pub fn z_mutex_loan(obj: *const z_owned_mutex_t) -> *const z_loaned_mutex_t;
}
unsafe extern "C" {
    pub fn z_mutex_loan_mut(obj: *mut z_owned_mutex_t) -> *mut z_loaned_mutex_t;
}
unsafe extern "C" {
    pub fn z_mutex_move(obj: *mut z_owned_mutex_t) -> *mut z_moved_mutex_t;
}
unsafe extern "C" {
    #[doc = " Constructs a mutex.\n\n Parameters:\n   m: Pointer to an uninitialized :c:type:`z_owned_mutex_t` that will be constructed.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_init(m: *mut z_owned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Drops a mutex and resets it to its gravestone state.\n\n Parameters:\n   m: Pointer to a :c:type:`z_moved_mutex_t` that will be dropped.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_drop(m: *mut z_moved_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Locks a mutex. If the mutex is already locked, blocks the thread until it acquires the lock.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be locked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_lock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Tries to lock a mutex. If the mutex is already locked, the function returns immediately.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be locked if not already locked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_try_lock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Unlocks a previously locked mutex. If the mutex was not locked by the current thread, the behavior is undefined.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_unlock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_condvar_t {
    pub _val: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_condvar_t"][::std::mem::size_of::<z_owned_condvar_t>() - 4usize];
    ["Alignment of z_owned_condvar_t"][::std::mem::align_of::<z_owned_condvar_t>() - 4usize];
    ["Offset of field: z_owned_condvar_t::_val"]
        [::std::mem::offset_of!(z_owned_condvar_t, _val) - 0usize];
};
pub type z_loaned_condvar_t = _z_condvar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_condvar_t {
    pub _this: z_owned_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_condvar_t"][::std::mem::size_of::<z_moved_condvar_t>() - 4usize];
    ["Alignment of z_moved_condvar_t"][::std::mem::align_of::<z_moved_condvar_t>() - 4usize];
    ["Offset of field: z_moved_condvar_t::_this"]
        [::std::mem::offset_of!(z_moved_condvar_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_condvar_null(obj: *mut z_owned_condvar_t);
}
unsafe extern "C" {
    pub fn z_condvar_take(obj: *mut z_owned_condvar_t, src: *mut z_moved_condvar_t);
}
unsafe extern "C" {
    pub fn z_condvar_loan(obj: *const z_owned_condvar_t) -> *const z_loaned_condvar_t;
}
unsafe extern "C" {
    pub fn z_condvar_loan_mut(obj: *mut z_owned_condvar_t) -> *mut z_loaned_condvar_t;
}
unsafe extern "C" {
    pub fn z_condvar_move(obj: *mut z_owned_condvar_t) -> *mut z_moved_condvar_t;
}
unsafe extern "C" {
    #[doc = " Initializes a condition variable.\n\n Parameters:\n   cv: Pointer to an uninitialized :c:type:`z_owned_condvar_t` that will be initialized.\n\n Returns:\n   ``0`` if the initialization is successful, a negative value otherwise."]
    pub fn z_condvar_init(cv: *mut z_owned_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Destroys a condition variable and releases its resources.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_moved_condvar_t` that will be destroyed.\n\n Returns:\n   ``0`` if the destruction is successful, a negative value otherwise."]
    pub fn z_condvar_drop(cv: *mut z_moved_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Signals (wakes up) one thread waiting on the condition variable.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` that will be signaled.\n\n Returns:\n   ``0`` if the signal is successful, a negative value otherwise."]
    pub fn z_condvar_signal(cv: *mut z_loaned_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Waits for a signal on the condition variable while holding a mutex.\n\n The calling thread is blocked until the condition variable is signaled.\n The associated mutex must be locked by the calling thread, and it will be automatically unlocked while waiting.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` on which to wait.\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked during the wait.\n\n Returns:\n   ``0`` if the wait is successful, a negative value otherwise."]
    pub fn z_condvar_wait(cv: *mut z_loaned_condvar_t, m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Waits for a signal on the condition variable while holding a mutex until a specified time.\n\n The calling thread is blocked until the condition variable is signaled or the timeout occurs.\n The associated mutex must be locked by the calling thread, and it will be automatically unlocked while waiting.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` on which to wait.\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked during the wait.\n   abstime: Absolute end time.\n\n Returns:\n   ``0`` if the wait is successful, ``Z_ETIMEDOUT`` if a timeout occurred, other negative value otherwise."]
    pub fn z_condvar_wait_until(
        cv: *mut z_loaned_condvar_t,
        m: *mut z_loaned_mutex_t,
        abstime: *const z_clock_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in microseconds.\n\n Parameters:\n   time: The amount of time to sleep, in microseconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_us(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in milliseconds.\n\n Parameters:\n   time: The amount of time to sleep, in milliseconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_ms(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in seconds.\n\n Parameters:\n   time: The amount of time to sleep, in seconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_s(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns monotonic clock time point corresponding to the current time instant."]
    pub fn z_clock_now() -> z_clock_t;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in microseconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in microseconds."]
    pub fn z_clock_elapsed_us(time: *mut z_clock_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in milliseconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in milliseconds."]
    pub fn z_clock_elapsed_ms(time: *mut z_clock_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in seconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in seconds."]
    pub fn z_clock_elapsed_s(time: *mut z_clock_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in microseconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in microseconds."]
    pub fn z_clock_advance_us(clock: *mut z_clock_t, duration: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in milliseconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in milliseconds."]
    pub fn z_clock_advance_ms(clock: *mut z_clock_t, duration: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in seconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in seconds."]
    pub fn z_clock_advance_s(clock: *mut z_clock_t, duration: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    #[doc = " Returns system clock time point corresponding to the current time instant."]
    pub fn z_time_now() -> z_time_t;
}
unsafe extern "C" {
    #[doc = " Gets the current time as a string.\n\n Parameters:\n   buf: Pointer to a buffer where the time string will be written.\n   buflen: The length of the buffer.\n\n Returns:\n   A pointer to the buffer containing the time string."]
    pub fn z_time_now_as_str(
        buf: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_ulong,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in microseconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in microseconds."]
    pub fn z_time_elapsed_us(time: *mut z_time_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in milliseconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in milliseconds."]
    pub fn z_time_elapsed_ms(time: *mut z_time_t) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in seconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in seconds."]
    pub fn z_time_elapsed_s(time: *mut z_time_t) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_delete_context_t {
    pub deleter: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    pub context: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_delete_context_t"][::std::mem::size_of::<_z_delete_context_t>() - 16usize];
    ["Alignment of _z_delete_context_t"][::std::mem::align_of::<_z_delete_context_t>() - 8usize];
    ["Offset of field: _z_delete_context_t::deleter"]
        [::std::mem::offset_of!(_z_delete_context_t, deleter) - 0usize];
    ["Offset of field: _z_delete_context_t::context"]
        [::std::mem::offset_of!(_z_delete_context_t, context) - 8usize];
};
#[doc = " An array of bytes.\n\n Members:\n   size_t len: The length of the bytes array.\n   uint8_t *start: A pointer to the bytes array.\n   _z_delete_context_t delete_context - context used to delete the data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_slice_t {
    pub len: usize,
    pub start: *const u8,
    pub _delete_context: _z_delete_context_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_slice_t"][::std::mem::size_of::<_z_slice_t>() - 32usize];
    ["Alignment of _z_slice_t"][::std::mem::align_of::<_z_slice_t>() - 8usize];
    ["Offset of field: _z_slice_t::len"][::std::mem::offset_of!(_z_slice_t, len) - 0usize];
    ["Offset of field: _z_slice_t::start"][::std::mem::offset_of!(_z_slice_t, start) - 8usize];
    ["Offset of field: _z_slice_t::_delete_context"]
        [::std::mem::offset_of!(_z_slice_t, _delete_context) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_slice_simple_rc_t {
    pub _val: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_slice_simple_rc_t"][::std::mem::size_of::<_z_slice_simple_rc_t>() - 8usize];
    ["Alignment of _z_slice_simple_rc_t"][::std::mem::align_of::<_z_slice_simple_rc_t>() - 8usize];
    ["Offset of field: _z_slice_simple_rc_t::_val"]
        [::std::mem::offset_of!(_z_slice_simple_rc_t, _val) - 0usize];
};
#[doc = " An atomically reference counted subslice.\n\n Members:\n   _z_slice_simple_rc_t len: Rc counted slice.\n   size_t start: Offset to the subslice start.\n   size_t len: Length of the subslice."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_arc_slice_t {
    pub slice: _z_slice_simple_rc_t,
    pub start: usize,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_arc_slice_t"][::std::mem::size_of::<_z_arc_slice_t>() - 24usize];
    ["Alignment of _z_arc_slice_t"][::std::mem::align_of::<_z_arc_slice_t>() - 8usize];
    ["Offset of field: _z_arc_slice_t::slice"]
        [::std::mem::offset_of!(_z_arc_slice_t, slice) - 0usize];
    ["Offset of field: _z_arc_slice_t::start"]
        [::std::mem::offset_of!(_z_arc_slice_t, start) - 8usize];
    ["Offset of field: _z_arc_slice_t::len"][::std::mem::offset_of!(_z_arc_slice_t, len) - 16usize];
};
pub type z_element_eq_f = ::std::option::Option<
    unsafe extern "C" fn(
        left: *const ::std::os::raw::c_void,
        right: *const ::std::os::raw::c_void,
    ) -> bool,
>;
pub type z_element_hash_f =
    ::std::option::Option<unsafe extern "C" fn(e: *const ::std::os::raw::c_void) -> usize>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_svec_t {
    pub _capacity: usize,
    pub _len: usize,
    pub _val: *mut ::std::os::raw::c_void,
    pub _aliased: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_svec_t"][::std::mem::size_of::<_z_svec_t>() - 32usize];
    ["Alignment of _z_svec_t"][::std::mem::align_of::<_z_svec_t>() - 8usize];
    ["Offset of field: _z_svec_t::_capacity"]
        [::std::mem::offset_of!(_z_svec_t, _capacity) - 0usize];
    ["Offset of field: _z_svec_t::_len"][::std::mem::offset_of!(_z_svec_t, _len) - 8usize];
    ["Offset of field: _z_svec_t::_val"][::std::mem::offset_of!(_z_svec_t, _val) - 16usize];
    ["Offset of field: _z_svec_t::_aliased"][::std::mem::offset_of!(_z_svec_t, _aliased) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_iosli_t {
    pub _r_pos: usize,
    pub _w_pos: usize,
    pub _capacity: usize,
    pub _buf: *mut u8,
    pub _is_alloc: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_iosli_t"][::std::mem::size_of::<_z_iosli_t>() - 40usize];
    ["Alignment of _z_iosli_t"][::std::mem::align_of::<_z_iosli_t>() - 8usize];
    ["Offset of field: _z_iosli_t::_r_pos"][::std::mem::offset_of!(_z_iosli_t, _r_pos) - 0usize];
    ["Offset of field: _z_iosli_t::_w_pos"][::std::mem::offset_of!(_z_iosli_t, _w_pos) - 8usize];
    ["Offset of field: _z_iosli_t::_capacity"]
        [::std::mem::offset_of!(_z_iosli_t, _capacity) - 16usize];
    ["Offset of field: _z_iosli_t::_buf"][::std::mem::offset_of!(_z_iosli_t, _buf) - 24usize];
    ["Offset of field: _z_iosli_t::_is_alloc"]
        [::std::mem::offset_of!(_z_iosli_t, _is_alloc) - 32usize];
};
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_iosli_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_zbuf_t {
    pub _ios: _z_iosli_t,
    pub _slice: _z_slice_simple_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_zbuf_t"][::std::mem::size_of::<_z_zbuf_t>() - 48usize];
    ["Alignment of _z_zbuf_t"][::std::mem::align_of::<_z_zbuf_t>() - 8usize];
    ["Offset of field: _z_zbuf_t::_ios"][::std::mem::offset_of!(_z_zbuf_t, _ios) - 0usize];
    ["Offset of field: _z_zbuf_t::_slice"][::std::mem::offset_of!(_z_zbuf_t, _slice) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_wbuf_t {
    pub _ioss: _z_iosli_svec_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
    pub _expansion_step: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_wbuf_t"][::std::mem::size_of::<_z_wbuf_t>() - 56usize];
    ["Alignment of _z_wbuf_t"][::std::mem::align_of::<_z_wbuf_t>() - 8usize];
    ["Offset of field: _z_wbuf_t::_ioss"][::std::mem::offset_of!(_z_wbuf_t, _ioss) - 0usize];
    ["Offset of field: _z_wbuf_t::_r_idx"][::std::mem::offset_of!(_z_wbuf_t, _r_idx) - 32usize];
    ["Offset of field: _z_wbuf_t::_w_idx"][::std::mem::offset_of!(_z_wbuf_t, _w_idx) - 40usize];
    ["Offset of field: _z_wbuf_t::_expansion_step"]
        [::std::mem::offset_of!(_z_wbuf_t, _expansion_step) - 48usize];
};
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_arc_slice_svec_t = _z_svec_t;
#[doc = " A container for slices.\n\n Members:\n   _z_slice_vec_t _slices: contents of the container."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_t {
    pub _slices: _z_arc_slice_svec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_t"][::std::mem::size_of::<_z_bytes_t>() - 32usize];
    ["Alignment of _z_bytes_t"][::std::mem::align_of::<_z_bytes_t>() - 8usize];
    ["Offset of field: _z_bytes_t::_slices"][::std::mem::offset_of!(_z_bytes_t, _slices) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_reader_t {
    pub slice_idx: usize,
    pub in_slice_idx: usize,
    pub byte_idx: usize,
    pub bytes: *const _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_reader_t"][::std::mem::size_of::<_z_bytes_reader_t>() - 32usize];
    ["Alignment of _z_bytes_reader_t"][::std::mem::align_of::<_z_bytes_reader_t>() - 8usize];
    ["Offset of field: _z_bytes_reader_t::slice_idx"]
        [::std::mem::offset_of!(_z_bytes_reader_t, slice_idx) - 0usize];
    ["Offset of field: _z_bytes_reader_t::in_slice_idx"]
        [::std::mem::offset_of!(_z_bytes_reader_t, in_slice_idx) - 8usize];
    ["Offset of field: _z_bytes_reader_t::byte_idx"]
        [::std::mem::offset_of!(_z_bytes_reader_t, byte_idx) - 16usize];
    ["Offset of field: _z_bytes_reader_t::bytes"]
        [::std::mem::offset_of!(_z_bytes_reader_t, bytes) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_writer_t {
    pub cache: *mut _z_arc_slice_t,
    pub bytes: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_writer_t"][::std::mem::size_of::<_z_bytes_writer_t>() - 40usize];
    ["Alignment of _z_bytes_writer_t"][::std::mem::align_of::<_z_bytes_writer_t>() - 8usize];
    ["Offset of field: _z_bytes_writer_t::cache"]
        [::std::mem::offset_of!(_z_bytes_writer_t, cache) - 0usize];
    ["Offset of field: _z_bytes_writer_t::bytes"]
        [::std::mem::offset_of!(_z_bytes_writer_t, bytes) - 8usize];
};
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_l_t {
    pub _val: *mut ::std::os::raw::c_void,
    pub _next: *mut _z_l_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_l_t"][::std::mem::size_of::<_z_l_t>() - 16usize];
    ["Alignment of _z_l_t"][::std::mem::align_of::<_z_l_t>() - 8usize];
    ["Offset of field: _z_l_t::_val"][::std::mem::offset_of!(_z_l_t, _val) - 0usize];
    ["Offset of field: _z_l_t::_next"][::std::mem::offset_of!(_z_l_t, _next) - 8usize];
};
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_list_t = _z_l_t;
pub type _z_slist_t = ::std::os::raw::c_void;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_t {
    pub _capacity: usize,
    pub _vals: *mut *mut _z_list_t,
    pub _f_hash: z_element_hash_f,
    pub _f_equals: z_element_eq_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_t"][::std::mem::size_of::<_z_hashmap_t>() - 32usize];
    ["Alignment of _z_hashmap_t"][::std::mem::align_of::<_z_hashmap_t>() - 8usize];
    ["Offset of field: _z_hashmap_t::_capacity"]
        [::std::mem::offset_of!(_z_hashmap_t, _capacity) - 0usize];
    ["Offset of field: _z_hashmap_t::_vals"][::std::mem::offset_of!(_z_hashmap_t, _vals) - 8usize];
    ["Offset of field: _z_hashmap_t::_f_hash"]
        [::std::mem::offset_of!(_z_hashmap_t, _f_hash) - 16usize];
    ["Offset of field: _z_hashmap_t::_f_equals"]
        [::std::mem::offset_of!(_z_hashmap_t, _f_equals) - 24usize];
};
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_int_void_map_t = _z_hashmap_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_str_intmap_t = _z_int_void_map_t;
#[doc = " A string with no terminator.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_string_t {
    pub _slice: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_string_t"][::std::mem::size_of::<_z_string_t>() - 32usize];
    ["Alignment of _z_string_t"][::std::mem::align_of::<_z_string_t>() - 8usize];
    ["Offset of field: _z_string_t::_slice"][::std::mem::offset_of!(_z_string_t, _slice) - 0usize];
};
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_string_svec_t = _z_svec_t;
pub const z_what_t_Z_WHAT_ROUTER: z_what_t = 1;
pub const z_what_t_Z_WHAT_PEER: z_what_t = 2;
pub const z_what_t_Z_WHAT_CLIENT: z_what_t = 4;
pub const z_what_t_Z_WHAT_ROUTER_PEER: z_what_t = 3;
pub const z_what_t_Z_WHAT_ROUTER_CLIENT: z_what_t = 5;
pub const z_what_t_Z_WHAT_PEER_CLIENT: z_what_t = 6;
pub const z_what_t_Z_WHAT_ROUTER_PEER_CLIENT: z_what_t = 7;
#[doc = " What bitmask for scouting.\n\n Enumerators:\n   Z_WHAT_ROUTER: Router.\n   Z_WHAT_PEER: Peer.\n   Z_WHAT_CLIENT: Client."]
pub type z_what_t = ::std::os::raw::c_uint;
pub const z_whatami_t_Z_WHATAMI_ROUTER: z_whatami_t = 1;
pub const z_whatami_t_Z_WHATAMI_PEER: z_whatami_t = 2;
pub const z_whatami_t_Z_WHATAMI_CLIENT: z_whatami_t = 4;
#[doc = " Whatami values, defined as a bitmask.\n\n Enumerators:\n   Z_WHATAMI_ROUTER: Bitmask to filter Zenoh routers.\n   Z_WHATAMI_PEER: Bitmask to filter for Zenoh peers.\n   Z_WHATAMI_CLIENT: Bitmask to filter for Zenoh clients."]
pub type z_whatami_t = ::std::os::raw::c_uint;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_DISJOINT:
    z_keyexpr_intersection_level_t = 0;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_INTERSECTS:
    z_keyexpr_intersection_level_t = 1;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_INCLUDES:
    z_keyexpr_intersection_level_t = 2;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_EQUALS:
    z_keyexpr_intersection_level_t = 3;
#[doc = " Intersection level of two key expressions.\n\n Enumerators:\n   Z_KEYEXPR_INTERSECTION_LEVEL_DISJOINT: The two key expressions do not intersect.\n   Z_KEYEXPR_INTERSECTION_LEVEL_INTERSECTS: The two key expressions intersect, i.e. there exists at least one key\n     expression that is included by both.\n   Z_KEYEXPR_INTERSECTION_LEVEL_INCLUDES: The first key expression is the superset of the second one.\n   Z_KEYEXPR_INTERSECTION_LEVEL_EQUALS: The two key expressions are equal."]
pub type z_keyexpr_intersection_level_t = ::std::os::raw::c_uint;
pub const z_sample_kind_t_Z_SAMPLE_KIND_PUT: z_sample_kind_t = 0;
pub const z_sample_kind_t_Z_SAMPLE_KIND_DELETE: z_sample_kind_t = 1;
#[doc = " Sample kind values.\n\n Enumerators:\n   Z_SAMPLE_KIND_PUT: The Sample was issued by a ``put`` operation.\n   Z_SAMPLE_KIND_DELETE: The Sample was issued by a ``delete`` operation."]
pub type z_sample_kind_t = ::std::os::raw::c_uint;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_AUTO: z_consolidation_mode_t = -1;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_NONE: z_consolidation_mode_t = 0;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_MONOTONIC: z_consolidation_mode_t = 1;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_LATEST: z_consolidation_mode_t = 2;
#[doc = " Consolidation mode values.\n\n Enumerators:\n   Z_CONSOLIDATION_MODE_AUTO: Let Zenoh decide the best consolidation mode depending on the query selector.\n   Z_CONSOLIDATION_MODE_NONE: No consolidation is applied. Replies may come in any order and any number.\n   Z_CONSOLIDATION_MODE_MONOTONIC: It guarantees that any reply for a given key expression will be monotonic in time\n     w.r.t. the previous received replies for the same key expression. I.e., for the same key expression multiple\n     replies may be received. It is guaranteed that two replies received at t1 and t2 will have timestamp\n     ts2 > ts1. It optimizes latency.\n   Z_CONSOLIDATION_MODE_LATEST: It guarantees unicity of replies for the same key expression.\n     It optimizes bandwidth."]
pub type z_consolidation_mode_t = ::std::os::raw::c_int;
pub const z_reliability_t_Z_RELIABILITY_BEST_EFFORT: z_reliability_t = 1;
pub const z_reliability_t_Z_RELIABILITY_RELIABLE: z_reliability_t = 0;
#[doc = " Reliability values.\n\n Enumerators:\n   Z_RELIABILITY_BEST_EFFORT: Defines reliability as ``BEST_EFFORT``\n   Z_RELIABILITY_RELIABLE: Defines reliability as ``RELIABLE``\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
pub type z_reliability_t = ::std::os::raw::c_uint;
pub const z_congestion_control_t_Z_CONGESTION_CONTROL_BLOCK: z_congestion_control_t = 1;
pub const z_congestion_control_t_Z_CONGESTION_CONTROL_DROP: z_congestion_control_t = 0;
#[doc = " Congestion control values.\n\n Enumerators:\n   Z_CONGESTION_CONTROL_BLOCK: Defines congestion control as ``BLOCK``. Messages are not dropped in case of\n     congestion control.\n   Z_CONGESTION_CONTROL_DROP: Defines congestion control as ``DROP``. Messages are dropped in case\n     of congestion control."]
pub type z_congestion_control_t = ::std::os::raw::c_uint;
pub const z_priority_t__Z_PRIORITY_CONTROL: z_priority_t = 0;
pub const z_priority_t_Z_PRIORITY_REAL_TIME: z_priority_t = 1;
pub const z_priority_t_Z_PRIORITY_INTERACTIVE_HIGH: z_priority_t = 2;
pub const z_priority_t_Z_PRIORITY_INTERACTIVE_LOW: z_priority_t = 3;
pub const z_priority_t_Z_PRIORITY_DATA_HIGH: z_priority_t = 4;
pub const z_priority_t_Z_PRIORITY_DATA: z_priority_t = 5;
pub const z_priority_t_Z_PRIORITY_DATA_LOW: z_priority_t = 6;
pub const z_priority_t_Z_PRIORITY_BACKGROUND: z_priority_t = 7;
#[doc = " Priority of Zenoh messages values.\n\n Enumerators:\n   _Z_PRIORITY_CONTROL: Priority for ``Control`` messages.\n   Z_PRIORITY_REAL_TIME: Priority for ``RealTime`` messages.\n   Z_PRIORITY_INTERACTIVE_HIGH: Highest priority for ``Interactive`` messages.\n   Z_PRIORITY_INTERACTIVE_LOW: Lowest priority for ``Interactive`` messages.\n   Z_PRIORITY_DATA_HIGH: Highest priority for ``Data`` messages.\n   Z_PRIORITY_DATA: Default priority for ``Data`` messages.\n   Z_PRIORITY_DATA_LOW: Lowest priority for ``Data`` messages.\n   Z_PRIORITY_BACKGROUND: Priority for ``Background traffic`` messages."]
pub type z_priority_t = ::std::os::raw::c_uint;
pub const z_query_target_t_Z_QUERY_TARGET_BEST_MATCHING: z_query_target_t = 0;
pub const z_query_target_t_Z_QUERY_TARGET_ALL: z_query_target_t = 1;
pub const z_query_target_t_Z_QUERY_TARGET_ALL_COMPLETE: z_query_target_t = 2;
#[doc = " Query target values.\n\n Enumerators:\n   Z_QUERY_TARGET_BEST_MATCHING: The nearest complete queryable if any else all matching queryables.\n   Z_QUERY_TARGET_ALL: All matching queryables.\n   Z_QUERY_TARGET_ALL_COMPLETE: A set of complete queryables."]
pub type z_query_target_t = ::std::os::raw::c_uint;
#[doc = " A zenoh encoding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_encoding_t {
    pub schema: _z_string_t,
    pub id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_encoding_t"][::std::mem::size_of::<_z_encoding_t>() - 40usize];
    ["Alignment of _z_encoding_t"][::std::mem::align_of::<_z_encoding_t>() - 8usize];
    ["Offset of field: _z_encoding_t::schema"]
        [::std::mem::offset_of!(_z_encoding_t, schema) - 0usize];
    ["Offset of field: _z_encoding_t::id"][::std::mem::offset_of!(_z_encoding_t, id) - 32usize];
};
#[doc = " A variable-length encoding unsigned integer."]
pub type _z_zint_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_id_t {
    pub id: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_id_t"][::std::mem::size_of::<_z_id_t>() - 16usize];
    ["Alignment of _z_id_t"][::std::mem::align_of::<_z_id_t>() - 1usize];
    ["Offset of field: _z_id_t::id"][::std::mem::offset_of!(_z_id_t, id) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_entity_global_id_t {
    pub zid: _z_id_t,
    pub eid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_entity_global_id_t"][::std::mem::size_of::<_z_entity_global_id_t>() - 20usize];
    ["Alignment of _z_entity_global_id_t"]
        [::std::mem::align_of::<_z_entity_global_id_t>() - 4usize];
    ["Offset of field: _z_entity_global_id_t::zid"]
        [::std::mem::offset_of!(_z_entity_global_id_t, zid) - 0usize];
    ["Offset of field: _z_entity_global_id_t::eid"]
        [::std::mem::offset_of!(_z_entity_global_id_t, eid) - 16usize];
};
#[doc = " NTP64 time."]
pub type _z_ntp64_t = u64;
#[doc = " A zenoh timestamp."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_timestamp_t {
    pub valid: bool,
    pub id: _z_id_t,
    pub time: _z_ntp64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_timestamp_t"][::std::mem::size_of::<_z_timestamp_t>() - 32usize];
    ["Alignment of _z_timestamp_t"][::std::mem::align_of::<_z_timestamp_t>() - 8usize];
    ["Offset of field: _z_timestamp_t::valid"]
        [::std::mem::offset_of!(_z_timestamp_t, valid) - 0usize];
    ["Offset of field: _z_timestamp_t::id"][::std::mem::offset_of!(_z_timestamp_t, id) - 1usize];
    ["Offset of field: _z_timestamp_t::time"]
        [::std::mem::offset_of!(_z_timestamp_t, time) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_keyexpr_t {
    pub _id: u16,
    pub _mapping: usize,
    pub _suffix: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_keyexpr_t"][::std::mem::size_of::<_z_keyexpr_t>() - 48usize];
    ["Alignment of _z_keyexpr_t"][::std::mem::align_of::<_z_keyexpr_t>() - 8usize];
    ["Offset of field: _z_keyexpr_t::_id"][::std::mem::offset_of!(_z_keyexpr_t, _id) - 0usize];
    ["Offset of field: _z_keyexpr_t::_mapping"]
        [::std::mem::offset_of!(_z_keyexpr_t, _mapping) - 8usize];
    ["Offset of field: _z_keyexpr_t::_suffix"]
        [::std::mem::offset_of!(_z_keyexpr_t, _suffix) - 16usize];
};
#[doc = " QoS settings of zenoh message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_qos_t {
    pub _val: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_qos_t"][::std::mem::size_of::<_z_qos_t>() - 1usize];
    ["Alignment of _z_qos_t"][::std::mem::align_of::<_z_qos_t>() - 1usize];
    ["Offset of field: _z_qos_t::_val"][::std::mem::offset_of!(_z_qos_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh value.\n\n Members:\n   _z_bytes_t payload: The payload of this zenoh value.\n   _z_encoding_t encoding: The encoding of the `payload`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_value_t {
    pub payload: _z_bytes_t,
    pub encoding: _z_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_value_t"][::std::mem::size_of::<_z_value_t>() - 72usize];
    ["Alignment of _z_value_t"][::std::mem::align_of::<_z_value_t>() - 8usize];
    ["Offset of field: _z_value_t::payload"][::std::mem::offset_of!(_z_value_t, payload) - 0usize];
    ["Offset of field: _z_value_t::encoding"]
        [::std::mem::offset_of!(_z_value_t, encoding) - 32usize];
};
#[doc = " A hello message returned by a zenoh entity to a scout message sent with :c:func:`_z_scout`.\n\n Members:\n   _z_slice_t zid: The Zenoh ID of the scouted entity (empty if absent).\n   _z_string_vec_t locators: The locators of the scouted entity.\n   z_whatami_t whatami: The kind of zenoh entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hello_t {
    pub _zid: _z_id_t,
    pub _locators: _z_string_svec_t,
    pub _whatami: z_whatami_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hello_t"][::std::mem::size_of::<_z_hello_t>() - 56usize];
    ["Alignment of _z_hello_t"][::std::mem::align_of::<_z_hello_t>() - 8usize];
    ["Offset of field: _z_hello_t::_zid"][::std::mem::offset_of!(_z_hello_t, _zid) - 0usize];
    ["Offset of field: _z_hello_t::_locators"]
        [::std::mem::offset_of!(_z_hello_t, _locators) - 16usize];
    ["Offset of field: _z_hello_t::_whatami"]
        [::std::mem::offset_of!(_z_hello_t, _whatami) - 48usize];
    ["Offset of field: _z_hello_t::_version"]
        [::std::mem::offset_of!(_z_hello_t, _version) - 52usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_source_info_t {
    pub _source_id: _z_entity_global_id_t,
    pub _source_sn: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_source_info_t"][::std::mem::size_of::<_z_source_info_t>() - 24usize];
    ["Alignment of _z_source_info_t"][::std::mem::align_of::<_z_source_info_t>() - 4usize];
    ["Offset of field: _z_source_info_t::_source_id"]
        [::std::mem::offset_of!(_z_source_info_t, _source_id) - 0usize];
    ["Offset of field: _z_source_info_t::_source_sn"]
        [::std::mem::offset_of!(_z_source_info_t, _source_sn) - 20usize];
};
pub type _z_network_message_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_locator_t {
    pub _metadata: _z_str_intmap_t,
    pub _protocol: _z_string_t,
    pub _address: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_locator_t"][::std::mem::size_of::<_z_locator_t>() - 96usize];
    ["Alignment of _z_locator_t"][::std::mem::align_of::<_z_locator_t>() - 8usize];
    ["Offset of field: _z_locator_t::_metadata"]
        [::std::mem::offset_of!(_z_locator_t, _metadata) - 0usize];
    ["Offset of field: _z_locator_t::_protocol"]
        [::std::mem::offset_of!(_z_locator_t, _protocol) - 32usize];
    ["Offset of field: _z_locator_t::_address"]
        [::std::mem::offset_of!(_z_locator_t, _address) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_endpoint_t {
    pub _locator: _z_locator_t,
    pub _config: _z_str_intmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_endpoint_t"][::std::mem::size_of::<_z_endpoint_t>() - 128usize];
    ["Alignment of _z_endpoint_t"][::std::mem::align_of::<_z_endpoint_t>() - 8usize];
    ["Offset of field: _z_endpoint_t::_locator"]
        [::std::mem::offset_of!(_z_endpoint_t, _locator) - 0usize];
    ["Offset of field: _z_endpoint_t::_config"]
        [::std::mem::offset_of!(_z_endpoint_t, _config) - 96usize];
};
#[doc = " Zenoh-net properties are represented as int-string map."]
pub type _z_config_t = _z_str_intmap_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_tcp_socket_t {
    pub _sock: _z_sys_net_socket_t,
    pub _rep: _z_sys_net_endpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_tcp_socket_t"][::std::mem::size_of::<_z_tcp_socket_t>() - 16usize];
    ["Alignment of _z_tcp_socket_t"][::std::mem::align_of::<_z_tcp_socket_t>() - 8usize];
    ["Offset of field: _z_tcp_socket_t::_sock"]
        [::std::mem::offset_of!(_z_tcp_socket_t, _sock) - 0usize];
    ["Offset of field: _z_tcp_socket_t::_rep"]
        [::std::mem::offset_of!(_z_tcp_socket_t, _rep) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_udp_socket_t {
    pub _sock: _z_sys_net_socket_t,
    pub _msock: _z_sys_net_socket_t,
    pub _rep: _z_sys_net_endpoint_t,
    pub _lep: _z_sys_net_endpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_udp_socket_t"][::std::mem::size_of::<_z_udp_socket_t>() - 24usize];
    ["Alignment of _z_udp_socket_t"][::std::mem::align_of::<_z_udp_socket_t>() - 8usize];
    ["Offset of field: _z_udp_socket_t::_sock"]
        [::std::mem::offset_of!(_z_udp_socket_t, _sock) - 0usize];
    ["Offset of field: _z_udp_socket_t::_msock"]
        [::std::mem::offset_of!(_z_udp_socket_t, _msock) - 4usize];
    ["Offset of field: _z_udp_socket_t::_rep"]
        [::std::mem::offset_of!(_z_udp_socket_t, _rep) - 8usize];
    ["Offset of field: _z_udp_socket_t::_lep"]
        [::std::mem::offset_of!(_z_udp_socket_t, _lep) - 16usize];
};
#[doc = " Link capabilities, stored as a register-like object.\n\n Fields:\n     transport: 2 bits, see _z_link_cap_transport_t enum.\n     flow: 1 bit, see _z_link_cap_flow_t enum.\n     reliable: 1 bit, 1 if the link is reliable (network definition)\n     reserved: 4 bits, reserved for future use"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_link_capabilities_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_capabilities_t"][::std::mem::size_of::<_z_link_capabilities_t>() - 1usize];
    ["Alignment of _z_link_capabilities_t"]
        [::std::mem::align_of::<_z_link_capabilities_t>() - 1usize];
};
impl _z_link_capabilities_t {
    #[inline]
    pub fn _transport(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set__transport(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _transport_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__transport_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _flow(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__flow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flow_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__flow_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _is_reliable(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__is_reliable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _is_reliable_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__is_reliable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _reserved_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__reserved_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _transport: u8,
        _flow: u8,
        _is_reliable: u8,
        _reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let _transport: u8 = unsafe { ::std::mem::transmute(_transport) };
            _transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _flow: u8 = unsafe { ::std::mem::transmute(_flow) };
            _flow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _is_reliable: u8 = unsafe { ::std::mem::transmute(_is_reliable) };
            _is_reliable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _reserved: u8 = unsafe { ::std::mem::transmute(_reserved) };
            _reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type _z_f_link_open =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t) -> z_result_t>;
pub type _z_f_link_listen =
    ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t) -> z_result_t>;
pub type _z_f_link_close = ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t)>;
pub type _z_f_link_write = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *const u8,
        len: usize,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize,
>;
pub type _z_f_link_write_all = ::std::option::Option<
    unsafe extern "C" fn(self_: *const _z_link_t, ptr: *const u8, len: usize) -> usize,
>;
pub type _z_f_link_read = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *mut u8,
        len: usize,
        addr: *mut _z_slice_t,
    ) -> usize,
>;
pub type _z_f_link_read_exact = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *mut u8,
        len: usize,
        addr: *mut _z_slice_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize,
>;
pub type _z_f_link_read_socket = ::std::option::Option<
    unsafe extern "C" fn(socket: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize,
>;
pub type _z_f_link_free = ::std::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_link_t {
    pub _endpoint: _z_endpoint_t,
    pub _type: ::std::os::raw::c_int,
    pub _socket: _z_link_t__bindgen_ty_1,
    pub _open_f: _z_f_link_open,
    pub _listen_f: _z_f_link_listen,
    pub _close_f: _z_f_link_close,
    pub _write_f: _z_f_link_write,
    pub _write_all_f: _z_f_link_write_all,
    pub _read_f: _z_f_link_read,
    pub _read_exact_f: _z_f_link_read_exact,
    pub _read_socket_f: _z_f_link_read_socket,
    pub _free_f: _z_f_link_free,
    pub _mtu: u16,
    pub _cap: _z_link_capabilities_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_link_t__bindgen_ty_1 {
    pub _tcp: _z_tcp_socket_t,
    pub _udp: _z_udp_socket_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_t__bindgen_ty_1"][::std::mem::size_of::<_z_link_t__bindgen_ty_1>() - 24usize];
    ["Alignment of _z_link_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_link_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_link_t__bindgen_ty_1::_tcp"]
        [::std::mem::offset_of!(_z_link_t__bindgen_ty_1, _tcp) - 0usize];
    ["Offset of field: _z_link_t__bindgen_ty_1::_udp"]
        [::std::mem::offset_of!(_z_link_t__bindgen_ty_1, _udp) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_t"][::std::mem::size_of::<_z_link_t>() - 240usize];
    ["Alignment of _z_link_t"][::std::mem::align_of::<_z_link_t>() - 8usize];
    ["Offset of field: _z_link_t::_endpoint"]
        [::std::mem::offset_of!(_z_link_t, _endpoint) - 0usize];
    ["Offset of field: _z_link_t::_type"][::std::mem::offset_of!(_z_link_t, _type) - 128usize];
    ["Offset of field: _z_link_t::_socket"][::std::mem::offset_of!(_z_link_t, _socket) - 136usize];
    ["Offset of field: _z_link_t::_open_f"][::std::mem::offset_of!(_z_link_t, _open_f) - 160usize];
    ["Offset of field: _z_link_t::_listen_f"]
        [::std::mem::offset_of!(_z_link_t, _listen_f) - 168usize];
    ["Offset of field: _z_link_t::_close_f"]
        [::std::mem::offset_of!(_z_link_t, _close_f) - 176usize];
    ["Offset of field: _z_link_t::_write_f"]
        [::std::mem::offset_of!(_z_link_t, _write_f) - 184usize];
    ["Offset of field: _z_link_t::_write_all_f"]
        [::std::mem::offset_of!(_z_link_t, _write_all_f) - 192usize];
    ["Offset of field: _z_link_t::_read_f"][::std::mem::offset_of!(_z_link_t, _read_f) - 200usize];
    ["Offset of field: _z_link_t::_read_exact_f"]
        [::std::mem::offset_of!(_z_link_t, _read_exact_f) - 208usize];
    ["Offset of field: _z_link_t::_read_socket_f"]
        [::std::mem::offset_of!(_z_link_t, _read_socket_f) - 216usize];
    ["Offset of field: _z_link_t::_free_f"][::std::mem::offset_of!(_z_link_t, _free_f) - 224usize];
    ["Offset of field: _z_link_t::_mtu"][::std::mem::offset_of!(_z_link_t, _mtu) - 232usize];
    ["Offset of field: _z_link_t::_cap"][::std::mem::offset_of!(_z_link_t, _cap) - 234usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_coundit_sn_t {
    pub _reliable: _z_zint_t,
    pub _best_effort: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_coundit_sn_t"][::std::mem::size_of::<_z_coundit_sn_t>() - 16usize];
    ["Alignment of _z_coundit_sn_t"][::std::mem::align_of::<_z_coundit_sn_t>() - 8usize];
    ["Offset of field: _z_coundit_sn_t::_reliable"]
        [::std::mem::offset_of!(_z_coundit_sn_t, _reliable) - 0usize];
    ["Offset of field: _z_coundit_sn_t::_best_effort"]
        [::std::mem::offset_of!(_z_coundit_sn_t, _best_effort) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_conduit_sn_list_t {
    pub _val: _z_conduit_sn_list_t__bindgen_ty_1,
    pub _is_qos: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_conduit_sn_list_t__bindgen_ty_1 {
    pub _plain: _z_coundit_sn_t,
    pub _qos: [_z_coundit_sn_t; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_conduit_sn_list_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_conduit_sn_list_t__bindgen_ty_1>() - 128usize];
    ["Alignment of _z_conduit_sn_list_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_conduit_sn_list_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_conduit_sn_list_t__bindgen_ty_1::_plain"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t__bindgen_ty_1, _plain) - 0usize];
    ["Offset of field: _z_conduit_sn_list_t__bindgen_ty_1::_qos"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t__bindgen_ty_1, _qos) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_conduit_sn_list_t"][::std::mem::size_of::<_z_conduit_sn_list_t>() - 136usize];
    ["Alignment of _z_conduit_sn_list_t"][::std::mem::align_of::<_z_conduit_sn_list_t>() - 8usize];
    ["Offset of field: _z_conduit_sn_list_t::_val"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t, _val) - 0usize];
    ["Offset of field: _z_conduit_sn_list_t::_is_qos"]
        [::std::mem::offset_of!(_z_conduit_sn_list_t, _is_qos) - 128usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_t_msg_join_t {
    pub _zid: _z_id_t,
    pub _lease: _z_zint_t,
    pub _next_sn: _z_conduit_sn_list_t,
    pub _batch_size: u16,
    pub _whatami: z_whatami_t,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _version: u8,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_join_t"][::std::mem::size_of::<_z_t_msg_join_t>() - 176usize];
    ["Alignment of _z_t_msg_join_t"][::std::mem::align_of::<_z_t_msg_join_t>() - 8usize];
    ["Offset of field: _z_t_msg_join_t::_zid"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _zid) - 0usize];
    ["Offset of field: _z_t_msg_join_t::_lease"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _lease) - 16usize];
    ["Offset of field: _z_t_msg_join_t::_next_sn"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _next_sn) - 24usize];
    ["Offset of field: _z_t_msg_join_t::_batch_size"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _batch_size) - 160usize];
    ["Offset of field: _z_t_msg_join_t::_whatami"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _whatami) - 164usize];
    ["Offset of field: _z_t_msg_join_t::_req_id_res"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _req_id_res) - 168usize];
    ["Offset of field: _z_t_msg_join_t::_seq_num_res"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _seq_num_res) - 169usize];
    ["Offset of field: _z_t_msg_join_t::_version"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _version) - 170usize];
    ["Offset of field: _z_t_msg_join_t::_patch"]
        [::std::mem::offset_of!(_z_t_msg_join_t, _patch) - 171usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_init_t {
    pub _zid: _z_id_t,
    pub _cookie: _z_slice_t,
    pub _batch_size: u16,
    pub _whatami: z_whatami_t,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _version: u8,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_init_t"][::std::mem::size_of::<_z_t_msg_init_t>() - 64usize];
    ["Alignment of _z_t_msg_init_t"][::std::mem::align_of::<_z_t_msg_init_t>() - 8usize];
    ["Offset of field: _z_t_msg_init_t::_zid"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _zid) - 0usize];
    ["Offset of field: _z_t_msg_init_t::_cookie"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _cookie) - 16usize];
    ["Offset of field: _z_t_msg_init_t::_batch_size"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _batch_size) - 48usize];
    ["Offset of field: _z_t_msg_init_t::_whatami"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _whatami) - 52usize];
    ["Offset of field: _z_t_msg_init_t::_req_id_res"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _req_id_res) - 56usize];
    ["Offset of field: _z_t_msg_init_t::_seq_num_res"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _seq_num_res) - 57usize];
    ["Offset of field: _z_t_msg_init_t::_version"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _version) - 58usize];
    ["Offset of field: _z_t_msg_init_t::_patch"]
        [::std::mem::offset_of!(_z_t_msg_init_t, _patch) - 59usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_open_t {
    pub _lease: _z_zint_t,
    pub _initial_sn: _z_zint_t,
    pub _cookie: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_open_t"][::std::mem::size_of::<_z_t_msg_open_t>() - 48usize];
    ["Alignment of _z_t_msg_open_t"][::std::mem::align_of::<_z_t_msg_open_t>() - 8usize];
    ["Offset of field: _z_t_msg_open_t::_lease"]
        [::std::mem::offset_of!(_z_t_msg_open_t, _lease) - 0usize];
    ["Offset of field: _z_t_msg_open_t::_initial_sn"]
        [::std::mem::offset_of!(_z_t_msg_open_t, _initial_sn) - 8usize];
    ["Offset of field: _z_t_msg_open_t::_cookie"]
        [::std::mem::offset_of!(_z_t_msg_open_t, _cookie) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_close_t {
    pub _reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_close_t"][::std::mem::size_of::<_z_t_msg_close_t>() - 1usize];
    ["Alignment of _z_t_msg_close_t"][::std::mem::align_of::<_z_t_msg_close_t>() - 1usize];
    ["Offset of field: _z_t_msg_close_t::_reason"]
        [::std::mem::offset_of!(_z_t_msg_close_t, _reason) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_keep_alive_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_keep_alive_t"][::std::mem::size_of::<_z_t_msg_keep_alive_t>() - 1usize];
    ["Alignment of _z_t_msg_keep_alive_t"]
        [::std::mem::align_of::<_z_t_msg_keep_alive_t>() - 1usize];
    ["Offset of field: _z_t_msg_keep_alive_t::__dummy"]
        [::std::mem::offset_of!(_z_t_msg_keep_alive_t, __dummy) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_frame_t {
    pub _payload: *mut _z_zbuf_t,
    pub _sn: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_frame_t"][::std::mem::size_of::<_z_t_msg_frame_t>() - 16usize];
    ["Alignment of _z_t_msg_frame_t"][::std::mem::align_of::<_z_t_msg_frame_t>() - 8usize];
    ["Offset of field: _z_t_msg_frame_t::_payload"]
        [::std::mem::offset_of!(_z_t_msg_frame_t, _payload) - 0usize];
    ["Offset of field: _z_t_msg_frame_t::_sn"]
        [::std::mem::offset_of!(_z_t_msg_frame_t, _sn) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_fragment_t {
    pub _payload: _z_slice_t,
    pub _sn: _z_zint_t,
    pub first: bool,
    pub drop: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_fragment_t"][::std::mem::size_of::<_z_t_msg_fragment_t>() - 48usize];
    ["Alignment of _z_t_msg_fragment_t"][::std::mem::align_of::<_z_t_msg_fragment_t>() - 8usize];
    ["Offset of field: _z_t_msg_fragment_t::_payload"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, _payload) - 0usize];
    ["Offset of field: _z_t_msg_fragment_t::_sn"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, _sn) - 32usize];
    ["Offset of field: _z_t_msg_fragment_t::first"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, first) - 40usize];
    ["Offset of field: _z_t_msg_fragment_t::drop"]
        [::std::mem::offset_of!(_z_t_msg_fragment_t, drop) - 41usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_transport_body_t {
    pub _join: _z_t_msg_join_t,
    pub _init: _z_t_msg_init_t,
    pub _open: _z_t_msg_open_t,
    pub _close: _z_t_msg_close_t,
    pub _keep_alive: _z_t_msg_keep_alive_t,
    pub _frame: _z_t_msg_frame_t,
    pub _fragment: _z_t_msg_fragment_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_body_t"][::std::mem::size_of::<_z_transport_body_t>() - 176usize];
    ["Alignment of _z_transport_body_t"][::std::mem::align_of::<_z_transport_body_t>() - 8usize];
    ["Offset of field: _z_transport_body_t::_join"]
        [::std::mem::offset_of!(_z_transport_body_t, _join) - 0usize];
    ["Offset of field: _z_transport_body_t::_init"]
        [::std::mem::offset_of!(_z_transport_body_t, _init) - 0usize];
    ["Offset of field: _z_transport_body_t::_open"]
        [::std::mem::offset_of!(_z_transport_body_t, _open) - 0usize];
    ["Offset of field: _z_transport_body_t::_close"]
        [::std::mem::offset_of!(_z_transport_body_t, _close) - 0usize];
    ["Offset of field: _z_transport_body_t::_keep_alive"]
        [::std::mem::offset_of!(_z_transport_body_t, _keep_alive) - 0usize];
    ["Offset of field: _z_transport_body_t::_frame"]
        [::std::mem::offset_of!(_z_transport_body_t, _frame) - 0usize];
    ["Offset of field: _z_transport_body_t::_fragment"]
        [::std::mem::offset_of!(_z_transport_body_t, _fragment) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_message_t {
    pub _body: _z_transport_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_message_t"][::std::mem::size_of::<_z_transport_message_t>() - 184usize];
    ["Alignment of _z_transport_message_t"]
        [::std::mem::align_of::<_z_transport_message_t>() - 8usize];
    ["Offset of field: _z_transport_message_t::_body"]
        [::std::mem::offset_of!(_z_transport_message_t, _body) - 0usize];
    ["Offset of field: _z_transport_message_t::_header"]
        [::std::mem::offset_of!(_z_transport_message_t, _header) - 176usize];
};
pub type _z_resource_slist_t = _z_slist_t;
pub type _z_transport_peer_multicast_slist_t = _z_slist_t;
pub type _z_transport_peer_unicast_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_rc_t {
    pub _val: *mut _z_session_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_rc_t"][::std::mem::size_of::<_z_session_rc_t>() - 16usize];
    ["Alignment of _z_session_rc_t"][::std::mem::align_of::<_z_session_rc_t>() - 8usize];
    ["Offset of field: _z_session_rc_t::_val"]
        [::std::mem::offset_of!(_z_session_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_rc_t::_cnt"]
        [::std::mem::offset_of!(_z_session_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_weak_t {
    pub _val: *mut _z_session_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_weak_t"][::std::mem::size_of::<_z_session_weak_t>() - 16usize];
    ["Alignment of _z_session_weak_t"][::std::mem::align_of::<_z_session_weak_t>() - 8usize];
    ["Offset of field: _z_session_weak_t::_val"]
        [::std::mem::offset_of!(_z_session_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_weak_t::_cnt"]
        [::std::mem::offset_of!(_z_session_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_common_t {
    pub _session: _z_session_weak_t,
    pub _link: *mut _z_link_t,
    pub _wbuf: _z_wbuf_t,
    pub _zbuf: _z_zbuf_t,
    pub _sn_res: _z_zint_t,
    pub _sn_tx_reliable: _z_zint_t,
    pub _sn_tx_best_effort: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _transmitted: bool,
    pub _mutex_rx: _z_mutex_t,
    pub _mutex_tx: _z_mutex_t,
    pub _mutex_peer: _z_mutex_rec_t,
    pub _read_task: *mut _z_task_t,
    pub _lease_task: *mut _z_task_t,
    pub _accept_task_running: *mut bool,
    pub _read_task_running: bool,
    pub _lease_task_running: bool,
    pub _batch_state: u8,
    pub _batch_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_common_t"][::std::mem::size_of::<_z_transport_common_t>() - 216usize];
    ["Alignment of _z_transport_common_t"]
        [::std::mem::align_of::<_z_transport_common_t>() - 8usize];
    ["Offset of field: _z_transport_common_t::_session"]
        [::std::mem::offset_of!(_z_transport_common_t, _session) - 0usize];
    ["Offset of field: _z_transport_common_t::_link"]
        [::std::mem::offset_of!(_z_transport_common_t, _link) - 16usize];
    ["Offset of field: _z_transport_common_t::_wbuf"]
        [::std::mem::offset_of!(_z_transport_common_t, _wbuf) - 24usize];
    ["Offset of field: _z_transport_common_t::_zbuf"]
        [::std::mem::offset_of!(_z_transport_common_t, _zbuf) - 80usize];
    ["Offset of field: _z_transport_common_t::_sn_res"]
        [::std::mem::offset_of!(_z_transport_common_t, _sn_res) - 128usize];
    ["Offset of field: _z_transport_common_t::_sn_tx_reliable"]
        [::std::mem::offset_of!(_z_transport_common_t, _sn_tx_reliable) - 136usize];
    ["Offset of field: _z_transport_common_t::_sn_tx_best_effort"]
        [::std::mem::offset_of!(_z_transport_common_t, _sn_tx_best_effort) - 144usize];
    ["Offset of field: _z_transport_common_t::_lease"]
        [::std::mem::offset_of!(_z_transport_common_t, _lease) - 152usize];
    ["Offset of field: _z_transport_common_t::_transmitted"]
        [::std::mem::offset_of!(_z_transport_common_t, _transmitted) - 160usize];
    ["Offset of field: _z_transport_common_t::_mutex_rx"]
        [::std::mem::offset_of!(_z_transport_common_t, _mutex_rx) - 164usize];
    ["Offset of field: _z_transport_common_t::_mutex_tx"]
        [::std::mem::offset_of!(_z_transport_common_t, _mutex_tx) - 168usize];
    ["Offset of field: _z_transport_common_t::_mutex_peer"]
        [::std::mem::offset_of!(_z_transport_common_t, _mutex_peer) - 172usize];
    ["Offset of field: _z_transport_common_t::_read_task"]
        [::std::mem::offset_of!(_z_transport_common_t, _read_task) - 176usize];
    ["Offset of field: _z_transport_common_t::_lease_task"]
        [::std::mem::offset_of!(_z_transport_common_t, _lease_task) - 184usize];
    ["Offset of field: _z_transport_common_t::_accept_task_running"]
        [::std::mem::offset_of!(_z_transport_common_t, _accept_task_running) - 192usize];
    ["Offset of field: _z_transport_common_t::_read_task_running"]
        [::std::mem::offset_of!(_z_transport_common_t, _read_task_running) - 200usize];
    ["Offset of field: _z_transport_common_t::_lease_task_running"]
        [::std::mem::offset_of!(_z_transport_common_t, _lease_task_running) - 201usize];
    ["Offset of field: _z_transport_common_t::_batch_state"]
        [::std::mem::offset_of!(_z_transport_common_t, _batch_state) - 202usize];
    ["Offset of field: _z_transport_common_t::_batch_count"]
        [::std::mem::offset_of!(_z_transport_common_t, _batch_count) - 208usize];
};
pub type _zp_f_send_tmsg = ::std::option::Option<
    unsafe extern "C" fn(
        self_: *mut _z_transport_common_t,
        t_msg: *const _z_transport_message_t,
    ) -> z_result_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_unicast_t {
    pub _common: _z_transport_common_t,
    pub _peers: *mut _z_transport_peer_unicast_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_unicast_t"][::std::mem::size_of::<_z_transport_unicast_t>() - 224usize];
    ["Alignment of _z_transport_unicast_t"]
        [::std::mem::align_of::<_z_transport_unicast_t>() - 8usize];
    ["Offset of field: _z_transport_unicast_t::_common"]
        [::std::mem::offset_of!(_z_transport_unicast_t, _common) - 0usize];
    ["Offset of field: _z_transport_unicast_t::_peers"]
        [::std::mem::offset_of!(_z_transport_unicast_t, _peers) - 216usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_multicast_t {
    pub _common: _z_transport_common_t,
    pub _peers: *mut _z_transport_peer_multicast_slist_t,
    pub _send_f: _zp_f_send_tmsg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_multicast_t"]
        [::std::mem::size_of::<_z_transport_multicast_t>() - 232usize];
    ["Alignment of _z_transport_multicast_t"]
        [::std::mem::align_of::<_z_transport_multicast_t>() - 8usize];
    ["Offset of field: _z_transport_multicast_t::_common"]
        [::std::mem::offset_of!(_z_transport_multicast_t, _common) - 0usize];
    ["Offset of field: _z_transport_multicast_t::_peers"]
        [::std::mem::offset_of!(_z_transport_multicast_t, _peers) - 216usize];
    ["Offset of field: _z_transport_multicast_t::_send_f"]
        [::std::mem::offset_of!(_z_transport_multicast_t, _send_f) - 224usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_t {
    pub _transport: _z_transport_t__bindgen_ty_1,
    pub _type: _z_transport_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_transport_t__bindgen_ty_1 {
    pub _unicast: _z_transport_unicast_t,
    pub _multicast: _z_transport_multicast_t,
    pub _raweth: _z_transport_multicast_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_transport_t__bindgen_ty_1>() - 232usize];
    ["Alignment of _z_transport_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_transport_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_unicast"]
        [::std::mem::offset_of!(_z_transport_t__bindgen_ty_1, _unicast) - 0usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_multicast"]
        [::std::mem::offset_of!(_z_transport_t__bindgen_ty_1, _multicast) - 0usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_raweth"]
        [::std::mem::offset_of!(_z_transport_t__bindgen_ty_1, _raweth) - 0usize];
};
pub const _z_transport_t__Z_TRANSPORT_UNICAST_TYPE: _z_transport_t__bindgen_ty_2 = 0;
pub const _z_transport_t__Z_TRANSPORT_MULTICAST_TYPE: _z_transport_t__bindgen_ty_2 = 1;
pub const _z_transport_t__Z_TRANSPORT_RAWETH_TYPE: _z_transport_t__bindgen_ty_2 = 2;
pub const _z_transport_t__Z_TRANSPORT_NONE: _z_transport_t__bindgen_ty_2 = 3;
pub type _z_transport_t__bindgen_ty_2 = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_t"][::std::mem::size_of::<_z_transport_t>() - 240usize];
    ["Alignment of _z_transport_t"][::std::mem::align_of::<_z_transport_t>() - 8usize];
    ["Offset of field: _z_transport_t::_transport"]
        [::std::mem::offset_of!(_z_transport_t, _transport) - 0usize];
    ["Offset of field: _z_transport_t::_type"]
        [::std::mem::offset_of!(_z_transport_t, _type) - 232usize];
};
#[doc = " The callback signature of the cleanup functions."]
pub type _z_drop_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_keyexpr_intmap_t = _z_int_void_map_t;
#[doc = " The callback signature of the functions handling data messages."]
pub type _z_closure_sample_callback_t = ::std::option::Option<
    unsafe extern "C" fn(sample: *mut _z_sample_t, arg: *mut ::std::os::raw::c_void),
>;
pub type _z_subscription_rc_slist_t = _z_slist_t;
#[doc = " The callback signature of the functions handling query messages."]
pub type _z_closure_query_callback_t = ::std::option::Option<
    unsafe extern "C" fn(query: *mut _z_query_rc_t, arg: *mut ::std::os::raw::c_void),
>;
pub type _z_session_queryable_rc_slist_t = _z_slist_t;
#[doc = " The callback signature of the functions handling query replies."]
pub type _z_closure_reply_callback_t = ::std::option::Option<
    unsafe extern "C" fn(reply: *mut _z_reply_t, arg: *mut ::std::os::raw::c_void),
>;
pub type _z_pending_query_slist_t = _z_slist_t;
pub type _z_session_interest_rc_slist_t = _z_slist_t;
pub type _z_declare_data_slist_t = _z_slist_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_liveliness_pending_query_intmap_t = _z_int_void_map_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_status_t {
    pub matching: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_status_t"][::std::mem::size_of::<_z_matching_status_t>() - 1usize];
    ["Alignment of _z_matching_status_t"][::std::mem::align_of::<_z_matching_status_t>() - 1usize];
    ["Offset of field: _z_matching_status_t::matching"]
        [::std::mem::offset_of!(_z_matching_status_t, matching) - 0usize];
};
pub type _z_closure_matching_status_callback_t = ::std::option::Option<
    unsafe extern "C" fn(status: *const _z_matching_status_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_matching_status_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: _z_closure_matching_status_callback_t,
    pub drop: _z_drop_handler_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_matching_status_t"]
        [::std::mem::size_of::<_z_closure_matching_status_t>() - 24usize];
    ["Alignment of _z_closure_matching_status_t"]
        [::std::mem::align_of::<_z_closure_matching_status_t>() - 8usize];
    ["Offset of field: _z_closure_matching_status_t::context"]
        [::std::mem::offset_of!(_z_closure_matching_status_t, context) - 0usize];
    ["Offset of field: _z_closure_matching_status_t::call"]
        [::std::mem::offset_of!(_z_closure_matching_status_t, call) - 8usize];
    ["Offset of field: _z_closure_matching_status_t::drop"]
        [::std::mem::offset_of!(_z_closure_matching_status_t, drop) - 16usize];
};
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_matching_listener_intmap_t = _z_int_void_map_t;
#[doc = " A zenoh-net session."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_session_t {
    pub _mutex_inner_initialized: bool,
    pub _mutex_inner: _z_mutex_t,
    pub _mode: z_whatami_t,
    pub _tp: _z_transport_t,
    pub _local_zid: _z_id_t,
    pub _resource_id: u16,
    pub _entity_id: u32,
    pub _query_id: _z_zint_t,
    pub _interest_id: _z_zint_t,
    pub _local_resources: *mut _z_resource_slist_t,
    pub _config: _z_config_t,
    pub _declaration_cache: *mut _z_network_message_slist_t,
    pub _lease_task_attr: *mut z_task_attr_t,
    pub _read_task_attr: *mut z_task_attr_t,
    pub _subscriptions: *mut _z_subscription_rc_slist_t,
    pub _liveliness_subscriptions: *mut _z_subscription_rc_slist_t,
    pub _local_tokens: _z_keyexpr_intmap_t,
    pub _remote_tokens: _z_keyexpr_intmap_t,
    pub _liveliness_query_id: u32,
    pub _liveliness_pending_queries: _z_liveliness_pending_query_intmap_t,
    pub _local_queryable: *mut _z_session_queryable_rc_slist_t,
    pub _pending_queries: *mut _z_pending_query_slist_t,
    pub _matching_listeners: _z_matching_listener_intmap_t,
    pub _local_interests: *mut _z_session_interest_rc_slist_t,
    pub _remote_declares: *mut _z_declare_data_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_t"][::std::mem::size_of::<_z_session_t>() - 544usize];
    ["Alignment of _z_session_t"][::std::mem::align_of::<_z_session_t>() - 8usize];
    ["Offset of field: _z_session_t::_mutex_inner_initialized"]
        [::std::mem::offset_of!(_z_session_t, _mutex_inner_initialized) - 0usize];
    ["Offset of field: _z_session_t::_mutex_inner"]
        [::std::mem::offset_of!(_z_session_t, _mutex_inner) - 4usize];
    ["Offset of field: _z_session_t::_mode"][::std::mem::offset_of!(_z_session_t, _mode) - 8usize];
    ["Offset of field: _z_session_t::_tp"][::std::mem::offset_of!(_z_session_t, _tp) - 16usize];
    ["Offset of field: _z_session_t::_local_zid"]
        [::std::mem::offset_of!(_z_session_t, _local_zid) - 256usize];
    ["Offset of field: _z_session_t::_resource_id"]
        [::std::mem::offset_of!(_z_session_t, _resource_id) - 272usize];
    ["Offset of field: _z_session_t::_entity_id"]
        [::std::mem::offset_of!(_z_session_t, _entity_id) - 276usize];
    ["Offset of field: _z_session_t::_query_id"]
        [::std::mem::offset_of!(_z_session_t, _query_id) - 280usize];
    ["Offset of field: _z_session_t::_interest_id"]
        [::std::mem::offset_of!(_z_session_t, _interest_id) - 288usize];
    ["Offset of field: _z_session_t::_local_resources"]
        [::std::mem::offset_of!(_z_session_t, _local_resources) - 296usize];
    ["Offset of field: _z_session_t::_config"]
        [::std::mem::offset_of!(_z_session_t, _config) - 304usize];
    ["Offset of field: _z_session_t::_declaration_cache"]
        [::std::mem::offset_of!(_z_session_t, _declaration_cache) - 336usize];
    ["Offset of field: _z_session_t::_lease_task_attr"]
        [::std::mem::offset_of!(_z_session_t, _lease_task_attr) - 344usize];
    ["Offset of field: _z_session_t::_read_task_attr"]
        [::std::mem::offset_of!(_z_session_t, _read_task_attr) - 352usize];
    ["Offset of field: _z_session_t::_subscriptions"]
        [::std::mem::offset_of!(_z_session_t, _subscriptions) - 360usize];
    ["Offset of field: _z_session_t::_liveliness_subscriptions"]
        [::std::mem::offset_of!(_z_session_t, _liveliness_subscriptions) - 368usize];
    ["Offset of field: _z_session_t::_local_tokens"]
        [::std::mem::offset_of!(_z_session_t, _local_tokens) - 376usize];
    ["Offset of field: _z_session_t::_remote_tokens"]
        [::std::mem::offset_of!(_z_session_t, _remote_tokens) - 408usize];
    ["Offset of field: _z_session_t::_liveliness_query_id"]
        [::std::mem::offset_of!(_z_session_t, _liveliness_query_id) - 440usize];
    ["Offset of field: _z_session_t::_liveliness_pending_queries"]
        [::std::mem::offset_of!(_z_session_t, _liveliness_pending_queries) - 448usize];
    ["Offset of field: _z_session_t::_local_queryable"]
        [::std::mem::offset_of!(_z_session_t, _local_queryable) - 480usize];
    ["Offset of field: _z_session_t::_pending_queries"]
        [::std::mem::offset_of!(_z_session_t, _pending_queries) - 488usize];
    ["Offset of field: _z_session_t::_matching_listeners"]
        [::std::mem::offset_of!(_z_session_t, _matching_listeners) - 496usize];
    ["Offset of field: _z_session_t::_local_interests"]
        [::std::mem::offset_of!(_z_session_t, _local_interests) - 528usize];
    ["Offset of field: _z_session_t::_remote_declares"]
        [::std::mem::offset_of!(_z_session_t, _remote_declares) - 536usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_t {
    pub _id: u32,
    pub _interest_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_t"][::std::mem::size_of::<_z_matching_listener_t>() - 24usize];
    ["Alignment of _z_matching_listener_t"]
        [::std::mem::align_of::<_z_matching_listener_t>() - 8usize];
    ["Offset of field: _z_matching_listener_t::_id"]
        [::std::mem::offset_of!(_z_matching_listener_t, _id) - 0usize];
    ["Offset of field: _z_matching_listener_t::_interest_id"]
        [::std::mem::offset_of!(_z_matching_listener_t, _interest_id) - 4usize];
    ["Offset of field: _z_matching_listener_t::_zn"]
        [::std::mem::offset_of!(_z_matching_listener_t, _zn) - 8usize];
};
pub type _z_filter_target_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_writer_filter_ctx_t {
    pub mutex: _z_mutex_t,
    pub targets: *mut _z_filter_target_slist_t,
    pub state: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_writer_filter_ctx_t"][::std::mem::size_of::<_z_writer_filter_ctx_t>() - 24usize];
    ["Alignment of _z_writer_filter_ctx_t"]
        [::std::mem::align_of::<_z_writer_filter_ctx_t>() - 8usize];
    ["Offset of field: _z_writer_filter_ctx_t::mutex"]
        [::std::mem::offset_of!(_z_writer_filter_ctx_t, mutex) - 0usize];
    ["Offset of field: _z_writer_filter_ctx_t::targets"]
        [::std::mem::offset_of!(_z_writer_filter_ctx_t, targets) - 8usize];
    ["Offset of field: _z_writer_filter_ctx_t::state"]
        [::std::mem::offset_of!(_z_writer_filter_ctx_t, state) - 16usize];
};
#[doc = " Return type when declaring a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_write_filter_t {
    pub _interest_id: u32,
    pub ctx: *mut _z_writer_filter_ctx_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_write_filter_t"][::std::mem::size_of::<_z_write_filter_t>() - 16usize];
    ["Alignment of _z_write_filter_t"][::std::mem::align_of::<_z_write_filter_t>() - 8usize];
    ["Offset of field: _z_write_filter_t::_interest_id"]
        [::std::mem::offset_of!(_z_write_filter_t, _interest_id) - 0usize];
    ["Offset of field: _z_write_filter_t::ctx"]
        [::std::mem::offset_of!(_z_write_filter_t, ctx) - 8usize];
};
#[doc = " Return type when declaring a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_publisher_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _zn: _z_session_weak_t,
    pub _encoding: _z_encoding_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub reliability: z_reliability_t,
    pub _is_express: bool,
    pub _filter: _z_write_filter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_publisher_t"][::std::mem::size_of::<_z_publisher_t>() - 144usize];
    ["Alignment of _z_publisher_t"][::std::mem::align_of::<_z_publisher_t>() - 8usize];
    ["Offset of field: _z_publisher_t::_key"]
        [::std::mem::offset_of!(_z_publisher_t, _key) - 0usize];
    ["Offset of field: _z_publisher_t::_id"][::std::mem::offset_of!(_z_publisher_t, _id) - 48usize];
    ["Offset of field: _z_publisher_t::_zn"][::std::mem::offset_of!(_z_publisher_t, _zn) - 56usize];
    ["Offset of field: _z_publisher_t::_encoding"]
        [::std::mem::offset_of!(_z_publisher_t, _encoding) - 72usize];
    ["Offset of field: _z_publisher_t::_congestion_control"]
        [::std::mem::offset_of!(_z_publisher_t, _congestion_control) - 112usize];
    ["Offset of field: _z_publisher_t::_priority"]
        [::std::mem::offset_of!(_z_publisher_t, _priority) - 116usize];
    ["Offset of field: _z_publisher_t::reliability"]
        [::std::mem::offset_of!(_z_publisher_t, reliability) - 120usize];
    ["Offset of field: _z_publisher_t::_is_express"]
        [::std::mem::offset_of!(_z_publisher_t, _is_express) - 124usize];
    ["Offset of field: _z_publisher_t::_filter"]
        [::std::mem::offset_of!(_z_publisher_t, _filter) - 128usize];
};
#[doc = " The query to be answered by a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_t {
    pub _key: _z_keyexpr_t,
    pub _value: _z_value_t,
    pub _request_id: u32,
    pub _zn: _z_session_weak_t,
    pub _attachment: _z_bytes_t,
    pub _parameters: _z_string_t,
    pub _anyke: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_t"][::std::mem::size_of::<_z_query_t>() - 216usize];
    ["Alignment of _z_query_t"][::std::mem::align_of::<_z_query_t>() - 8usize];
    ["Offset of field: _z_query_t::_key"][::std::mem::offset_of!(_z_query_t, _key) - 0usize];
    ["Offset of field: _z_query_t::_value"][::std::mem::offset_of!(_z_query_t, _value) - 48usize];
    ["Offset of field: _z_query_t::_request_id"]
        [::std::mem::offset_of!(_z_query_t, _request_id) - 120usize];
    ["Offset of field: _z_query_t::_zn"][::std::mem::offset_of!(_z_query_t, _zn) - 128usize];
    ["Offset of field: _z_query_t::_attachment"]
        [::std::mem::offset_of!(_z_query_t, _attachment) - 144usize];
    ["Offset of field: _z_query_t::_parameters"]
        [::std::mem::offset_of!(_z_query_t, _parameters) - 176usize];
    ["Offset of field: _z_query_t::_anyke"][::std::mem::offset_of!(_z_query_t, _anyke) - 208usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_rc_t {
    pub _val: *mut _z_query_t,
    pub _cnt: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_rc_t"][::std::mem::size_of::<_z_query_rc_t>() - 16usize];
    ["Alignment of _z_query_rc_t"][::std::mem::align_of::<_z_query_rc_t>() - 8usize];
    ["Offset of field: _z_query_rc_t::_val"][::std::mem::offset_of!(_z_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_query_rc_t::_cnt"][::std::mem::offset_of!(_z_query_rc_t, _cnt) - 8usize];
};
#[doc = " Return type when declaring a querier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_querier_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _zn: _z_session_weak_t,
    pub _encoding: _z_encoding_t,
    pub _consolidation_mode: z_consolidation_mode_t,
    pub _target: z_query_target_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub reliability: z_reliability_t,
    pub _is_express: bool,
    pub _timeout_ms: u64,
    pub _filter: _z_write_filter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_querier_t"][::std::mem::size_of::<_z_querier_t>() - 160usize];
    ["Alignment of _z_querier_t"][::std::mem::align_of::<_z_querier_t>() - 8usize];
    ["Offset of field: _z_querier_t::_key"][::std::mem::offset_of!(_z_querier_t, _key) - 0usize];
    ["Offset of field: _z_querier_t::_id"][::std::mem::offset_of!(_z_querier_t, _id) - 48usize];
    ["Offset of field: _z_querier_t::_zn"][::std::mem::offset_of!(_z_querier_t, _zn) - 56usize];
    ["Offset of field: _z_querier_t::_encoding"]
        [::std::mem::offset_of!(_z_querier_t, _encoding) - 72usize];
    ["Offset of field: _z_querier_t::_consolidation_mode"]
        [::std::mem::offset_of!(_z_querier_t, _consolidation_mode) - 112usize];
    ["Offset of field: _z_querier_t::_target"]
        [::std::mem::offset_of!(_z_querier_t, _target) - 116usize];
    ["Offset of field: _z_querier_t::_congestion_control"]
        [::std::mem::offset_of!(_z_querier_t, _congestion_control) - 120usize];
    ["Offset of field: _z_querier_t::_priority"]
        [::std::mem::offset_of!(_z_querier_t, _priority) - 124usize];
    ["Offset of field: _z_querier_t::reliability"]
        [::std::mem::offset_of!(_z_querier_t, reliability) - 128usize];
    ["Offset of field: _z_querier_t::_is_express"]
        [::std::mem::offset_of!(_z_querier_t, _is_express) - 132usize];
    ["Offset of field: _z_querier_t::_timeout_ms"]
        [::std::mem::offset_of!(_z_querier_t, _timeout_ms) - 136usize];
    ["Offset of field: _z_querier_t::_filter"]
        [::std::mem::offset_of!(_z_querier_t, _filter) - 144usize];
};
#[doc = " Return type when declaring a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_t {
    pub _entity_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_t"][::std::mem::size_of::<_z_queryable_t>() - 24usize];
    ["Alignment of _z_queryable_t"][::std::mem::align_of::<_z_queryable_t>() - 8usize];
    ["Offset of field: _z_queryable_t::_entity_id"]
        [::std::mem::offset_of!(_z_queryable_t, _entity_id) - 0usize];
    ["Offset of field: _z_queryable_t::_zn"][::std::mem::offset_of!(_z_queryable_t, _zn) - 8usize];
};
#[doc = " A zenoh-net data sample.\n\n A sample is the value associated to a given resource at a given point in time.\n\n Members:\n   _z_keyexpr_t key: The resource key of this data sample.\n   _z_slice_t value: The value of this data sample.\n   _z_encoding_t encoding: The encoding for the value of this data sample.\n   _z_source_info_t source_info: The source info for this data sample (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sample_t {
    pub keyexpr: _z_keyexpr_t,
    pub payload: _z_bytes_t,
    pub timestamp: _z_timestamp_t,
    pub encoding: _z_encoding_t,
    pub kind: z_sample_kind_t,
    pub qos: _z_qos_t,
    pub attachment: _z_bytes_t,
    pub reliability: z_reliability_t,
    pub source_info: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sample_t"][::std::mem::size_of::<_z_sample_t>() - 224usize];
    ["Alignment of _z_sample_t"][::std::mem::align_of::<_z_sample_t>() - 8usize];
    ["Offset of field: _z_sample_t::keyexpr"]
        [::std::mem::offset_of!(_z_sample_t, keyexpr) - 0usize];
    ["Offset of field: _z_sample_t::payload"]
        [::std::mem::offset_of!(_z_sample_t, payload) - 48usize];
    ["Offset of field: _z_sample_t::timestamp"]
        [::std::mem::offset_of!(_z_sample_t, timestamp) - 80usize];
    ["Offset of field: _z_sample_t::encoding"]
        [::std::mem::offset_of!(_z_sample_t, encoding) - 112usize];
    ["Offset of field: _z_sample_t::kind"][::std::mem::offset_of!(_z_sample_t, kind) - 152usize];
    ["Offset of field: _z_sample_t::qos"][::std::mem::offset_of!(_z_sample_t, qos) - 156usize];
    ["Offset of field: _z_sample_t::attachment"]
        [::std::mem::offset_of!(_z_sample_t, attachment) - 160usize];
    ["Offset of field: _z_sample_t::reliability"]
        [::std::mem::offset_of!(_z_sample_t, reliability) - 192usize];
    ["Offset of field: _z_sample_t::source_info"]
        [::std::mem::offset_of!(_z_sample_t, source_info) - 196usize];
};
pub const _z_reply_tag_t__Z_REPLY_TAG_DATA: _z_reply_tag_t = 0;
pub const _z_reply_tag_t__Z_REPLY_TAG_FINAL: _z_reply_tag_t = 1;
pub const _z_reply_tag_t__Z_REPLY_TAG_ERROR: _z_reply_tag_t = 2;
pub const _z_reply_tag_t__Z_REPLY_TAG_NONE: _z_reply_tag_t = 3;
#[doc = " Reply tag values.\n\n Enumerators:\n     _Z_REPLY_TAG_DATA: Tag identifying that the reply contains some data.\n     _Z_REPLY_TAG_FINAL: Tag identifying that the reply does not contain any data and that there will be no more\n         replies for this query.\n     _Z_REPLY_TAG_ERROR: Tag identifying that the reply contains error.\n     _Z_REPLY_TAG_NONE: Tag identifying empty reply."]
pub type _z_reply_tag_t = ::std::os::raw::c_uint;
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_sample_t data: a :c:type:`_z_sample_t` containing the key and value of the reply.\n   _z_slice_t replier_id: The id of the entity that sent this reply.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_data_t {
    pub _result: _z_reply_data_t__bindgen_ty_1,
    pub replier_id: _z_entity_global_id_t,
    pub _tag: _z_reply_tag_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_reply_data_t__bindgen_ty_1 {
    pub error: _z_value_t,
    pub sample: _z_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_data_t__bindgen_ty_1"]
        [::std::mem::size_of::<_z_reply_data_t__bindgen_ty_1>() - 224usize];
    ["Alignment of _z_reply_data_t__bindgen_ty_1"]
        [::std::mem::align_of::<_z_reply_data_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_reply_data_t__bindgen_ty_1::error"]
        [::std::mem::offset_of!(_z_reply_data_t__bindgen_ty_1, error) - 0usize];
    ["Offset of field: _z_reply_data_t__bindgen_ty_1::sample"]
        [::std::mem::offset_of!(_z_reply_data_t__bindgen_ty_1, sample) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_data_t"][::std::mem::size_of::<_z_reply_data_t>() - 248usize];
    ["Alignment of _z_reply_data_t"][::std::mem::align_of::<_z_reply_data_t>() - 8usize];
    ["Offset of field: _z_reply_data_t::_result"]
        [::std::mem::offset_of!(_z_reply_data_t, _result) - 0usize];
    ["Offset of field: _z_reply_data_t::replier_id"]
        [::std::mem::offset_of!(_z_reply_data_t, replier_id) - 224usize];
    ["Offset of field: _z_reply_data_t::_tag"]
        [::std::mem::offset_of!(_z_reply_data_t, _tag) - 244usize];
};
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_reply_t_Tag tag: Indicates if the reply contains data or if it's a FINAL reply.\n   _z_reply_data_t data: The reply data if :c:member:`_z_reply_t.tag` equals\n :c:member:`_z_reply_t_Tag._Z_REPLY_TAG_DATA`.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_t {
    pub data: _z_reply_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_t"][::std::mem::size_of::<_z_reply_t>() - 248usize];
    ["Alignment of _z_reply_t"][::std::mem::align_of::<_z_reply_t>() - 8usize];
    ["Offset of field: _z_reply_t::data"][::std::mem::offset_of!(_z_reply_t, data) - 0usize];
};
#[doc = " Return type when declaring a subscriber."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscriber_t {
    pub _entity_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscriber_t"][::std::mem::size_of::<_z_subscriber_t>() - 24usize];
    ["Alignment of _z_subscriber_t"][::std::mem::align_of::<_z_subscriber_t>() - 8usize];
    ["Offset of field: _z_subscriber_t::_entity_id"]
        [::std::mem::offset_of!(_z_subscriber_t, _entity_id) - 0usize];
    ["Offset of field: _z_subscriber_t::_zn"]
        [::std::mem::offset_of!(_z_subscriber_t, _zn) - 8usize];
};
#[doc = " Represents a Zenoh ID.\n\n In general, valid Zenoh IDs are LSB-first 128bit unsigned and non-zero integers.\n\n Members:\n   uint8_t id[16]: The array containing the 16 octets of a Zenoh ID."]
pub type z_id_t = _z_id_t;
#[doc = "  Represents an ID globally identifying an entity in a Zenoh system."]
pub type z_entity_global_id_t = _z_entity_global_id_t;
#[doc = " A zenoh timestamp."]
pub type z_timestamp_t = _z_timestamp_t;
#[doc = " Represents an array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_slice_t {
    #[doc = " Represents an array of bytes."]
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_slice_t"][::std::mem::size_of::<z_owned_slice_t>() - 32usize];
    ["Alignment of z_owned_slice_t"][::std::mem::align_of::<z_owned_slice_t>() - 8usize];
    ["Offset of field: z_owned_slice_t::_val"]
        [::std::mem::offset_of!(z_owned_slice_t, _val) - 0usize];
};
#[doc = " Represents an array of bytes."]
pub type z_loaned_slice_t = _z_slice_t;
#[doc = " Represents an array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_slice_t {
    pub _this: z_owned_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_slice_t"][::std::mem::size_of::<z_moved_slice_t>() - 32usize];
    ["Alignment of z_moved_slice_t"][::std::mem::align_of::<z_moved_slice_t>() - 8usize];
    ["Offset of field: z_moved_slice_t::_this"]
        [::std::mem::offset_of!(z_moved_slice_t, _this) - 0usize];
};
#[doc = " Represents an array of bytes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_slice_t {
    #[doc = " Represents an array of bytes."]
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_slice_t"][::std::mem::size_of::<z_view_slice_t>() - 32usize];
    ["Alignment of z_view_slice_t"][::std::mem::align_of::<z_view_slice_t>() - 8usize];
    ["Offset of field: z_view_slice_t::_val"]
        [::std::mem::offset_of!(z_view_slice_t, _val) - 0usize];
};
#[doc = " Represents a container for slices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_bytes_t {
    #[doc = " Represents a container for slices."]
    pub _val: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_bytes_t"][::std::mem::size_of::<z_owned_bytes_t>() - 32usize];
    ["Alignment of z_owned_bytes_t"][::std::mem::align_of::<z_owned_bytes_t>() - 8usize];
    ["Offset of field: z_owned_bytes_t::_val"]
        [::std::mem::offset_of!(z_owned_bytes_t, _val) - 0usize];
};
#[doc = " Represents a container for slices."]
pub type z_loaned_bytes_t = _z_bytes_t;
#[doc = " Represents a container for slices."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_bytes_t {
    pub _this: z_owned_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_bytes_t"][::std::mem::size_of::<z_moved_bytes_t>() - 32usize];
    ["Alignment of z_moved_bytes_t"][::std::mem::align_of::<z_moved_bytes_t>() - 8usize];
    ["Offset of field: z_moved_bytes_t::_this"]
        [::std::mem::offset_of!(z_moved_bytes_t, _this) - 0usize];
};
#[doc = " Represents a writer for data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_bytes_writer_t {
    #[doc = " Represents a writer for data."]
    pub _val: _z_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_bytes_writer_t"][::std::mem::size_of::<z_owned_bytes_writer_t>() - 40usize];
    ["Alignment of z_owned_bytes_writer_t"]
        [::std::mem::align_of::<z_owned_bytes_writer_t>() - 8usize];
    ["Offset of field: z_owned_bytes_writer_t::_val"]
        [::std::mem::offset_of!(z_owned_bytes_writer_t, _val) - 0usize];
};
#[doc = " Represents a writer for data."]
pub type z_loaned_bytes_writer_t = _z_bytes_writer_t;
#[doc = " Represents a writer for data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_bytes_writer_t {
    pub _this: z_owned_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_bytes_writer_t"][::std::mem::size_of::<z_moved_bytes_writer_t>() - 40usize];
    ["Alignment of z_moved_bytes_writer_t"]
        [::std::mem::align_of::<z_moved_bytes_writer_t>() - 8usize];
    ["Offset of field: z_moved_bytes_writer_t::_this"]
        [::std::mem::offset_of!(z_moved_bytes_writer_t, _this) - 0usize];
};
#[doc = " A reader for data."]
pub type z_bytes_reader_t = _z_bytes_reader_t;
#[doc = " An iterator over slices of data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_bytes_slice_iterator_t {
    pub _bytes: *const _z_bytes_t,
    pub _slice_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_bytes_slice_iterator_t"]
        [::std::mem::size_of::<z_bytes_slice_iterator_t>() - 16usize];
    ["Alignment of z_bytes_slice_iterator_t"]
        [::std::mem::align_of::<z_bytes_slice_iterator_t>() - 8usize];
    ["Offset of field: z_bytes_slice_iterator_t::_bytes"]
        [::std::mem::offset_of!(z_bytes_slice_iterator_t, _bytes) - 0usize];
    ["Offset of field: z_bytes_slice_iterator_t::_slice_idx"]
        [::std::mem::offset_of!(z_bytes_slice_iterator_t, _slice_idx) - 8usize];
};
#[doc = " Represents a string without null-terminator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_string_t {
    #[doc = " Represents a string without null-terminator."]
    pub _val: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_string_t"][::std::mem::size_of::<z_owned_string_t>() - 32usize];
    ["Alignment of z_owned_string_t"][::std::mem::align_of::<z_owned_string_t>() - 8usize];
    ["Offset of field: z_owned_string_t::_val"]
        [::std::mem::offset_of!(z_owned_string_t, _val) - 0usize];
};
#[doc = " Represents a string without null-terminator."]
pub type z_loaned_string_t = _z_string_t;
#[doc = " Represents a string without null-terminator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_string_t {
    pub _this: z_owned_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_string_t"][::std::mem::size_of::<z_moved_string_t>() - 32usize];
    ["Alignment of z_moved_string_t"][::std::mem::align_of::<z_moved_string_t>() - 8usize];
    ["Offset of field: z_moved_string_t::_this"]
        [::std::mem::offset_of!(z_moved_string_t, _this) - 0usize];
};
#[doc = " Represents a string without null-terminator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_string_t {
    #[doc = " Represents a string without null-terminator."]
    pub _val: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_string_t"][::std::mem::size_of::<z_view_string_t>() - 32usize];
    ["Alignment of z_view_string_t"][::std::mem::align_of::<z_view_string_t>() - 8usize];
    ["Offset of field: z_view_string_t::_val"]
        [::std::mem::offset_of!(z_view_string_t, _val) - 0usize];
};
#[doc = " Represents a key expression in Zenoh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_keyexpr_t {
    #[doc = " Represents a key expression in Zenoh."]
    pub _val: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_keyexpr_t"][::std::mem::size_of::<z_owned_keyexpr_t>() - 48usize];
    ["Alignment of z_owned_keyexpr_t"][::std::mem::align_of::<z_owned_keyexpr_t>() - 8usize];
    ["Offset of field: z_owned_keyexpr_t::_val"]
        [::std::mem::offset_of!(z_owned_keyexpr_t, _val) - 0usize];
};
#[doc = " Represents a key expression in Zenoh."]
pub type z_loaned_keyexpr_t = _z_keyexpr_t;
#[doc = " Represents a key expression in Zenoh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_keyexpr_t {
    pub _this: z_owned_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_keyexpr_t"][::std::mem::size_of::<z_moved_keyexpr_t>() - 48usize];
    ["Alignment of z_moved_keyexpr_t"][::std::mem::align_of::<z_moved_keyexpr_t>() - 8usize];
    ["Offset of field: z_moved_keyexpr_t::_this"]
        [::std::mem::offset_of!(z_moved_keyexpr_t, _this) - 0usize];
};
#[doc = " Represents a key expression in Zenoh."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_keyexpr_t {
    #[doc = " Represents a key expression in Zenoh."]
    pub _val: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_keyexpr_t"][::std::mem::size_of::<z_view_keyexpr_t>() - 48usize];
    ["Alignment of z_view_keyexpr_t"][::std::mem::align_of::<z_view_keyexpr_t>() - 8usize];
    ["Offset of field: z_view_keyexpr_t::_val"]
        [::std::mem::offset_of!(z_view_keyexpr_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_config_t {
    #[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
    pub _val: _z_config_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_config_t"][::std::mem::size_of::<z_owned_config_t>() - 32usize];
    ["Alignment of z_owned_config_t"][::std::mem::align_of::<z_owned_config_t>() - 8usize];
    ["Offset of field: z_owned_config_t::_val"]
        [::std::mem::offset_of!(z_owned_config_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
pub type z_loaned_config_t = _z_config_t;
#[doc = " Represents a Zenoh configuration, used to configure Zenoh sessions upon opening."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_config_t {
    pub _this: z_owned_config_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_config_t"][::std::mem::size_of::<z_moved_config_t>() - 32usize];
    ["Alignment of z_moved_config_t"][::std::mem::align_of::<z_moved_config_t>() - 8usize];
    ["Offset of field: z_moved_config_t::_this"]
        [::std::mem::offset_of!(z_moved_config_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_session_t {
    #[doc = " Represents a Zenoh Session."]
    pub _rc: _z_session_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_session_t"][::std::mem::size_of::<z_owned_session_t>() - 16usize];
    ["Alignment of z_owned_session_t"][::std::mem::align_of::<z_owned_session_t>() - 8usize];
    ["Offset of field: z_owned_session_t::_rc"]
        [::std::mem::offset_of!(z_owned_session_t, _rc) - 0usize];
};
#[doc = " Represents a Zenoh Session."]
pub type z_loaned_session_t = _z_session_rc_t;
#[doc = " Represents a Zenoh Session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_session_t {
    pub _this: z_owned_session_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_session_t"][::std::mem::size_of::<z_moved_session_t>() - 16usize];
    ["Alignment of z_moved_session_t"][::std::mem::align_of::<z_moved_session_t>() - 8usize];
    ["Offset of field: z_moved_session_t::_this"]
        [::std::mem::offset_of!(z_moved_session_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Subscriber entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_subscriber_t {
    #[doc = " Represents a Zenoh Subscriber entity."]
    pub _val: _z_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_subscriber_t"][::std::mem::size_of::<z_owned_subscriber_t>() - 24usize];
    ["Alignment of z_owned_subscriber_t"][::std::mem::align_of::<z_owned_subscriber_t>() - 8usize];
    ["Offset of field: z_owned_subscriber_t::_val"]
        [::std::mem::offset_of!(z_owned_subscriber_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Subscriber entity."]
pub type z_loaned_subscriber_t = _z_subscriber_t;
#[doc = " Represents a Zenoh Subscriber entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_subscriber_t {
    pub _this: z_owned_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_subscriber_t"][::std::mem::size_of::<z_moved_subscriber_t>() - 24usize];
    ["Alignment of z_moved_subscriber_t"][::std::mem::align_of::<z_moved_subscriber_t>() - 8usize];
    ["Offset of field: z_moved_subscriber_t::_this"]
        [::std::mem::offset_of!(z_moved_subscriber_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Publisher entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_publisher_t {
    #[doc = " Represents a Zenoh Publisher entity."]
    pub _val: _z_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_publisher_t"][::std::mem::size_of::<z_owned_publisher_t>() - 144usize];
    ["Alignment of z_owned_publisher_t"][::std::mem::align_of::<z_owned_publisher_t>() - 8usize];
    ["Offset of field: z_owned_publisher_t::_val"]
        [::std::mem::offset_of!(z_owned_publisher_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Publisher entity."]
pub type z_loaned_publisher_t = _z_publisher_t;
#[doc = " Represents a Zenoh Publisher entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_publisher_t {
    pub _this: z_owned_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_publisher_t"][::std::mem::size_of::<z_moved_publisher_t>() - 144usize];
    ["Alignment of z_moved_publisher_t"][::std::mem::align_of::<z_moved_publisher_t>() - 8usize];
    ["Offset of field: z_moved_publisher_t::_this"]
        [::std::mem::offset_of!(z_moved_publisher_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Querier entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_querier_t {
    #[doc = " Represents a Zenoh Querier entity."]
    pub _val: _z_querier_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_querier_t"][::std::mem::size_of::<z_owned_querier_t>() - 160usize];
    ["Alignment of z_owned_querier_t"][::std::mem::align_of::<z_owned_querier_t>() - 8usize];
    ["Offset of field: z_owned_querier_t::_val"]
        [::std::mem::offset_of!(z_owned_querier_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Querier entity."]
pub type z_loaned_querier_t = _z_querier_t;
#[doc = " Represents a Zenoh Querier entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_querier_t {
    pub _this: z_owned_querier_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_querier_t"][::std::mem::size_of::<z_moved_querier_t>() - 160usize];
    ["Alignment of z_moved_querier_t"][::std::mem::align_of::<z_moved_querier_t>() - 8usize];
    ["Offset of field: z_moved_querier_t::_this"]
        [::std::mem::offset_of!(z_moved_querier_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Matching listener entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_matching_listener_t {
    #[doc = " Represents a Zenoh Matching listener entity."]
    pub _val: _z_matching_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_matching_listener_t"]
        [::std::mem::size_of::<z_owned_matching_listener_t>() - 24usize];
    ["Alignment of z_owned_matching_listener_t"]
        [::std::mem::align_of::<z_owned_matching_listener_t>() - 8usize];
    ["Offset of field: z_owned_matching_listener_t::_val"]
        [::std::mem::offset_of!(z_owned_matching_listener_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Matching listener entity."]
pub type z_loaned_matching_listener_t = _z_matching_listener_t;
#[doc = " Represents a Zenoh Matching listener entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_matching_listener_t {
    pub _this: z_owned_matching_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_matching_listener_t"]
        [::std::mem::size_of::<z_moved_matching_listener_t>() - 24usize];
    ["Alignment of z_moved_matching_listener_t"]
        [::std::mem::align_of::<z_moved_matching_listener_t>() - 8usize];
    ["Offset of field: z_moved_matching_listener_t::_this"]
        [::std::mem::offset_of!(z_moved_matching_listener_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Queryable entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_queryable_t {
    #[doc = " Represents a Zenoh Queryable entity."]
    pub _val: _z_queryable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_queryable_t"][::std::mem::size_of::<z_owned_queryable_t>() - 24usize];
    ["Alignment of z_owned_queryable_t"][::std::mem::align_of::<z_owned_queryable_t>() - 8usize];
    ["Offset of field: z_owned_queryable_t::_val"]
        [::std::mem::offset_of!(z_owned_queryable_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh Queryable entity."]
pub type z_loaned_queryable_t = _z_queryable_t;
#[doc = " Represents a Zenoh Queryable entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_queryable_t {
    pub _this: z_owned_queryable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_queryable_t"][::std::mem::size_of::<z_moved_queryable_t>() - 24usize];
    ["Alignment of z_moved_queryable_t"][::std::mem::align_of::<z_moved_queryable_t>() - 8usize];
    ["Offset of field: z_moved_queryable_t::_this"]
        [::std::mem::offset_of!(z_moved_queryable_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_query_t {
    #[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
    pub _rc: _z_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_query_t"][::std::mem::size_of::<z_owned_query_t>() - 16usize];
    ["Alignment of z_owned_query_t"][::std::mem::align_of::<z_owned_query_t>() - 8usize];
    ["Offset of field: z_owned_query_t::_rc"]
        [::std::mem::offset_of!(z_owned_query_t, _rc) - 0usize];
};
#[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
pub type z_loaned_query_t = _z_query_rc_t;
#[doc = " Represents a Zenoh Query entity, received by Zenoh Queryable entities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_query_t {
    pub _this: z_owned_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_query_t"][::std::mem::size_of::<z_moved_query_t>() - 16usize];
    ["Alignment of z_moved_query_t"][::std::mem::align_of::<z_moved_query_t>() - 8usize];
    ["Offset of field: z_moved_query_t::_this"]
        [::std::mem::offset_of!(z_moved_query_t, _this) - 0usize];
};
#[doc = " Represents the encoding of a payload, in a MIME-like format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_encoding_t {
    #[doc = " Represents the encoding of a payload, in a MIME-like format."]
    pub _val: _z_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_encoding_t"][::std::mem::size_of::<z_owned_encoding_t>() - 40usize];
    ["Alignment of z_owned_encoding_t"][::std::mem::align_of::<z_owned_encoding_t>() - 8usize];
    ["Offset of field: z_owned_encoding_t::_val"]
        [::std::mem::offset_of!(z_owned_encoding_t, _val) - 0usize];
};
#[doc = " Represents the encoding of a payload, in a MIME-like format."]
pub type z_loaned_encoding_t = _z_encoding_t;
#[doc = " Represents the encoding of a payload, in a MIME-like format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_encoding_t {
    pub _this: z_owned_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_encoding_t"][::std::mem::size_of::<z_moved_encoding_t>() - 40usize];
    ["Alignment of z_moved_encoding_t"][::std::mem::align_of::<z_moved_encoding_t>() - 8usize];
    ["Offset of field: z_moved_encoding_t::_this"]
        [::std::mem::offset_of!(z_moved_encoding_t, _this) - 0usize];
};
#[doc = " Represents a Zenoh reply error."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_reply_err_t {
    #[doc = " Represents a Zenoh reply error."]
    pub _val: _z_value_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_reply_err_t"][::std::mem::size_of::<z_owned_reply_err_t>() - 72usize];
    ["Alignment of z_owned_reply_err_t"][::std::mem::align_of::<z_owned_reply_err_t>() - 8usize];
    ["Offset of field: z_owned_reply_err_t::_val"]
        [::std::mem::offset_of!(z_owned_reply_err_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh reply error."]
pub type z_loaned_reply_err_t = _z_value_t;
#[doc = " Represents a Zenoh reply error."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_reply_err_t {
    pub _this: z_owned_reply_err_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_reply_err_t"][::std::mem::size_of::<z_moved_reply_err_t>() - 72usize];
    ["Alignment of z_moved_reply_err_t"][::std::mem::align_of::<z_moved_reply_err_t>() - 8usize];
    ["Offset of field: z_moved_reply_err_t::_this"]
        [::std::mem::offset_of!(z_moved_reply_err_t, _this) - 0usize];
};
#[doc = " Represents sample source information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_source_info_t {
    #[doc = " Represents sample source information."]
    pub _val: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_source_info_t"][::std::mem::size_of::<z_owned_source_info_t>() - 24usize];
    ["Alignment of z_owned_source_info_t"]
        [::std::mem::align_of::<z_owned_source_info_t>() - 4usize];
    ["Offset of field: z_owned_source_info_t::_val"]
        [::std::mem::offset_of!(z_owned_source_info_t, _val) - 0usize];
};
#[doc = " Represents sample source information."]
pub type z_loaned_source_info_t = _z_source_info_t;
#[doc = " Represents sample source information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_source_info_t {
    pub _this: z_owned_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_source_info_t"][::std::mem::size_of::<z_moved_source_info_t>() - 24usize];
    ["Alignment of z_moved_source_info_t"]
        [::std::mem::align_of::<z_moved_source_info_t>() - 4usize];
    ["Offset of field: z_moved_source_info_t::_this"]
        [::std::mem::offset_of!(z_moved_source_info_t, _this) - 0usize];
};
#[doc = " A struct that indicates if there exist Subscribers matching the Publisher's key expression or Queryables matching\n Querier's key expression and target.\n Members:\n   bool matching: true if there exist matching Zenoh entities, false otherwise."]
pub type z_matching_status_t = _z_matching_status_t;
#[doc = " Represents the configuration used to configure a subscriber upon declaration :c:func:`z_declare_subscriber`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_subscriber_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_subscriber_options_t"][::std::mem::size_of::<z_subscriber_options_t>() - 1usize];
    ["Alignment of z_subscriber_options_t"]
        [::std::mem::align_of::<z_subscriber_options_t>() - 1usize];
    ["Offset of field: z_subscriber_options_t::__dummy"]
        [::std::mem::offset_of!(z_subscriber_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a zenoh upon opening :c:func:`z_open`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_open_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_open_options_t"][::std::mem::size_of::<z_open_options_t>() - 1usize];
    ["Alignment of z_open_options_t"][::std::mem::align_of::<z_open_options_t>() - 1usize];
    ["Offset of field: z_open_options_t::__dummy"]
        [::std::mem::offset_of!(z_open_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a zenoh upon closing :c:func:`z_close`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_close_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_close_options_t"][::std::mem::size_of::<z_close_options_t>() - 1usize];
    ["Alignment of z_close_options_t"][::std::mem::align_of::<z_close_options_t>() - 1usize];
    ["Offset of field: z_close_options_t::__dummy"]
        [::std::mem::offset_of!(z_close_options_t, __dummy) - 0usize];
};
#[doc = " Represents the reply consolidation mode to apply on replies to a :c:func:`z_get`.\n\n Members:\n   z_consolidation_mode_t mode: the consolidation mode, see :c:type:`z_consolidation_mode_t`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_consolidation_t {
    pub mode: z_consolidation_mode_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_consolidation_t"][::std::mem::size_of::<z_query_consolidation_t>() - 4usize];
    ["Alignment of z_query_consolidation_t"]
        [::std::mem::align_of::<z_query_consolidation_t>() - 4usize];
    ["Offset of field: z_query_consolidation_t::mode"]
        [::std::mem::offset_of!(z_query_consolidation_t, mode) - 0usize];
};
#[doc = " Represents the configuration used to configure a publisher upon declaration with :c:func:`z_declare_publisher`.\n\n Members:\n   z_moved_encoding_t *encoding: Default encoding for messages put by this publisher.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing messages from this\n     publisher.\n   z_priority_t priority: The priority of messages issued by this publisher.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_options_t"][::std::mem::size_of::<z_publisher_options_t>() - 24usize];
    ["Alignment of z_publisher_options_t"]
        [::std::mem::align_of::<z_publisher_options_t>() - 8usize];
    ["Offset of field: z_publisher_options_t::encoding"]
        [::std::mem::offset_of!(z_publisher_options_t, encoding) - 0usize];
    ["Offset of field: z_publisher_options_t::congestion_control"]
        [::std::mem::offset_of!(z_publisher_options_t, congestion_control) - 8usize];
    ["Offset of field: z_publisher_options_t::priority"]
        [::std::mem::offset_of!(z_publisher_options_t, priority) - 12usize];
    ["Offset of field: z_publisher_options_t::is_express"]
        [::std::mem::offset_of!(z_publisher_options_t, is_express) - 16usize];
};
#[doc = " Options passed to the :c:func:`z_declare_querier()` function.\n\n Members:\n   z_moved_encoding_t *encoding: Default encoding for values sent by this querier.\n   z_query_target_t target: The Queryables that should be target of the querier queries.\n   z_query_consolidation_t consolidation: The replies consolidation strategy to apply on replies to the querier\n    queries.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing the querier queries.\n   bool is_express: If set to ``true``, the querier queries will not be batched. This usually has a positive impact on\n \t   latency but negative impact on throughput.\n   z_priority_t priority: The priority of the querier queries.\n   uint64_t timeout_ms: The timeout for the querier queries in milliseconds. 0 means default query timeout from zenoh\n     configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_querier_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub target: z_query_target_t,
    pub consolidation: z_query_consolidation_t,
    pub congestion_control: z_congestion_control_t,
    pub is_express: bool,
    pub priority: z_priority_t,
    pub timeout_ms: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_querier_options_t"][::std::mem::size_of::<z_querier_options_t>() - 40usize];
    ["Alignment of z_querier_options_t"][::std::mem::align_of::<z_querier_options_t>() - 8usize];
    ["Offset of field: z_querier_options_t::encoding"]
        [::std::mem::offset_of!(z_querier_options_t, encoding) - 0usize];
    ["Offset of field: z_querier_options_t::target"]
        [::std::mem::offset_of!(z_querier_options_t, target) - 8usize];
    ["Offset of field: z_querier_options_t::consolidation"]
        [::std::mem::offset_of!(z_querier_options_t, consolidation) - 12usize];
    ["Offset of field: z_querier_options_t::congestion_control"]
        [::std::mem::offset_of!(z_querier_options_t, congestion_control) - 16usize];
    ["Offset of field: z_querier_options_t::is_express"]
        [::std::mem::offset_of!(z_querier_options_t, is_express) - 20usize];
    ["Offset of field: z_querier_options_t::priority"]
        [::std::mem::offset_of!(z_querier_options_t, priority) - 24usize];
    ["Offset of field: z_querier_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_querier_options_t, timeout_ms) - 32usize];
};
#[doc = " Options passed to the :c:func:`z_querier_get()` function.\n\n Members:\n   z_moved_bytes_t *payload: An optional payload to attach to the query.\n   z_moved_encoding_t *encoding: An optional encoding of the query payload and or attachment.\n   z_moved_bytes_t *attachment: An optional attachment to attach to the query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_querier_get_options_t {
    pub payload: *mut z_moved_bytes_t,
    pub encoding: *mut z_moved_encoding_t,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_querier_get_options_t"][::std::mem::size_of::<z_querier_get_options_t>() - 24usize];
    ["Alignment of z_querier_get_options_t"]
        [::std::mem::align_of::<z_querier_get_options_t>() - 8usize];
    ["Offset of field: z_querier_get_options_t::payload"]
        [::std::mem::offset_of!(z_querier_get_options_t, payload) - 0usize];
    ["Offset of field: z_querier_get_options_t::encoding"]
        [::std::mem::offset_of!(z_querier_get_options_t, encoding) - 8usize];
    ["Offset of field: z_querier_get_options_t::attachment"]
        [::std::mem::offset_of!(z_querier_get_options_t, attachment) - 16usize];
};
#[doc = " Represents the configuration used to configure a queryable upon declaration :c:func:`z_declare_queryable`.\n\n Members:\n   bool complete: The completeness of the queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_queryable_options_t {
    pub complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_queryable_options_t"][::std::mem::size_of::<z_queryable_options_t>() - 1usize];
    ["Alignment of z_queryable_options_t"]
        [::std::mem::align_of::<z_queryable_options_t>() - 1usize];
    ["Offset of field: z_queryable_options_t::complete"]
        [::std::mem::offset_of!(z_queryable_options_t, complete) - 0usize];
};
#[doc = " Represents the configuration used to configure a query reply sent via :c:func:`z_query_reply`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the response.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_options_t"][::std::mem::size_of::<z_query_reply_options_t>() - 40usize];
    ["Alignment of z_query_reply_options_t"]
        [::std::mem::align_of::<z_query_reply_options_t>() - 8usize];
    ["Offset of field: z_query_reply_options_t::encoding"]
        [::std::mem::offset_of!(z_query_reply_options_t, encoding) - 0usize];
    ["Offset of field: z_query_reply_options_t::congestion_control"]
        [::std::mem::offset_of!(z_query_reply_options_t, congestion_control) - 8usize];
    ["Offset of field: z_query_reply_options_t::priority"]
        [::std::mem::offset_of!(z_query_reply_options_t, priority) - 12usize];
    ["Offset of field: z_query_reply_options_t::timestamp"]
        [::std::mem::offset_of!(z_query_reply_options_t, timestamp) - 16usize];
    ["Offset of field: z_query_reply_options_t::is_express"]
        [::std::mem::offset_of!(z_query_reply_options_t, is_express) - 24usize];
    ["Offset of field: z_query_reply_options_t::attachment"]
        [::std::mem::offset_of!(z_query_reply_options_t, attachment) - 32usize];
};
#[doc = " Represents the configuration used to configure a query reply delete sent via :c:func:`z_query_reply_del`.\n\n Members:\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the response.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_del_options_t {
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_del_options_t"]
        [::std::mem::size_of::<z_query_reply_del_options_t>() - 32usize];
    ["Alignment of z_query_reply_del_options_t"]
        [::std::mem::align_of::<z_query_reply_del_options_t>() - 8usize];
    ["Offset of field: z_query_reply_del_options_t::congestion_control"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, congestion_control) - 0usize];
    ["Offset of field: z_query_reply_del_options_t::priority"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, priority) - 4usize];
    ["Offset of field: z_query_reply_del_options_t::timestamp"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, timestamp) - 8usize];
    ["Offset of field: z_query_reply_del_options_t::is_express"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, is_express) - 16usize];
    ["Offset of field: z_query_reply_del_options_t::attachment"]
        [::std::mem::offset_of!(z_query_reply_del_options_t, attachment) - 24usize];
};
#[doc = " Represents the configuration used to configure a query reply error sent via :c:func:`z_query_reply_err`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_err_options_t {
    pub encoding: *mut z_moved_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_err_options_t"]
        [::std::mem::size_of::<z_query_reply_err_options_t>() - 8usize];
    ["Alignment of z_query_reply_err_options_t"]
        [::std::mem::align_of::<z_query_reply_err_options_t>() - 8usize];
    ["Offset of field: z_query_reply_err_options_t::encoding"]
        [::std::mem::offset_of!(z_query_reply_err_options_t, encoding) - 0usize];
};
#[doc = " Represents the configuration used to configure a put operation sent via :c:func:`z_put`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the publication.\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_put_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_put_options_t"][::std::mem::size_of::<z_put_options_t>() - 40usize];
    ["Alignment of z_put_options_t"][::std::mem::align_of::<z_put_options_t>() - 8usize];
    ["Offset of field: z_put_options_t::encoding"]
        [::std::mem::offset_of!(z_put_options_t, encoding) - 0usize];
    ["Offset of field: z_put_options_t::congestion_control"]
        [::std::mem::offset_of!(z_put_options_t, congestion_control) - 8usize];
    ["Offset of field: z_put_options_t::priority"]
        [::std::mem::offset_of!(z_put_options_t, priority) - 12usize];
    ["Offset of field: z_put_options_t::timestamp"]
        [::std::mem::offset_of!(z_put_options_t, timestamp) - 16usize];
    ["Offset of field: z_put_options_t::is_express"]
        [::std::mem::offset_of!(z_put_options_t, is_express) - 24usize];
    ["Offset of field: z_put_options_t::attachment"]
        [::std::mem::offset_of!(z_put_options_t, attachment) - 32usize];
};
#[doc = " Represents the configuration used to configure a delete operation sent via :c:func:`z_delete`.\n\n Members:\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when router.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_delete_options_t {
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub timestamp: *mut z_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_delete_options_t"][::std::mem::size_of::<z_delete_options_t>() - 24usize];
    ["Alignment of z_delete_options_t"][::std::mem::align_of::<z_delete_options_t>() - 8usize];
    ["Offset of field: z_delete_options_t::congestion_control"]
        [::std::mem::offset_of!(z_delete_options_t, congestion_control) - 0usize];
    ["Offset of field: z_delete_options_t::priority"]
        [::std::mem::offset_of!(z_delete_options_t, priority) - 4usize];
    ["Offset of field: z_delete_options_t::is_express"]
        [::std::mem::offset_of!(z_delete_options_t, is_express) - 8usize];
    ["Offset of field: z_delete_options_t::timestamp"]
        [::std::mem::offset_of!(z_delete_options_t, timestamp) - 16usize];
};
#[doc = " Represents the configuration used to configure a put operation by a previously declared publisher,\n sent via :c:func:`z_publisher_put`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_moved_bytes_t* attachment: An optional attachment to the publication.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_put_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub timestamp: *mut z_timestamp_t,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_put_options_t"]
        [::std::mem::size_of::<z_publisher_put_options_t>() - 24usize];
    ["Alignment of z_publisher_put_options_t"]
        [::std::mem::align_of::<z_publisher_put_options_t>() - 8usize];
    ["Offset of field: z_publisher_put_options_t::encoding"]
        [::std::mem::offset_of!(z_publisher_put_options_t, encoding) - 0usize];
    ["Offset of field: z_publisher_put_options_t::timestamp"]
        [::std::mem::offset_of!(z_publisher_put_options_t, timestamp) - 8usize];
    ["Offset of field: z_publisher_put_options_t::attachment"]
        [::std::mem::offset_of!(z_publisher_put_options_t, attachment) - 16usize];
};
#[doc = " Represents the configuration used to configure a delete operation by a previously declared publisher,\n sent via :c:func:`z_publisher_delete`.\n\n Members:\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_delete_options_t {
    pub timestamp: *mut z_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_delete_options_t"]
        [::std::mem::size_of::<z_publisher_delete_options_t>() - 8usize];
    ["Alignment of z_publisher_delete_options_t"]
        [::std::mem::align_of::<z_publisher_delete_options_t>() - 8usize];
    ["Offset of field: z_publisher_delete_options_t::timestamp"]
        [::std::mem::offset_of!(z_publisher_delete_options_t, timestamp) - 0usize];
};
#[doc = " Represents the configuration used to configure a get operation sent via :c:func:`z_get`.\n\n Members:\n   z_moved_bytes_t* payload: The payload to include in the query.\n   z_moved_encoding_t* encoding: Payload encoding.\n   z_query_consolidation_t consolidation: The replies consolidation strategy to apply on replies.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing the query.\n   z_priority_t priority: The priority of the query.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_query_target_t target: The queryables that should be targeted by this get.\n   z_moved_bytes_t* attachment: An optional attachment to the query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_get_options_t {
    pub payload: *mut z_moved_bytes_t,
    pub encoding: *mut z_moved_encoding_t,
    pub consolidation: z_query_consolidation_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub target: z_query_target_t,
    pub timeout_ms: u64,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_get_options_t"][::std::mem::size_of::<z_get_options_t>() - 56usize];
    ["Alignment of z_get_options_t"][::std::mem::align_of::<z_get_options_t>() - 8usize];
    ["Offset of field: z_get_options_t::payload"]
        [::std::mem::offset_of!(z_get_options_t, payload) - 0usize];
    ["Offset of field: z_get_options_t::encoding"]
        [::std::mem::offset_of!(z_get_options_t, encoding) - 8usize];
    ["Offset of field: z_get_options_t::consolidation"]
        [::std::mem::offset_of!(z_get_options_t, consolidation) - 16usize];
    ["Offset of field: z_get_options_t::congestion_control"]
        [::std::mem::offset_of!(z_get_options_t, congestion_control) - 20usize];
    ["Offset of field: z_get_options_t::priority"]
        [::std::mem::offset_of!(z_get_options_t, priority) - 24usize];
    ["Offset of field: z_get_options_t::is_express"]
        [::std::mem::offset_of!(z_get_options_t, is_express) - 28usize];
    ["Offset of field: z_get_options_t::target"]
        [::std::mem::offset_of!(z_get_options_t, target) - 32usize];
    ["Offset of field: z_get_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_get_options_t, timeout_ms) - 40usize];
    ["Offset of field: z_get_options_t::attachment"]
        [::std::mem::offset_of!(z_get_options_t, attachment) - 48usize];
};
#[doc = " Represents the configuration used to configure a publisher upon declaration with :c:func:`z_declare_publisher`.\n\n Members:\n   uint64_t timeout_ms: The maximum duration in ms the scouting can take.\n   z_what_t what: Type of entities to scout for."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_scout_options_t {
    pub timeout_ms: u32,
    pub what: z_what_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_scout_options_t"][::std::mem::size_of::<z_scout_options_t>() - 8usize];
    ["Alignment of z_scout_options_t"][::std::mem::align_of::<z_scout_options_t>() - 4usize];
    ["Offset of field: z_scout_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_scout_options_t, timeout_ms) - 0usize];
    ["Offset of field: z_scout_options_t::what"]
        [::std::mem::offset_of!(z_scout_options_t, what) - 4usize];
};
#[doc = " Represents a data sample."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_sample_t {
    #[doc = " Represents a data sample."]
    pub _val: _z_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_sample_t"][::std::mem::size_of::<z_owned_sample_t>() - 224usize];
    ["Alignment of z_owned_sample_t"][::std::mem::align_of::<z_owned_sample_t>() - 8usize];
    ["Offset of field: z_owned_sample_t::_val"]
        [::std::mem::offset_of!(z_owned_sample_t, _val) - 0usize];
};
#[doc = " Represents a data sample."]
pub type z_loaned_sample_t = _z_sample_t;
#[doc = " Represents a data sample."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_sample_t {
    pub _this: z_owned_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_sample_t"][::std::mem::size_of::<z_moved_sample_t>() - 224usize];
    ["Alignment of z_moved_sample_t"][::std::mem::align_of::<z_moved_sample_t>() - 8usize];
    ["Offset of field: z_moved_sample_t::_this"]
        [::std::mem::offset_of!(z_moved_sample_t, _this) - 0usize];
};
#[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_hello_t {
    #[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
    pub _val: _z_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_hello_t"][::std::mem::size_of::<z_owned_hello_t>() - 56usize];
    ["Alignment of z_owned_hello_t"][::std::mem::align_of::<z_owned_hello_t>() - 8usize];
    ["Offset of field: z_owned_hello_t::_val"]
        [::std::mem::offset_of!(z_owned_hello_t, _val) - 0usize];
};
#[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
pub type z_loaned_hello_t = _z_hello_t;
#[doc = " Represents the content of a `hello` message returned by a zenoh entity as a reply to a `scout` message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_hello_t {
    pub _this: z_owned_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_hello_t"][::std::mem::size_of::<z_moved_hello_t>() - 56usize];
    ["Alignment of z_moved_hello_t"][::std::mem::align_of::<z_moved_hello_t>() - 8usize];
    ["Offset of field: z_moved_hello_t::_this"]
        [::std::mem::offset_of!(z_moved_hello_t, _this) - 0usize];
};
#[doc = " Represents the reply to a query."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_owned_reply_t {
    #[doc = " Represents the reply to a query."]
    pub _val: _z_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_reply_t"][::std::mem::size_of::<z_owned_reply_t>() - 248usize];
    ["Alignment of z_owned_reply_t"][::std::mem::align_of::<z_owned_reply_t>() - 8usize];
    ["Offset of field: z_owned_reply_t::_val"]
        [::std::mem::offset_of!(z_owned_reply_t, _val) - 0usize];
};
#[doc = " Represents the reply to a query."]
pub type z_loaned_reply_t = _z_reply_t;
#[doc = " Represents the reply to a query."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_moved_reply_t {
    pub _this: z_owned_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_reply_t"][::std::mem::size_of::<z_moved_reply_t>() - 248usize];
    ["Alignment of z_moved_reply_t"][::std::mem::align_of::<z_moved_reply_t>() - 8usize];
    ["Offset of field: z_moved_reply_t::_this"]
        [::std::mem::offset_of!(z_moved_reply_t, _this) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_string_array_t {
    #[doc = " Represents an array of non null-terminated string."]
    pub _val: _z_string_svec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_string_array_t"][::std::mem::size_of::<z_owned_string_array_t>() - 32usize];
    ["Alignment of z_owned_string_array_t"]
        [::std::mem::align_of::<z_owned_string_array_t>() - 8usize];
    ["Offset of field: z_owned_string_array_t::_val"]
        [::std::mem::offset_of!(z_owned_string_array_t, _val) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
pub type z_loaned_string_array_t = _z_string_svec_t;
#[doc = " Represents an array of non null-terminated string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_string_array_t {
    pub _this: z_owned_string_array_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_string_array_t"][::std::mem::size_of::<z_moved_string_array_t>() - 32usize];
    ["Alignment of z_moved_string_array_t"]
        [::std::mem::align_of::<z_moved_string_array_t>() - 8usize];
    ["Offset of field: z_moved_string_array_t::_this"]
        [::std::mem::offset_of!(z_moved_string_array_t, _this) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
pub type z_closure_drop_callback_t = _z_drop_handler_t;
pub type z_closure_sample_callback_t = _z_closure_sample_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_sample_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_sample_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_sample_t"][::std::mem::size_of::<_z_closure_sample_t>() - 24usize];
    ["Alignment of _z_closure_sample_t"][::std::mem::align_of::<_z_closure_sample_t>() - 8usize];
    ["Offset of field: _z_closure_sample_t::context"]
        [::std::mem::offset_of!(_z_closure_sample_t, context) - 0usize];
    ["Offset of field: _z_closure_sample_t::call"]
        [::std::mem::offset_of!(_z_closure_sample_t, call) - 8usize];
    ["Offset of field: _z_closure_sample_t::drop"]
        [::std::mem::offset_of!(_z_closure_sample_t, drop) - 16usize];
};
#[doc = " Represents the sample closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_sample_t {
    #[doc = " Represents the sample closure."]
    pub _val: _z_closure_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_sample_t"]
        [::std::mem::size_of::<z_owned_closure_sample_t>() - 24usize];
    ["Alignment of z_owned_closure_sample_t"]
        [::std::mem::align_of::<z_owned_closure_sample_t>() - 8usize];
    ["Offset of field: z_owned_closure_sample_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_sample_t, _val) - 0usize];
};
#[doc = " Represents the sample closure."]
pub type z_loaned_closure_sample_t = _z_closure_sample_t;
#[doc = " Represents the sample closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_sample_t {
    pub _this: z_owned_closure_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_sample_t"]
        [::std::mem::size_of::<z_moved_closure_sample_t>() - 24usize];
    ["Alignment of z_moved_closure_sample_t"]
        [::std::mem::align_of::<z_moved_closure_sample_t>() - 8usize];
    ["Offset of field: z_moved_closure_sample_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_sample_t, _this) - 0usize];
};
#[doc = " Represents the sample closure."]
pub type z_closure_query_callback_t = _z_closure_query_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_query_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_query_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_query_t"][::std::mem::size_of::<_z_closure_query_t>() - 24usize];
    ["Alignment of _z_closure_query_t"][::std::mem::align_of::<_z_closure_query_t>() - 8usize];
    ["Offset of field: _z_closure_query_t::context"]
        [::std::mem::offset_of!(_z_closure_query_t, context) - 0usize];
    ["Offset of field: _z_closure_query_t::call"]
        [::std::mem::offset_of!(_z_closure_query_t, call) - 8usize];
    ["Offset of field: _z_closure_query_t::drop"]
        [::std::mem::offset_of!(_z_closure_query_t, drop) - 16usize];
};
#[doc = " Represents the query callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_query_t {
    #[doc = " Represents the query callback closure."]
    pub _val: _z_closure_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_query_t"][::std::mem::size_of::<z_owned_closure_query_t>() - 24usize];
    ["Alignment of z_owned_closure_query_t"]
        [::std::mem::align_of::<z_owned_closure_query_t>() - 8usize];
    ["Offset of field: z_owned_closure_query_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_query_t, _val) - 0usize];
};
#[doc = " Represents the query callback closure."]
pub type z_loaned_closure_query_t = _z_closure_query_t;
#[doc = " Represents the query callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_query_t {
    pub _this: z_owned_closure_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_query_t"][::std::mem::size_of::<z_moved_closure_query_t>() - 24usize];
    ["Alignment of z_moved_closure_query_t"]
        [::std::mem::align_of::<z_moved_closure_query_t>() - 8usize];
    ["Offset of field: z_moved_closure_query_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_query_t, _this) - 0usize];
};
#[doc = " Represents the query callback closure."]
pub type z_closure_reply_callback_t = _z_closure_reply_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_reply_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_reply_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_reply_t"][::std::mem::size_of::<_z_closure_reply_t>() - 24usize];
    ["Alignment of _z_closure_reply_t"][::std::mem::align_of::<_z_closure_reply_t>() - 8usize];
    ["Offset of field: _z_closure_reply_t::context"]
        [::std::mem::offset_of!(_z_closure_reply_t, context) - 0usize];
    ["Offset of field: _z_closure_reply_t::call"]
        [::std::mem::offset_of!(_z_closure_reply_t, call) - 8usize];
    ["Offset of field: _z_closure_reply_t::drop"]
        [::std::mem::offset_of!(_z_closure_reply_t, drop) - 16usize];
};
#[doc = " Represents the query reply callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_reply_t {
    #[doc = " Represents the query reply callback closure."]
    pub _val: _z_closure_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_reply_t"][::std::mem::size_of::<z_owned_closure_reply_t>() - 24usize];
    ["Alignment of z_owned_closure_reply_t"]
        [::std::mem::align_of::<z_owned_closure_reply_t>() - 8usize];
    ["Offset of field: z_owned_closure_reply_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_reply_t, _val) - 0usize];
};
#[doc = " Represents the query reply callback closure."]
pub type z_loaned_closure_reply_t = _z_closure_reply_t;
#[doc = " Represents the query reply callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_reply_t {
    pub _this: z_owned_closure_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_reply_t"][::std::mem::size_of::<z_moved_closure_reply_t>() - 24usize];
    ["Alignment of z_moved_closure_reply_t"]
        [::std::mem::align_of::<z_moved_closure_reply_t>() - 8usize];
    ["Offset of field: z_moved_closure_reply_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_reply_t, _this) - 0usize];
};
#[doc = " Represents the query reply callback closure."]
pub type z_closure_hello_callback_t = ::std::option::Option<
    unsafe extern "C" fn(hello: *mut z_loaned_hello_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_hello_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_hello_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_hello_t"][::std::mem::size_of::<_z_closure_hello_t>() - 24usize];
    ["Alignment of _z_closure_hello_t"][::std::mem::align_of::<_z_closure_hello_t>() - 8usize];
    ["Offset of field: _z_closure_hello_t::context"]
        [::std::mem::offset_of!(_z_closure_hello_t, context) - 0usize];
    ["Offset of field: _z_closure_hello_t::call"]
        [::std::mem::offset_of!(_z_closure_hello_t, call) - 8usize];
    ["Offset of field: _z_closure_hello_t::drop"]
        [::std::mem::offset_of!(_z_closure_hello_t, drop) - 16usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_hello_t {
    #[doc = " Represents the Zenoh ID callback closure."]
    pub _val: _z_closure_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_hello_t"][::std::mem::size_of::<z_owned_closure_hello_t>() - 24usize];
    ["Alignment of z_owned_closure_hello_t"]
        [::std::mem::align_of::<z_owned_closure_hello_t>() - 8usize];
    ["Offset of field: z_owned_closure_hello_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_hello_t, _val) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_loaned_closure_hello_t = _z_closure_hello_t;
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_hello_t {
    pub _this: z_owned_closure_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_hello_t"][::std::mem::size_of::<z_moved_closure_hello_t>() - 24usize];
    ["Alignment of z_moved_closure_hello_t"]
        [::std::mem::align_of::<z_moved_closure_hello_t>() - 8usize];
    ["Offset of field: z_moved_closure_hello_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_hello_t, _this) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_closure_zid_callback_t = ::std::option::Option<
    unsafe extern "C" fn(id: *const z_id_t, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_zid_t {
    pub context: *mut ::std::os::raw::c_void,
    pub call: z_closure_zid_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_zid_t"][::std::mem::size_of::<_z_closure_zid_t>() - 24usize];
    ["Alignment of _z_closure_zid_t"][::std::mem::align_of::<_z_closure_zid_t>() - 8usize];
    ["Offset of field: _z_closure_zid_t::context"]
        [::std::mem::offset_of!(_z_closure_zid_t, context) - 0usize];
    ["Offset of field: _z_closure_zid_t::call"]
        [::std::mem::offset_of!(_z_closure_zid_t, call) - 8usize];
    ["Offset of field: _z_closure_zid_t::drop"]
        [::std::mem::offset_of!(_z_closure_zid_t, drop) - 16usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_zid_t {
    #[doc = " Represents the Zenoh ID callback closure."]
    pub _val: _z_closure_zid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_zid_t"][::std::mem::size_of::<z_owned_closure_zid_t>() - 24usize];
    ["Alignment of z_owned_closure_zid_t"]
        [::std::mem::align_of::<z_owned_closure_zid_t>() - 8usize];
    ["Offset of field: z_owned_closure_zid_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_zid_t, _val) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_loaned_closure_zid_t = _z_closure_zid_t;
#[doc = " Represents the Zenoh ID callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_zid_t {
    pub _this: z_owned_closure_zid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_zid_t"][::std::mem::size_of::<z_moved_closure_zid_t>() - 24usize];
    ["Alignment of z_moved_closure_zid_t"]
        [::std::mem::align_of::<z_moved_closure_zid_t>() - 8usize];
    ["Offset of field: z_moved_closure_zid_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_zid_t, _this) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_closure_matching_status_callback_t = _z_closure_matching_status_callback_t;
#[doc = " Represents the matching status callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_matching_status_t {
    #[doc = " Represents the matching status callback closure."]
    pub _val: _z_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_matching_status_t"]
        [::std::mem::size_of::<z_owned_closure_matching_status_t>() - 24usize];
    ["Alignment of z_owned_closure_matching_status_t"]
        [::std::mem::align_of::<z_owned_closure_matching_status_t>() - 8usize];
    ["Offset of field: z_owned_closure_matching_status_t::_val"]
        [::std::mem::offset_of!(z_owned_closure_matching_status_t, _val) - 0usize];
};
#[doc = " Represents the matching status callback closure."]
pub type z_loaned_closure_matching_status_t = _z_closure_matching_status_t;
#[doc = " Represents the matching status callback closure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_matching_status_t {
    pub _this: z_owned_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_matching_status_t"]
        [::std::mem::size_of::<z_moved_closure_matching_status_t>() - 24usize];
    ["Alignment of z_moved_closure_matching_status_t"]
        [::std::mem::align_of::<z_moved_closure_matching_status_t>() - 8usize];
    ["Offset of field: z_moved_closure_matching_status_t::_this"]
        [::std::mem::offset_of!(z_moved_closure_matching_status_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_liveliness_token_t {
    pub _id: u32,
    pub _key: _z_keyexpr_t,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_liveliness_token_t"][::std::mem::size_of::<_z_liveliness_token_t>() - 72usize];
    ["Alignment of _z_liveliness_token_t"]
        [::std::mem::align_of::<_z_liveliness_token_t>() - 8usize];
    ["Offset of field: _z_liveliness_token_t::_id"]
        [::std::mem::offset_of!(_z_liveliness_token_t, _id) - 0usize];
    ["Offset of field: _z_liveliness_token_t::_key"]
        [::std::mem::offset_of!(_z_liveliness_token_t, _key) - 8usize];
    ["Offset of field: _z_liveliness_token_t::_zn"]
        [::std::mem::offset_of!(_z_liveliness_token_t, _zn) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_liveliness_token_t {
    pub _val: _z_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_liveliness_token_t"]
        [::std::mem::size_of::<z_owned_liveliness_token_t>() - 72usize];
    ["Alignment of z_owned_liveliness_token_t"]
        [::std::mem::align_of::<z_owned_liveliness_token_t>() - 8usize];
    ["Offset of field: z_owned_liveliness_token_t::_val"]
        [::std::mem::offset_of!(z_owned_liveliness_token_t, _val) - 0usize];
};
pub type z_loaned_liveliness_token_t = _z_liveliness_token_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_liveliness_token_t {
    pub _this: z_owned_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_liveliness_token_t"]
        [::std::mem::size_of::<z_moved_liveliness_token_t>() - 72usize];
    ["Alignment of z_moved_liveliness_token_t"]
        [::std::mem::align_of::<z_moved_liveliness_token_t>() - 8usize];
    ["Offset of field: z_moved_liveliness_token_t::_this"]
        [::std::mem::offset_of!(z_moved_liveliness_token_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_liveliness_token_null(obj: *mut z_owned_liveliness_token_t);
}
unsafe extern "C" {
    pub fn z_internal_liveliness_token_check(obj: *const z_owned_liveliness_token_t) -> bool;
}
unsafe extern "C" {
    pub fn z_liveliness_token_loan(
        obj: *const z_owned_liveliness_token_t,
    ) -> *const z_loaned_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_loan_mut(
        obj: *mut z_owned_liveliness_token_t,
    ) -> *mut z_loaned_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_move(
        obj: *mut z_owned_liveliness_token_t,
    ) -> *mut z_moved_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_take(
        obj: *mut z_owned_liveliness_token_t,
        src: *mut z_moved_liveliness_token_t,
    );
}
unsafe extern "C" {
    pub fn z_liveliness_token_drop(obj: *mut z_moved_liveliness_token_t);
}
unsafe extern "C" {
    pub fn z_liveliness_token_take_from_loaned(
        dst: *mut z_owned_liveliness_token_t,
        src: *mut z_loaned_liveliness_token_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_clone(
        obj: *mut z_owned_liveliness_token_t,
        src: *const z_loaned_liveliness_token_t,
    ) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_declare_token()`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_token_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_token_options_t"]
        [::std::mem::size_of::<z_liveliness_token_options_t>() - 1usize];
    ["Alignment of z_liveliness_token_options_t"]
        [::std::mem::align_of::<z_liveliness_token_options_t>() - 1usize];
    ["Offset of field: z_liveliness_token_options_t::__dummy"]
        [::std::mem::offset_of!(z_liveliness_token_options_t, __dummy) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs default value for :c:type:`z_liveliness_token_options_t`."]
    pub fn z_liveliness_token_options_default(
        options: *mut z_liveliness_token_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs and declares a liveliness token on the network.\n\n Liveliness token subscribers on an intersecting key expression will receive a PUT sample when connectivity\n is achieved, and a DELETE sample if it's lost.\n\n Parameters:\n   zs: A Zenos session to declare the liveliness token.\n   token: An uninitialized memory location where liveliness token will be constructed.\n   keyexpr: A keyexpr to declare a liveliess token for.\n   options: Liveliness token declaration options.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_token(
        zs: *const z_loaned_session_t,
        token: *mut z_owned_liveliness_token_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_liveliness_token_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclare a liveliness token, notifying subscribers of its destruction.\n\n Parameters:\n   token: Moved :c:type:`z_owned_liveliness_token_t` to undeclare.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_undeclare_token(token: *mut z_moved_liveliness_token_t) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_declare_subscriber()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_subscriber_options_t {
    pub history: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_subscriber_options_t"]
        [::std::mem::size_of::<z_liveliness_subscriber_options_t>() - 1usize];
    ["Alignment of z_liveliness_subscriber_options_t"]
        [::std::mem::align_of::<z_liveliness_subscriber_options_t>() - 1usize];
    ["Offset of field: z_liveliness_subscriber_options_t::history"]
        [::std::mem::offset_of!(z_liveliness_subscriber_options_t, history) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constucts default value for :c:type:`z_liveliness_subscriber_options_t`."]
    pub fn z_liveliness_subscriber_options_default(
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a subscriber on liveliness tokens that intersect `keyexpr`.\n\n Parameters:\n   zs: The Zenoh session.\n   sub: An uninitialized memory location where subscriber will be constructed.\n   keyexpr: The key expression to subscribe to.\n   callback: The callback function that will be called each time a liveliness token status is changed.\n   options: The options to be passed to the liveliness subscriber declaration.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_subscriber(
        zs: *const z_loaned_session_t,
        sub: *mut z_owned_subscriber_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background subscriber on liveliness tokens that intersect `keyexpr`.\n Subscriber callback will be called to process the messages, until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: The Zenoh session.\n   keyexpr: The key expression to subscribe to.\n   callback: The callback function that will be called each time a liveliness token status is changed.\n   options: The options to be passed to the liveliness subscriber declaration.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_background_subscriber(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_get()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_get_options_t {
    pub timeout_ms: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_get_options_t"]
        [::std::mem::size_of::<z_liveliness_get_options_t>() - 8usize];
    ["Alignment of z_liveliness_get_options_t"]
        [::std::mem::align_of::<z_liveliness_get_options_t>() - 8usize];
    ["Offset of field: z_liveliness_get_options_t::timeout_ms"]
        [::std::mem::offset_of!(z_liveliness_get_options_t, timeout_ms) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs default value :c:type:`z_liveliness_get_options_t`."]
    pub fn z_liveliness_get_options_default(options: *mut z_liveliness_get_options_t)
        -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Queries liveliness tokens currently on the network with a key expression intersecting with `keyexpr`.\n\n Parameters:\n   zs: The Zenoh session.\n   keyexpr: The key expression to query liveliness tokens for.\n   callback: The callback function that will be called for each received reply.\n   options: Additional options for the liveliness get operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_get(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_liveliness_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Just some bytes.\n\n Constant alias for string: `\"zenoh/bytes\"`.\n\n This encoding supposes that the payload was created with c:func:`z_bytes_from_buf`, c:func:`z_bytes_from_slice` or\n similar functions and its data can be accessed via c:func:`z_bytes_to_slice`."]
    pub fn z_encoding_zenoh_bytes() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A UTF-8 string.\n Constant alias for string: `\"zenoh/string\"`.\n\n This encoding supposes that the payload was created with c:func:`z_bytes_from_str`, c:func:`z_bytes_from_string` or\n similar functions and its data can be accessed via c:func:`z_bytes_to_string`."]
    pub fn z_encoding_zenoh_string() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Zenoh serialized data.\n Constant alias for string: `\"zenoh/serialized\"`.\n\n This encoding supposes that the payload was created with serialization functions.\n The `schema` field may contain the details of serialziation format."]
    pub fn z_encoding_zenoh_serialized() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific stream of bytes.\n Constant alias for string: `\"application/octet-stream\"`."]
    pub fn z_encoding_application_octet_stream() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A textual file.\n Constant alias for string: `\"text/plain\"`."]
    pub fn z_encoding_text_plain() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON data intended to be consumed by an application.\n Constant alias for string: `\"application/json\"`."]
    pub fn z_encoding_application_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON data intended to be human readable.\n Constant alias for string: `\"text/json\"`."]
    pub fn z_encoding_text_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Common Data Representation (CDR)-encoded data.\n Constant alias for string: `\"application/cdr\"`."]
    pub fn z_encoding_application_cdr() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Concise Binary Object Representation (CBOR)-encoded data.\n Constant alias for string: `\"application/cbor\"`."]
    pub fn z_encoding_application_cbor() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " YAML data intended to be consumed by an application.\n Constant alias for string: `\"application/yaml\"`."]
    pub fn z_encoding_application_yaml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " YAML data intended to be human readable.\n Constant alias for string: `\"text/yaml\"`."]
    pub fn z_encoding_text_yaml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON5 encoded data that are human readable.\n Constant alias for string: `\"text/json5\"`."]
    pub fn z_encoding_text_json5() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Python object serialized using `pickle <https://docs.python.org/3/library/pickle.html>`_.\n Constant alias for string: `\"application/python-serialized-object\"`."]
    pub fn z_encoding_application_python_serialized_object() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific protobuf-encoded data.\n Constant alias for string: `\"application/protobuf\"`."]
    pub fn z_encoding_application_protobuf() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Java serialized object.\n Constant alias for string: `\"application/java-serialized-object\"`."]
    pub fn z_encoding_application_java_serialized_object() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An `openmetrics <https://github.com/OpenObservability/OpenMetrics>`_ data, commonly used by\n `Prometheus <https://prometheus.io/>`_.\n Constant alias for string: `\"application/openmetrics-text\"`."]
    pub fn z_encoding_application_openmetrics_text() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Portable Network Graphics (PNG) image.\n Constant alias for string: `\"image/png\"`."]
    pub fn z_encoding_image_png() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Joint Photographic Experts Group (JPEG) image.\n Constant alias for string: `\"image/jpeg\"`."]
    pub fn z_encoding_image_jpeg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Graphics Interchange Format (GIF) image.\n Constant alias for string: `\"image/gif\"`."]
    pub fn z_encoding_image_gif() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A BitMap (BMP) image.\n Constant alias for string: `\"image/bmp\"`."]
    pub fn z_encoding_image_bmp() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Web Portable (WebP) image.\n Constant alias for string: `\"image/webp\"`."]
    pub fn z_encoding_image_webp() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An XML file intended to be consumed by an application.\n Constant alias for string: `\"application/xml\"`."]
    pub fn z_encoding_application_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An encoded list of tuples, each consisting of a name and a value.\n Constant alias for string: `\"application/x-www-form-urlencoded\"`."]
    pub fn z_encoding_application_x_www_form_urlencoded() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An HTML file.\n Constant alias for string: `\"text/html\"`."]
    pub fn z_encoding_text_html() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An XML file that is human-readable.\n Constant alias for string: `\"text/xml\"`."]
    pub fn z_encoding_text_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A CSS file.\n Constant alias for string: `\"text/css\"`."]
    pub fn z_encoding_text_css() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JavaScript file.\n Constant alias for string: `\"text/javascript\"`."]
    pub fn z_encoding_text_javascript() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Markdown file.\n Constant alias for string: `\"text/markdown\"`."]
    pub fn z_encoding_text_markdown() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A CSV file.\n Constant alias for string: `\"text/csv\"`."]
    pub fn z_encoding_text_csv() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific SQL query.\n Constant alias for string: `\"application/sql\"`."]
    pub fn z_encoding_application_sql() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Constrained Application Protocol (CoAP) data intended for CoAP-to-HTTP and HTTP-to-CoAP proxies.\n Constant alias for string: `\"application/coap-payload\"`."]
    pub fn z_encoding_application_coap_payload() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Defines a JSON document structure for expressing a sequence of operations to apply to a JSON document.\n Constant alias for string: `\"application/json-patch+json\"`."]
    pub fn z_encoding_application_json_patch_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8.\n Constant alias for string: `\"application/json-seq\"`."]
    pub fn z_encoding_application_json_seq() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSONPath defines a string syntax for selecting and extracting JSON values from within a given JSON value.\n Constant alias for string: `\"application/jsonpath\"`."]
    pub fn z_encoding_application_jsonpath() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSON Web Token (JWT).\n Constant alias for string: `\"application/jwt\"`."]
    pub fn z_encoding_application_jwt() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific MPEG-4 encoded data, either audio or video.\n Constant alias for string: `\"application/mp4\"`."]
    pub fn z_encoding_application_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A SOAP 1.2 message serialized as XML 1.0.\n Constant alias for string: `\"application/soap+xml\"`."]
    pub fn z_encoding_application_soap_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A YANG-encoded data commonly used by the Network Configuration Protocol (NETCONF).\n Constant alias for string: `\"application/yang\"`."]
    pub fn z_encoding_application_yang() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A MPEG-4 Advanced Audio Coding (AAC) media.\n Constant alias for string: `\"audio/aac\"`."]
    pub fn z_encoding_audio_aac() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Free Lossless Audio Codec (FLAC) media.\n Constant alias for string: `\"audio/flac\"`."]
    pub fn z_encoding_audio_flac() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An audio codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.\n Constant alias for string: `\"audio/mp4\"`."]
    pub fn z_encoding_audio_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An Ogg-encapsulated audio stream.\n Constant alias for string: `\"audio/ogg\"`."]
    pub fn z_encoding_audio_ogg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Vorbis-encoded audio stream.\n Constant alias for string: `\"audio/vorbis\"`."]
    pub fn z_encoding_audio_vorbis() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h261-encoded video stream.\n Constant alias for string: `\"video/h261\"`."]
    pub fn z_encoding_video_h261() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h263-encoded video stream.\n Constant alias for string: `\"video/h263\"`."]
    pub fn z_encoding_video_h263() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h264-encoded video stream.\n Constant alias for string: `\"video/h264\"`."]
    pub fn z_encoding_video_h264() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h265-encoded video stream.\n Constant alias for string: `\"video/h265\"`."]
    pub fn z_encoding_video_h265() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h266-encoded video stream.\n Constant alias for string: `\"video/h266\"`."]
    pub fn z_encoding_video_h266() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A video codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.\n Constant alias for string: `\"video/mp4\"`."]
    pub fn z_encoding_video_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An Ogg-encapsulated video stream.\n Constant alias for string: `\"video/ogg\"`."]
    pub fn z_encoding_video_ogg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An uncompressed, studio-quality video stream.\n Constant alias for string: `\"video/raw\"`."]
    pub fn z_encoding_video_raw() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A VP8-encoded video stream.\n Constant alias for string: `\"video/vp8\"`."]
    pub fn z_encoding_video_vp8() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A VP9-encoded video stream.\n Constant alias for string: `\"video/vp9\"`."]
    pub fn z_encoding_video_vp9() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Returns a loaned default `z_loaned_encoding_t`."]
    pub fn z_encoding_loan_default() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_string_t` by wrapping a ``const char *`` string.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n   value: Pointer to a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_string_from_str(
        str_: *mut z_view_string_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_string_t` by wrapping a ``const char *`` substring.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n   value: Pointer to a null terminated string.\n   len: Size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_string_from_substr(
        str_: *mut z_view_string_t,
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a null-terminated string.\n It is a loaned key expression that aliases ``name``.\n This function will fail if the string is not in canon form.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_str(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a null-terminated string.\n It is a loaned key expression that aliases ``name``.\n Input key expression is not checked for correctness.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string."]
    pub fn z_view_keyexpr_from_str_unchecked(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_keyexpr_t` from a null-terminated string with auto canonization.\n It is a loaned key expression that aliases ``name``.\n The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying len.\n May SEGFAULT if `name` is NULL or lies in read-only memory (as values initialized with string literals do).\n `name` must outlive the constructed key expression.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_str_autocanonize(
        keyexpr: *mut z_view_keyexpr_t,
        name: *mut ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` by aliasing a substring.\n It is a loaned key expression that aliases ``name``.\n This function will fail if the string is not in canon form.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_substr(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_keyexpr_t` from a substring with auto canonization.\n It is a loaned key expression that aliases ``name``.\n The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying len.\n May SEGFAULT if `name` is NULL or lies in read-only memory (as values initialized with string literals do).\n `name` must outlive the constructed key expression.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Pointer to the size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_substr_autocanonize(
        keyexpr: *mut z_view_keyexpr_t,
        name: *mut ::std::os::raw::c_char,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a substring.\n It is a loaned key expression that aliases ``name``.\n Input key expression is not checked for correctness.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Size of the string."]
    pub fn z_view_keyexpr_from_substr_unchecked(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Gets a string view from a :c:type:`z_keyexpr_t`.\n\n Parameters:\n   keyexpr: Pointer to a loaned instance of :c:type:`z_keyexpr_t`.\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_as_view_string(
        keyexpr: *const z_loaned_keyexpr_t,
        str_: *mut z_view_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs key expression by concatenation of key expression in `left` with a string in `right`.\n\n To avoid odd behaviors, concatenating a key expression starting with `*` to one ending with `*` is forbidden by this\n operation, as this would extremely likely cause bugs.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` to keyexpr to concatenate to.\n   right: Pointer to the start of the substring that will be concatenated.\n   len: Length of the substring to concatenate.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_concat(
        key: *mut z_owned_keyexpr_t,
        left: *const z_loaned_keyexpr_t,
        right: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs key expression by performing path-joining (automatically inserting '/'). The resulting key expression is\n automatically canonized.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` to the left part of the resulting key expression.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` to the right part of the resulting key expression.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_join(
        key: *mut z_owned_keyexpr_t,
        left: *const z_loaned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the relation between `left` and `right` from the `left`'s point of view.\n\n Note that this is slower than `z_keyexpr_intersects` and `keyexpr_includes`, so you should favor these methods for\n most applications.\n\n Parameters:\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` representing left key expression.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` representing right key expression.\n\n Return:\n   Relation between `left` and `right` from the `left`'s point of view."]
    pub fn z_keyexpr_relation_to(
        left: *const z_loaned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_keyexpr_intersection_level_t;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr is valid and in canonical form.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a non-null terminated string.\n   len: Number of characters in ``start``.\n\n Return:\n   ``0`` if the passed string is a valid (and canon) key expression, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_is_canon(start: *const ::std::os::raw::c_char, len: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Canonizes of a given keyexpr in string representation.\n The canonization is performed over the passed string, possibly shortening it by modifying ``len``.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a non-null terminated string.\n   len: Number of characters in ``start``.\n\n Return:\n   ``0`` if canonization successful, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_canonize(start: *mut ::std::os::raw::c_char, len: *mut usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Canonizes of a given keyexpr in string representation.\n The canonization is performed over the passed string, possibly shortening it by setting null at the end.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a null terminated string.\n\n Return:\n   ``0`` if canonization successful, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_canonize_null_terminated(start: *mut ::std::os::raw::c_char) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr contains another keyexpr in its set.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if ``l`` includes ``r``, i.e. the set defined by ``l`` contains every key belonging to the set\n   defined by ``r``. Otherwise, returns ``false``."]
    pub fn z_keyexpr_includes(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr intersects with another keyexpr.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if keyexprs intersect, i.e. there exists at least one key which is contained in both of the\n   sets defined by ``l`` and ``r``. Otherwise, returns ``false``."]
    pub fn z_keyexpr_intersects(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t)
        -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if two keyexpr are equal.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if both ``l`` and ``r`` are equal. Otherwise, returns  ``false``."]
    pub fn z_keyexpr_equals(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a new, zenoh-allocated, default configuration.\n It consists in a default set of properties for zenoh session configuration.\n\n Parameters:\n   config: Pointer to uninitialized :c:type:`z_owned_config_t`.\n\n Return:\n   ``0`` in case of success, or a ``negative value`` otherwise."]
    pub fn z_config_default(config: *mut z_owned_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_encoding_t` from a null terminated string.\n\n Parameters:\n   encoding: Pointer to an uninitialized :c:type:`z_owned_encoding_t`.\n   s: Pointer to the null terminated string to use.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_from_str(
        encoding: *mut z_owned_encoding_t,
        s: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_encoding_t` from a null terminated string.\n\n Parameters:\n   encoding: Pointer to an uninitialized :c:type:`z_owned_encoding_t`.\n   s: Pointer to the string to use.\n   len: Number of characters from the string s to use.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_from_substr(
        encoding: *mut z_owned_encoding_t,
        s: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sets a schema to this encoding from a null-terminated string. Zenoh does not define what a schema is and its\n semantics is left to the implementer. E.g. a common schema for `text/plain` encoding is `utf-8`.\n\n Parameters:\n   encoding: Pointer to initialized :c:type:`z_loaned_encoding_t`.\n   schema: Pointer to the null terminated string to use as a schema.\n\n Return:\n   ``0`` in case of success,``negative value`` otherwise."]
    pub fn z_encoding_set_schema_from_str(
        encoding: *mut z_loaned_encoding_t,
        schema: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sets a schema to this encoding from a substring. Zenoh does not define what a schema is and its semantics is left\n to the implementer. E.g. a common schema for `text/plain` encoding is `utf-8`.\n\n Parameters:\n   encoding: Pointer to initialized :c:type:`z_loaned_encoding_t`.\n   schema: Pointer to the substring start.\n   len: Number of characters to consider.\n\n Return:\n   ``0`` if in case of success,``negative value`` otherwise."]
    pub fn z_encoding_set_schema_from_substr(
        encoding: *mut z_loaned_encoding_t,
        schema: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a string from a :c:type:`z_loaned_encoding_t`.\n\n Parameters:\n   encoding: Pointer to the :c:type:`z_loaned_encoding_t` to use.\n   string: Pointer to an uninitialized :c:type:`z_owned_string_t` to store the string.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_to_string(
        encoding: *const z_loaned_encoding_t,
        string: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if two encodings are equal.\n\n Parameters:\n   left: Pointer to the first :c:type:`z_loaned_encoding_t` to compare.\n   right: Pointer to the second :c:type:`z_loaned_encoding_t` to compare.\n\n Return:\n   ``true`` if `left` equals `right`, ``false`` otherwise."]
    pub fn z_encoding_equals(
        left: *const z_loaned_encoding_t,
        right: *const z_loaned_encoding_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the bytes data from a reply error payload by aliasing it.\n\n Parameters:\n   reply_err: Pointer to a :c:type:`z_loaned_reply_err_t` to get data from.\n\n Return:\n   Pointer to the data as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_reply_err_payload(reply_err: *const z_loaned_reply_err_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a reply error encoding by aliasing it.\n\n Parameters:\n   reply_err: Pointer to the :c:type:`z_loaned_reply_err_t` to get the encoding from.\n\n Return:\n   Pointer to the encoding as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_reply_err_encoding(
        reply_err: *const z_loaned_reply_err_t,
    ) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_slice_t` by copying a buffer into it.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`.\n   data: Pointer to the data that will be copied into slice.\n   len: Number of bytes to copy.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_slice_copy_from_buf(
        slice: *mut z_owned_slice_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_slice_t` by transferring ownership over a data to it.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`.\n   data: Pointer to the data to be owned by `slice`.\n   len: Number of bytes in `data`.\n   deleter: A thread-safe delete function to free the `data`. Will be called once when `slice` is dropped.\n     Can be NULL in the case where `data` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_slice_from_buf(
        slice: *mut z_owned_slice_t,
        data: *mut u8,
        len: usize,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_slice_t`.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_view_slice_t`.\n   data: Pointer to the data to be pointed by `slice`.\n   len: Number of bytes in `data`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_view_slice_from_buf(
        slice: *mut z_view_slice_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds an empty :c:type:`z_owned_slice_t`.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`."]
    pub fn z_slice_empty(slice: *mut z_owned_slice_t);
}
unsafe extern "C" {
    #[doc = " Gets date pointer of a bytes array.\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to get data from.\n\n Return:\n   The data pointer."]
    pub fn z_slice_data(slice: *const z_loaned_slice_t) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Gets the total number of bytes in a bytes array.\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to get length from.\n\n Return:\n   The number of bytes."]
    pub fn z_slice_len(slice: *const z_loaned_slice_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Checks if slice is empty\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to check.\n\n Return:\n   ``true`` if the container is empty, ``false`` otherwise."]
    pub fn z_slice_is_empty(slice: *const z_loaned_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_slice_t`\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n   dst: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the decoded slice.\n\n Return:\n   ``0`` if decode is successful, or a ``negative value`` otherwise."]
    pub fn z_bytes_to_slice(
        bytes: *const z_loaned_bytes_t,
        dst: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_string_t`\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the decoded string.\n\n Return:\n   ``0`` if decode is successful, or a ``negative value`` otherwise."]
    pub fn z_bytes_to_string(
        bytes: *const z_loaned_bytes_t,
        str_: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a slice into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded slice.\n   slice: Pointer to the slice to convert. The slice will be consumed upon function return.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *mut z_moved_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a slice into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded slice.\n   slice: Pointer to the slice to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the data to convert. Ownership is transferred to the `bytes`.\n   len: Number of bytes to consider.\n   deleter: A thread-safe delete function to free the `data`. Will be called once when `bytes` is dropped.\n     Can be NULL in the case where `data` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_buf(
        bytes: *mut z_owned_bytes_t,
        data: *mut u8,
        len: usize,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the data to convert.\n   len: Number of bytes to consider.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_buf(
        bytes: *mut z_owned_bytes_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts statically allocated constant data into a :c:type:`z_owned_bytes_t` by aliasing.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the statically allocated constant data to encode.\n   len: Number of bytes to consider.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_static_buf(
        bytes: *mut z_owned_bytes_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a string into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   s: Pointer to the string to convert. The string will be consumed upon function return.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_string(bytes: *mut z_owned_bytes_t, s: *mut z_moved_string_t)
        -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a string into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   s: Pointer to the string to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_string(
        bytes: *mut z_owned_bytes_t,
        s: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a null-terminated string into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the string to converts. Ownership is transferred to the `bytes`.\n   deleter: A thread-safe delete function to free the `value`. Will be called once when `bytes` is dropped.\n     Can be NULL in the case where `value` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_str(
        bytes: *mut z_owned_bytes_t,
        value: *mut ::std::os::raw::c_char,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                value: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a null-terminated string into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the string to converts.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a statically allocated constant null-terminated string into a :c:type:`z_owned_bytes_t` by aliasing.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the statically allocated constant string to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_static_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs an empty payload.\n\n Parameters:\n   bytes: Pointer to an unitialized :c:type:`z_loaned_bytes_t` instance."]
    pub fn z_bytes_empty(bytes: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Returns total number of bytes in the container.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n\n Return:\n   Number of the bytes in the container."]
    pub fn z_bytes_len(bytes: *const z_loaned_bytes_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Checks if container is empty\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n\n Return:\n   ``true`` if conainer is empty,  ``false`` otherwise."]
    pub fn z_bytes_is_empty(bytes: *const z_loaned_bytes_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns an iterator on raw bytes slices contained in the `z_loaned_bytes_t`.\n\n Zenoh may store data in non-contiguous regions of memory, this iterator\n then allows to access raw data directly without any attempt of deserializing it.\n Please note that no guarantee is provided on the internal memory layout.\n The only provided guarantee is on the bytes order that is preserved.\n\n Parameters:\n   bytes: Data to iterate over.\n\n Return:\n   The constructed :c:type:`z_bytes_slice_iterator_t`."]
    pub fn z_bytes_get_slice_iterator(bytes: *const z_loaned_bytes_t) -> z_bytes_slice_iterator_t;
}
unsafe extern "C" {
    #[doc = " Constructs :c:type:`z_view_slice_t` providing view to the next slice.\n\n Parameters:\n   iter: An iterator over slices of serialized data.\n   out: An uninitialized :c:type:`z_view_slice_t` that will contain next slice.\n\n Return:\n   ``false`` when iterator reaches the end,  ``true`` otherwise."]
    pub fn z_bytes_slice_iterator_next(
        iter: *mut z_bytes_slice_iterator_t,
        out: *mut z_view_slice_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns a reader for the `bytes`.\n\n The `bytes` should outlive the reader and should not be modified, while reader is in use.\n\n Parameters:\n   bytes: Data to read.\n\n Return:\n   The constructed :c:type:`z_bytes_reader_t`."]
    pub fn z_bytes_get_reader(bytes: *const z_loaned_bytes_t) -> z_bytes_reader_t;
}
unsafe extern "C" {
    #[doc = " Reads data into specified destination.\n\n Parameters:\n   reader: Data reader to read from.\n   dst: Buffer where the read data is written.\n   len: Maximum number of bytes to read.\n\n Return:\n   Number of bytes read. If return value is smaller than `len`, it means that the end of the data was reached."]
    pub fn z_bytes_reader_read(reader: *mut z_bytes_reader_t, dst: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Sets the `reader` position indicator for the payload to the value pointed to by offset.\n The new position is exactly `offset` bytes measured from the beginning of the payload if origin is `SEEK_SET`,\n from the current reader position if origin is `SEEK_CUR`, and from the end of the payload if origin is `SEEK_END`.\n\n Parameters:\n   reader: Data reader to reposition.\n   offset: New position ffset in bytes.\n   origin: Origin for the new position.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_reader_seek(
        reader: *mut z_bytes_reader_t,
        offset: i64,
        origin: ::std::os::raw::c_int,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the read position indicator.\n\n Parameters:\n   reader: Data reader to get position of.\n\n Return:\n   Read position indicator on success or -1L if failure occurs."]
    pub fn z_bytes_reader_tell(reader: *mut z_bytes_reader_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets number of bytes that can still be read.\n\n Parameters:\n   reader: Data reader.\n\n Return:\n   Number of bytes that can still be read."]
    pub fn z_bytes_reader_remaining(reader: *const z_bytes_reader_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Constructs an empty writer for payload.\n\n Parameters:\n   writer: An uninitialized memory location where writer is to be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_writer_empty(writer: *mut z_owned_bytes_writer_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Finishes writing and returns underlying bytes.\n\n Parameters:\n   writer: A data writer.\n   bytes: An uninitialized memory location where bytes is to be constructed."]
    pub fn z_bytes_writer_finish(writer: *mut z_moved_bytes_writer_t, bytes: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Writes `len` bytes from `src` into underlying :c:type:`z_loaned_bytes_t`.\n\n Parameters:\n   writer: A data writer.\n   src: Buffer to write from.\n   len: Number of bytes to write.\n\n Return:\n   ``0`` if write is successful, ``negative value`` otherwise."]
    pub fn z_bytes_writer_write_all(
        writer: *mut z_loaned_bytes_writer_t,
        src: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends bytes.\n This allows to compose a serialized data out of multiple `z_owned_bytes_t` that may point to different memory\n regions. Said in other terms, it allows to create a linear view on different memory regions without copy.\n\n Parameters:\n   writer: A data writer.\n   bytes: A data to append.\n\n Return:\n   ``0`` if write is successful, ``negative value`` otherwise."]
    pub fn z_bytes_writer_append(
        writer: *mut z_loaned_bytes_writer_t,
        bytes: *mut z_moved_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Create timestamp.\n\n Parameters:\n   ts: An uninitialized :c:type:`z_timestamp_t`.\n   zs: Pointer to a :c:type:`z_loaned_session_t` to get the id from.\n\n Return:\n   ``0`` if encode is successful, ``negative value`` otherwise (for example if RTC is not available on the system)."]
    pub fn z_timestamp_new(ts: *mut z_timestamp_t, zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns NTP64 time associated with this timestamp.\n\n Parameters:\n   ts: Pointer to the valid :c:type:`z_timestamp_t`.\n\n Return:\n   NTP64 time value"]
    pub fn z_timestamp_ntp64_time(ts: *const z_timestamp_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Returns id associated with this timestamp.\n\n Parameters:\n   ts: Pointer to the valid :c:type:`z_timestamp_t`.\n\n Return:\n   Associated id represented by c:type:`z_id_t`"]
    pub fn z_timestamp_id(ts: *const z_timestamp_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Creates an entity global id.\n\n Parameters:\n   gid: An uninitialized :c:type:`z_entity_global_id_t`.\n   zid: Pointer to a :c:type:`z_id_t` zenoh id.\n   eid: :c:type:`uint32_t` entity id."]
    pub fn z_entity_global_id_new(
        gid: *mut z_entity_global_id_t,
        zid: *const z_id_t,
        eid: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the entity id of the entity global id.\n\n Parameters:\n   gid: Pointer to the valid :c:type:`z_entity_global_id_t`.\n\n Return:\n   Entity id represented by c:type:`uint32_t`."]
    pub fn z_entity_global_id_eid(gid: *const z_entity_global_id_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Returns the zenoh id of entity global id.\n\n Parameters:\n   gid: Pointer to the valid :c:type:`z_entity_global_id_t`.\n\n Return:\n   Zenoh id represented by c:type:`z_id_t`."]
    pub fn z_entity_global_id_zid(gid: *const z_entity_global_id_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new source info.\n\n Parameters:\n   info: An uninitialized :c:type:`z_owned_source_info_t`.\n   source_id: Pointer to a :c:type:`z_entity_global_id_t` global entity id.\n   source_sn: :c:type:`uint32_t` sequence number.\n\n Return:\n   ``0`` if construction is successful, ``negative value`` otherwise.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_new(
        info: *mut z_owned_source_info_t,
        source_id: *const z_entity_global_id_t,
        source_sn: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the sequence number associated with this source info.\n\n Parameters:\n   info: Pointer to the :c:type:`z_loaned_source_info_t` to get the parameters from.\n\n Return:\n   :c:type:`uint32_t` sequence number.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_sn(info: *const z_loaned_source_info_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Returns the sequence number associated with this source info.\n\n Parameters:\n   info: Pointer to the :c:type:`z_loaned_source_info_t` to get the parameters from.\n\n Return:\n   Global entity ID as a :c:type:`z_entity_global_id_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_id(info: *const z_loaned_source_info_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Builds a default query target.\n\n Return:\n   The constructed :c:type:`z_query_target_t`."]
    pub fn z_query_target_default() -> z_query_target_t;
}
unsafe extern "C" {
    #[doc = " Builds an automatic query consolidation :c:type:`z_query_consolidation_t`.\n\n A query consolidation strategy will automatically be selected depending on the query selector.\n If selector contains time range properties, no consolidation is performed.\n Otherwise the :c:func:`z_query_consolidation_latest` strategy is used.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_auto() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a default :c:type:`z_query_consolidation_t`.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_default() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a latest query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy optimizes bandwidth on all links in the system but will provide a very poor latency.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_latest() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a monotonic query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy offers the best latency. Replies are directly transmitted to the application when received\n without needing to wait for all replies. This mode does not guarantee that there will be no duplicates.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_monotonic() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a no query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy is useful when querying timeseries data bases or when using quorums.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_none() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Gets a query parameters field.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the parameters from.\n   parameters: Pointer to an uninitialized :c:type:`z_view_string_t` to contain the parameters."]
    pub fn z_query_parameters(query: *const z_loaned_query_t, parameters: *mut z_view_string_t);
}
unsafe extern "C" {
    #[doc = " Gets a query payload by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the value from.\n\n Return:\n   Pointer to the payload as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_query_payload(query: *const z_loaned_query_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a query encoding by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the value from.\n\n Return:\n   Pointer to the encoding as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_query_encoding(query: *const z_loaned_query_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Gets a query attachment value by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the attachment from.\n\n Return:\n   Pointer to the attachment as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_query_attachment(query: *const z_loaned_query_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a query keyexpr by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a:c:type:`z_keyexpr_t`."]
    pub fn z_query_keyexpr(query: *const z_loaned_query_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Builds a new sample closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_sample_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_sample(
        closure: *mut z_owned_closure_sample_t,
        call: z_closure_sample_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a sample closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_sample_t` to call.\n   sample: Pointer to the :c:type:`z_loaned_sample_t` to pass to the closure."]
    pub fn z_closure_sample_call(
        closure: *const z_loaned_closure_sample_t,
        sample: *mut z_loaned_sample_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new query closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_query_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_query(
        closure: *mut z_owned_closure_query_t,
        call: z_closure_query_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a query closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_query_t` to call.\n   query: Pointer to the :c:type:`z_loaned_query_t` to pass to the closure."]
    pub fn z_closure_query_call(
        closure: *const z_loaned_closure_query_t,
        query: *mut z_loaned_query_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new reply closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_reply_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_reply(
        closure: *mut z_owned_closure_reply_t,
        call: z_closure_reply_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a reply closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_reply_t` to call.\n   reply: Pointer to the :c:type:`z_loaned_reply_t` to pass to the closure."]
    pub fn z_closure_reply_call(
        closure: *const z_loaned_closure_reply_t,
        reply: *mut z_loaned_reply_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new hello closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_hello_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_hello(
        closure: *mut z_owned_closure_hello_t,
        call: z_closure_hello_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a hello closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_hello_t` to call.\n   hello: Pointer to the :c:type:`z_loaned_hello_t` to pass to the closure."]
    pub fn z_closure_hello_call(
        closure: *const z_loaned_closure_hello_t,
        hello: *mut z_loaned_hello_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new zid closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_zid_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_zid(
        closure: *mut z_owned_closure_zid_t,
        call: z_closure_zid_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a zid closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_zid_t` to call.\n   zid: Pointer to the :c:type:`z_id_t` to pass to the closure."]
    pub fn z_closure_zid_call(closure: *const z_loaned_closure_zid_t, id: *const z_id_t);
}
unsafe extern "C" {
    #[doc = " Builds a new matching status closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_matching_status_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_matching_status(
        closure: *mut z_owned_closure_matching_status_t,
        call: z_closure_matching_status_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a matching status closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_matching_status_t` to call.\n   status: Pointer to the :c:type:`z_matching_status_t` to pass to the closure."]
    pub fn z_closure_matching_status_call(
        closure: *const z_loaned_closure_matching_status_t,
        status: *const z_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_null(obj: *mut z_owned_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_check(obj: *const z_owned_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_loan(obj: *const z_owned_string_t) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_loan_mut(obj: *mut z_owned_string_t) -> *mut z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_move(obj: *mut z_owned_string_t) -> *mut z_moved_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_take(obj: *mut z_owned_string_t, src: *mut z_moved_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_drop(obj: *mut z_moved_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_take_from_loaned(
        dst: *mut z_owned_string_t,
        src: *mut z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_clone(obj: *mut z_owned_string_t, src: *const z_loaned_string_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_keyexpr_null(obj: *mut z_owned_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_keyexpr_check(obj: *const z_owned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_loan(obj: *const z_owned_keyexpr_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_loan_mut(obj: *mut z_owned_keyexpr_t) -> *mut z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_move(obj: *mut z_owned_keyexpr_t) -> *mut z_moved_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_take(obj: *mut z_owned_keyexpr_t, src: *mut z_moved_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_drop(obj: *mut z_moved_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_take_from_loaned(
        dst: *mut z_owned_keyexpr_t,
        src: *mut z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_keyexpr_clone(
        obj: *mut z_owned_keyexpr_t,
        src: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_config_null(obj: *mut z_owned_config_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_config_check(obj: *const z_owned_config_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_loan(obj: *const z_owned_config_t) -> *const z_loaned_config_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_loan_mut(obj: *mut z_owned_config_t) -> *mut z_loaned_config_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_move(obj: *mut z_owned_config_t) -> *mut z_moved_config_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_take(obj: *mut z_owned_config_t, src: *mut z_moved_config_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_drop(obj: *mut z_moved_config_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_take_from_loaned(
        dst: *mut z_owned_config_t,
        src: *mut z_loaned_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_config_clone(obj: *mut z_owned_config_t, src: *const z_loaned_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_session_null(obj: *mut z_owned_session_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_session_check(obj: *const z_owned_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_loan(obj: *const z_owned_session_t) -> *const z_loaned_session_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_loan_mut(obj: *mut z_owned_session_t) -> *mut z_loaned_session_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_move(obj: *mut z_owned_session_t) -> *mut z_moved_session_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_take(obj: *mut z_owned_session_t, src: *mut z_moved_session_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_session_drop(obj: *mut z_moved_session_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_subscriber_null(obj: *mut z_owned_subscriber_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_subscriber_check(obj: *const z_owned_subscriber_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_loan(obj: *const z_owned_subscriber_t) -> *const z_loaned_subscriber_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_loan_mut(obj: *mut z_owned_subscriber_t) -> *mut z_loaned_subscriber_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_move(obj: *mut z_owned_subscriber_t) -> *mut z_moved_subscriber_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_take(obj: *mut z_owned_subscriber_t, src: *mut z_moved_subscriber_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_subscriber_drop(obj: *mut z_moved_subscriber_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_publisher_null(obj: *mut z_owned_publisher_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_publisher_check(obj: *const z_owned_publisher_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_loan(obj: *const z_owned_publisher_t) -> *const z_loaned_publisher_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_loan_mut(obj: *mut z_owned_publisher_t) -> *mut z_loaned_publisher_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_move(obj: *mut z_owned_publisher_t) -> *mut z_moved_publisher_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_take(obj: *mut z_owned_publisher_t, src: *mut z_moved_publisher_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_publisher_drop(obj: *mut z_moved_publisher_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_querier_null(obj: *mut z_owned_querier_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_querier_check(obj: *const z_owned_querier_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_loan(obj: *const z_owned_querier_t) -> *const z_loaned_querier_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_loan_mut(obj: *mut z_owned_querier_t) -> *mut z_loaned_querier_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_move(obj: *mut z_owned_querier_t) -> *mut z_moved_querier_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_take(obj: *mut z_owned_querier_t, src: *mut z_moved_querier_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_querier_drop(obj: *mut z_moved_querier_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_matching_listener_null(obj: *mut z_owned_matching_listener_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_matching_listener_check(obj: *const z_owned_matching_listener_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_loan(
        obj: *const z_owned_matching_listener_t,
    ) -> *const z_loaned_matching_listener_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_loan_mut(
        obj: *mut z_owned_matching_listener_t,
    ) -> *mut z_loaned_matching_listener_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_move(
        obj: *mut z_owned_matching_listener_t,
    ) -> *mut z_moved_matching_listener_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_take(
        obj: *mut z_owned_matching_listener_t,
        src: *mut z_moved_matching_listener_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_matching_listener_drop(obj: *mut z_moved_matching_listener_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_queryable_null(obj: *mut z_owned_queryable_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_queryable_check(obj: *const z_owned_queryable_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_loan(obj: *const z_owned_queryable_t) -> *const z_loaned_queryable_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_loan_mut(obj: *mut z_owned_queryable_t) -> *mut z_loaned_queryable_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_move(obj: *mut z_owned_queryable_t) -> *mut z_moved_queryable_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_take(obj: *mut z_owned_queryable_t, src: *mut z_moved_queryable_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_queryable_drop(obj: *mut z_moved_queryable_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_hello_null(obj: *mut z_owned_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_hello_check(obj: *const z_owned_hello_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_loan(obj: *const z_owned_hello_t) -> *const z_loaned_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_loan_mut(obj: *mut z_owned_hello_t) -> *mut z_loaned_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_move(obj: *mut z_owned_hello_t) -> *mut z_moved_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_take(obj: *mut z_owned_hello_t, src: *mut z_moved_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_drop(obj: *mut z_moved_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_take_from_loaned(
        dst: *mut z_owned_hello_t,
        src: *mut z_loaned_hello_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_hello_clone(obj: *mut z_owned_hello_t, src: *const z_loaned_hello_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_null(obj: *mut z_owned_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_check(obj: *const z_owned_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_loan(obj: *const z_owned_reply_t) -> *const z_loaned_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_loan_mut(obj: *mut z_owned_reply_t) -> *mut z_loaned_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_move(obj: *mut z_owned_reply_t) -> *mut z_moved_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_take(obj: *mut z_owned_reply_t, src: *mut z_moved_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_drop(obj: *mut z_moved_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_take_from_loaned(
        dst: *mut z_owned_reply_t,
        src: *mut z_loaned_reply_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_clone(obj: *mut z_owned_reply_t, src: *const z_loaned_reply_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_array_null(obj: *mut z_owned_string_array_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_string_array_check(obj: *const z_owned_string_array_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_loan(
        obj: *const z_owned_string_array_t,
    ) -> *const z_loaned_string_array_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_loan_mut(
        obj: *mut z_owned_string_array_t,
    ) -> *mut z_loaned_string_array_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_move(obj: *mut z_owned_string_array_t) -> *mut z_moved_string_array_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_take(obj: *mut z_owned_string_array_t, src: *mut z_moved_string_array_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_drop(obj: *mut z_moved_string_array_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_take_from_loaned(
        dst: *mut z_owned_string_array_t,
        src: *mut z_loaned_string_array_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_string_array_clone(
        obj: *mut z_owned_string_array_t,
        src: *const z_loaned_string_array_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_sample_null(obj: *mut z_owned_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_sample_check(obj: *const z_owned_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_loan(obj: *const z_owned_sample_t) -> *const z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_loan_mut(obj: *mut z_owned_sample_t) -> *mut z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_move(obj: *mut z_owned_sample_t) -> *mut z_moved_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_take(obj: *mut z_owned_sample_t, src: *mut z_moved_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_drop(obj: *mut z_moved_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_take_from_loaned(
        dst: *mut z_owned_sample_t,
        src: *mut z_loaned_sample_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_sample_clone(obj: *mut z_owned_sample_t, src: *const z_loaned_sample_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_source_info_null(obj: *mut z_owned_source_info_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_source_info_check(obj: *const z_owned_source_info_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_loan(obj: *const z_owned_source_info_t) -> *const z_loaned_source_info_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_loan_mut(obj: *mut z_owned_source_info_t) -> *mut z_loaned_source_info_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_move(obj: *mut z_owned_source_info_t) -> *mut z_moved_source_info_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_take(obj: *mut z_owned_source_info_t, src: *mut z_moved_source_info_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_drop(obj: *mut z_moved_source_info_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_take_from_loaned(
        dst: *mut z_owned_source_info_t,
        src: *mut z_loaned_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_source_info_clone(
        obj: *mut z_owned_source_info_t,
        src: *const z_loaned_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_query_null(obj: *mut z_owned_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_query_check(obj: *const z_owned_query_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_loan(obj: *const z_owned_query_t) -> *const z_loaned_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_loan_mut(obj: *mut z_owned_query_t) -> *mut z_loaned_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_move(obj: *mut z_owned_query_t) -> *mut z_moved_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_take(obj: *mut z_owned_query_t, src: *mut z_moved_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_drop(obj: *mut z_moved_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_take_from_loaned(
        dst: *mut z_owned_query_t,
        src: *mut z_loaned_query_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_query_clone(obj: *mut z_owned_query_t, src: *const z_loaned_query_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_slice_null(obj: *mut z_owned_slice_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_slice_check(obj: *const z_owned_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_loan(obj: *const z_owned_slice_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_loan_mut(obj: *mut z_owned_slice_t) -> *mut z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_move(obj: *mut z_owned_slice_t) -> *mut z_moved_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_take(obj: *mut z_owned_slice_t, src: *mut z_moved_slice_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_drop(obj: *mut z_moved_slice_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_take_from_loaned(
        dst: *mut z_owned_slice_t,
        src: *mut z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_slice_clone(obj: *mut z_owned_slice_t, src: *const z_loaned_slice_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_null(obj: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_check(obj: *const z_owned_bytes_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_loan(obj: *const z_owned_bytes_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_loan_mut(obj: *mut z_owned_bytes_t) -> *mut z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_move(obj: *mut z_owned_bytes_t) -> *mut z_moved_bytes_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_take(obj: *mut z_owned_bytes_t, src: *mut z_moved_bytes_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_drop(obj: *mut z_moved_bytes_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_take_from_loaned(
        dst: *mut z_owned_bytes_t,
        src: *mut z_loaned_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_clone(obj: *mut z_owned_bytes_t, src: *const z_loaned_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_writer_null(obj: *mut z_owned_bytes_writer_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_bytes_writer_check(obj: *const z_owned_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_loan(
        obj: *const z_owned_bytes_writer_t,
    ) -> *const z_loaned_bytes_writer_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_loan_mut(
        obj: *mut z_owned_bytes_writer_t,
    ) -> *mut z_loaned_bytes_writer_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_move(obj: *mut z_owned_bytes_writer_t) -> *mut z_moved_bytes_writer_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_take(obj: *mut z_owned_bytes_writer_t, src: *mut z_moved_bytes_writer_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_drop(obj: *mut z_moved_bytes_writer_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_bytes_writer_take_from_loaned(
        dst: *mut z_owned_bytes_writer_t,
        src: *mut z_loaned_bytes_writer_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_err_null(obj: *mut z_owned_reply_err_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_reply_err_check(obj: *const z_owned_reply_err_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_loan(obj: *const z_owned_reply_err_t) -> *const z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_loan_mut(obj: *mut z_owned_reply_err_t) -> *mut z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_move(obj: *mut z_owned_reply_err_t) -> *mut z_moved_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_take(obj: *mut z_owned_reply_err_t, src: *mut z_moved_reply_err_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_drop(obj: *mut z_moved_reply_err_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_take_from_loaned(
        dst: *mut z_owned_reply_err_t,
        src: *mut z_loaned_reply_err_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_reply_err_clone(
        obj: *mut z_owned_reply_err_t,
        src: *const z_loaned_reply_err_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_encoding_null(obj: *mut z_owned_encoding_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_encoding_check(obj: *const z_owned_encoding_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_loan(obj: *const z_owned_encoding_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_loan_mut(obj: *mut z_owned_encoding_t) -> *mut z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_move(obj: *mut z_owned_encoding_t) -> *mut z_moved_encoding_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_take(obj: *mut z_owned_encoding_t, src: *mut z_moved_encoding_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_drop(obj: *mut z_moved_encoding_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_take_from_loaned(
        dst: *mut z_owned_encoding_t,
        src: *mut z_loaned_encoding_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_encoding_clone(
        obj: *mut z_owned_encoding_t,
        src: *const z_loaned_encoding_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_sample_null(closure_sample: *mut z_owned_closure_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_sample_check(val: *const z_owned_closure_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_move(
        val: *mut z_owned_closure_sample_t,
    ) -> *mut z_moved_closure_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_take(
        obj: *mut z_owned_closure_sample_t,
        src: *mut z_moved_closure_sample_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_drop(obj: *mut z_moved_closure_sample_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_sample_loan(
        val: *const z_owned_closure_sample_t,
    ) -> *const z_loaned_closure_sample_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_query_null(closure_query: *mut z_owned_closure_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_query_check(val: *const z_owned_closure_query_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_move(val: *mut z_owned_closure_query_t) -> *mut z_moved_closure_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_take(
        obj: *mut z_owned_closure_query_t,
        src: *mut z_moved_closure_query_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_drop(obj: *mut z_moved_closure_query_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_query_loan(
        val: *const z_owned_closure_query_t,
    ) -> *const z_loaned_closure_query_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_reply_null(closure_reply: *mut z_owned_closure_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_reply_check(val: *const z_owned_closure_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_move(val: *mut z_owned_closure_reply_t) -> *mut z_moved_closure_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_take(
        obj: *mut z_owned_closure_reply_t,
        src: *mut z_moved_closure_reply_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_drop(obj: *mut z_moved_closure_reply_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_reply_loan(
        val: *const z_owned_closure_reply_t,
    ) -> *const z_loaned_closure_reply_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_hello_null(closure_hello: *mut z_owned_closure_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_hello_check(val: *const z_owned_closure_hello_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_move(val: *mut z_owned_closure_hello_t) -> *mut z_moved_closure_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_take(
        obj: *mut z_owned_closure_hello_t,
        src: *mut z_moved_closure_hello_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_drop(obj: *mut z_moved_closure_hello_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_hello_loan(
        val: *const z_owned_closure_hello_t,
    ) -> *const z_loaned_closure_hello_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_zid_null(closure_zid: *mut z_owned_closure_zid_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_zid_check(val: *const z_owned_closure_zid_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_move(val: *mut z_owned_closure_zid_t) -> *mut z_moved_closure_zid_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_take(obj: *mut z_owned_closure_zid_t, src: *mut z_moved_closure_zid_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_drop(obj: *mut z_moved_closure_zid_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_zid_loan(val: *const z_owned_closure_zid_t) -> *const z_loaned_closure_zid_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_matching_status_null(
        closure_matching_status: *mut z_owned_closure_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_internal_closure_matching_status_check(
        val: *const z_owned_closure_matching_status_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_move(
        val: *mut z_owned_closure_matching_status_t,
    ) -> *mut z_moved_closure_matching_status_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_take(
        obj: *mut z_owned_closure_matching_status_t,
        src: *mut z_moved_closure_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_drop(obj: *mut z_moved_closure_matching_status_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_closure_matching_status_loan(
        val: *const z_owned_closure_matching_status_t,
    ) -> *const z_loaned_closure_matching_status_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_is_empty(obj: *const z_view_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_loan(keyexpr: *const z_view_keyexpr_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_loan_mut(keyexpr: *mut z_view_keyexpr_t) -> *mut z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_keyexpr_empty(keyexpr: *mut z_view_keyexpr_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_is_empty(obj: *const z_view_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_loan(string: *const z_view_string_t) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_loan_mut(string: *mut z_view_string_t) -> *mut z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_string_empty(string: *mut z_view_string_t);
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_is_empty(obj: *const z_view_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_loan(slice: *const z_view_slice_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_loan_mut(slice: *mut z_view_slice_t) -> *mut z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Loans"]
    pub fn z_view_slice_empty(slice: *mut z_view_slice_t);
}
unsafe extern "C" {
    #[doc = " Gets data from a :c:type:`z_loaned_string_t`.\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get data from.\n\n Return:\n   Pointer to the string data."]
    pub fn z_string_data(str_: *const z_loaned_string_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Gets string length from a :c:type:`z_loaned_string_t`.\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get length from.\n\n Return:\n   Length of the string."]
    pub fn z_string_len(str_: *const z_loaned_string_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_string_t` by copying a ``const char *`` string.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a null terminated string to be copied.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_copy_from_str(
        str_: *mut z_owned_string_t,
        value: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_string_t` by transferring ownership over a null-terminated string to it.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a null terminated string to be owned by `str`.\n   deleter: A thread-safe delete function to free the `value`. Will be called once when `str` is dropped.\n     Can be NULL in the case where `value` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_from_str(
        str_: *mut z_owned_string_t,
        value: *mut ::std::os::raw::c_char,
        deleter: ::std::option::Option<
            unsafe extern "C" fn(
                value: *mut ::std::os::raw::c_void,
                context: *mut ::std::os::raw::c_void,
            ),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds an empty :c:type:`z_owned_string_t`.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`."]
    pub fn z_string_empty(str_: *mut z_owned_string_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_string_t` by wrapping a substring specified by ``const char *`` and length `len`.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a string.\n   len: String size.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_copy_from_substr(
        str_: *mut z_owned_string_t,
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if string is empty\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to check.\n\n Return:\n  ``true`` if the string is empty, ``false`` otherwise."]
    pub fn z_string_is_empty(str_: *const z_loaned_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns :c:type:`z_loaned_slice_t` for the string\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get a slice.\n\n Return:\n   slice containing string data"]
    pub fn z_string_as_slice(str_: *const z_loaned_string_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Returns default :c:type:`z_priority_t` value"]
    pub fn z_priority_default() -> z_priority_t;
}
unsafe extern "C" {
    #[doc = " Returns id of Zenoh entity that transmitted hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   Id of the Zenoh entity that transmitted hello message."]
    pub fn z_hello_zid(hello: *const z_loaned_hello_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Returns type of Zenoh entity that transmitted hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   Type of the Zenoh entity that transmitted hello message."]
    pub fn z_hello_whatami(hello: *const z_loaned_hello_t) -> z_whatami_t;
}
unsafe extern "C" {
    #[doc = " Constructs an array of locators of Zenoh entity that sent hello message.\n\n Note that it is a method for zenoh-c compatiblity, in zenoh-pico :c:func:`zp_hello_locators`\n can be used.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n   locators_out: An uninitialized memory location where :c:type:`z_owned_string_array_t` will be constructed."]
    pub fn z_hello_locators(
        hello: *const z_loaned_hello_t,
        locators_out: *mut z_owned_string_array_t,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a non-owned non-null-terminated string from the kind of zenoh entity.\n\n The string has static storage (i.e. valid until the end of the program).\n\n Parameters:\n   whatami: A whatami bitmask of zenoh entity kind.\n   str_out: An uninitialized memory location where strring will be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_whatami_to_view_string(
        whatami: z_whatami_t,
        str_out: *mut z_view_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Scouts for other Zenoh entities like routers and/or peers.\n\n Parameters:\n   config: Moved :c:type:`z_owned_config_t` to configure the scouting with.\n   callback: Moved :c:type:`z_owned_closure_hello_t` callback.\n   options: Pointer to a :c:type:`z_scout_options_t` to configure the operation.\n\n Return:\n   ``0`` if scouting was successfully triggered, ``negative value`` otherwise."]
    pub fn z_scout(
        config: *mut z_moved_config_t,
        callback: *mut z_moved_closure_hello_t,
        options: *const z_scout_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_scout_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_scout_options_t`."]
    pub fn z_scout_options_default(options: *mut z_scout_options_t);
}
unsafe extern "C" {
    #[doc = " Opens a Zenoh session.\n\n Parameters:\n   zs: Pointer to an uninitialized :c:type:`z_owned_session_t` to store the session info.\n   config: Moved :c:type:`z_owned_config_t` to configure the session with.\n   options: Pointer to a :c:type:`z_open_options_t` to configure the operation.\n\n Return:\n   ``0`` if open is successful, ``negative value`` otherwise."]
    pub fn z_open(
        zs: *mut z_owned_session_t,
        config: *mut z_moved_config_t,
        options: *const z_open_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Closes a Zenoh session.\n\n Parameters:\n   zs: Loaned :c:type:`z_owned_session_t` to close.\n   options: Pointer to a :c:type:`z_close_options_t` to configure the operation.\n\n Return:\n   ``0`` if close is successful, ``negative value`` otherwise."]
    pub fn z_close(zs: *mut z_loaned_session_t, options: *const z_close_options_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if Zenoh session is closed.\n\n Parameters:\n   zs: Loaned :c:type:`z_owned_session_t`.\n\n Return:\n   ``true`` if session is closed, ``false`` otherwise."]
    pub fn z_session_is_closed(zs: *const z_loaned_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Fetches Zenoh IDs of all connected peers.\n\n The callback will be called once for each ID. It is guaranteed to never be called concurrently,\n and to be dropped before this function exits.\n\n Parameters:\n   zs: Pointer to :c:type:`z_loaned_session_t` to fetch peer id from.\n   callback: Moved :c:type:`z_owned_closure_zid_t` callback.\n\n Return:\n   ``0`` if operation was successfully triggered, ``negative value`` otherwise."]
    pub fn z_info_peers_zid(
        zs: *const z_loaned_session_t,
        callback: *mut z_moved_closure_zid_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Fetches Zenoh IDs of all connected routers.\n\n The callback will be called once for each ID. It is guaranteed to never be called concurrently,\n and to be dropped before this function exits.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to fetch router id from.\n   callback: Moved :c:type:`z_owned_closure_zid_t` callback.\n\n Return:\n   ``0`` if operation was successfully triggered, ``negative value`` otherwise."]
    pub fn z_info_routers_zid(
        zs: *const z_loaned_session_t,
        callback: *mut z_moved_closure_zid_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the local Zenoh ID associated to a given Zenoh session.\n\n If this function returns an array of 16 zeros, this means the session is invalid.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to get the id from.\n\n Return:\n   The local Zenoh ID of the session as :c:type:`z_id_t`."]
    pub fn z_info_zid(zs: *const z_loaned_session_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Converts a Zenoh ID into a string for print purposes.\n\n Parameters:\n   id: Pointer to the id to convert.\n   str: Pointer to uninitialized :c:type:`z_owned_string_t` to store the string.\n\n Return:\n   ``0`` if operation is successful, ``negative value`` otherwise."]
    pub fn z_id_to_string(id: *const z_id_t, str_: *mut z_owned_string_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_sample_keyexpr(sample: *const z_loaned_sample_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Gets the payload of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the payload from.\n\n Return:\n   The payload wrapped as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_sample_payload(sample: *const z_loaned_sample_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets the timestamp of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the timestamp from.\n\n Return:\n   The pointer to timestamp wrapped as a :c:type:`z_timestamp_t`. Returns NULL if no timestamp was set."]
    pub fn z_sample_timestamp(sample: *const z_loaned_sample_t) -> *const z_timestamp_t;
}
unsafe extern "C" {
    #[doc = " Gets the encoding of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the encoding from.\n\n Return:\n   The encoding wrapped as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_sample_encoding(sample: *const z_loaned_sample_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Gets the kind of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the kind from.\n\n Return:\n   The sample kind wrapped as a :c:type:`z_sample_kind_t`."]
    pub fn z_sample_kind(sample: *const z_loaned_sample_t) -> z_sample_kind_t;
}
unsafe extern "C" {
    #[doc = " Got a sample qos congestion control value.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the congestion control from.\n\n Return:\n   The congestion control wrapped as a :c:type:`z_congestion_control_t`."]
    pub fn z_sample_congestion_control(sample: *const z_loaned_sample_t) -> z_congestion_control_t;
}
unsafe extern "C" {
    #[doc = " Got whether sample qos express flag was set or not.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the express flag from.\n\n Return:\n   The express flag value."]
    pub fn z_sample_express(sample: *const z_loaned_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets sample qos priority value.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the qos priority from.\n\n Return:\n   The priority wrapped as a :c:type:`z_priority_t`."]
    pub fn z_sample_priority(sample: *const z_loaned_sample_t) -> z_priority_t;
}
unsafe extern "C" {
    #[doc = " Gets the attachment of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the attachment from.\n\n Return:\n   Pointer to the attachment as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_sample_attachment(sample: *const z_loaned_sample_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_put_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_put_options_t`."]
    pub fn z_put_options_default(options: *mut z_put_options_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_delete_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_delete_options_t`."]
    pub fn z_delete_options_default(options: *mut z_delete_options_t);
}
unsafe extern "C" {
    #[doc = " Puts data for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to put the data through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to put the data for.\n   payload: Moved :c:type:`z_owned_bytes_t` containing the data to put.\n   options: Pointer to a :c:type:`z_put_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_put(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deletes data for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to delete the data through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to delete the data for.\n   options: Pointer to a :c:type:`z_delete_options_t` to configure the operation.\n\n Return:\n   ``0`` if delete operation is successful, ``negative value`` otherwise."]
    pub fn z_delete(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_delete_options_t`."]
    pub fn z_publisher_options_default(options: *mut z_publisher_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a publisher for a given keyexpr.\n\n Data can be put and deleted with this publisher with the help of the\n :c:func:`z_publisher_put` and :c:func:`z_publisher_delete` functions.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the publisher through.\n   pub: Pointer to an uninitialized :c:type:`z_owned_publisher_t`.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the publisher with.\n   options: Pointer to a :c:type:`z_publisher_options_t` to configure the operation.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_publisher(
        zs: *const z_loaned_session_t,
        pub_: *mut z_owned_publisher_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_publisher_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the publisher.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_publisher_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_publisher(pub_: *mut z_moved_publisher_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_put_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_publisher_put_options_t`."]
    pub fn z_publisher_put_options_default(options: *mut z_publisher_put_options_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_delete_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_publisher_delete_options_t`."]
    pub fn z_publisher_delete_options_default(options: *mut z_publisher_delete_options_t);
}
unsafe extern "C" {
    #[doc = " Puts data for the keyexpr bound to the given publisher.\n\n Parameters:\n   pub: Pointer to a :c:type:`z_loaned_publisher_t` from where to put the data.\n   payload: Moved :c:type:`z_owned_bytes_t` containing the data to put.\n   options: Pointer to a :c:type:`z_publisher_put_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_publisher_put(
        pub_: *const z_loaned_publisher_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_publisher_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deletes data from the keyexpr bound to the given publisher.\n\n Parameters:\n   pub: Pointer to a :c:type:`z_loaned_publisher_t` from where to delete the data.\n   options: Pointer to a :c:type:`z_publisher_delete_options_t` to configure the delete operation.\n\n Return:\n   ``0`` if delete operation is successful, ``negative value`` otherwise."]
    pub fn z_publisher_delete(
        pub_: *const z_loaned_publisher_t,
        options: *const z_publisher_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a publisher.\n\n Parameters:\n   publisher: Pointer to a :c:type:`z_loaned_publisher_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_publisher_keyexpr(publisher: *const z_loaned_publisher_t)
        -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Declares a matching listener, registering a callback for notifying subscribers matching with a given publisher.\n The callback will be run in the background until the corresponding publisher is dropped.\n\n Parameters:\n   publisher: A publisher to associate with matching listener.\n   callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber\n disconnects or when the first subscriber connects).\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_declare_background_matching_listener(
        publisher: *const z_loaned_publisher_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs matching listener, registering a callback for notifying subscribers matching with a given publisher.\n\n Parameters:\n   publisher: A publisher to associate with matching listener.\n   matching_listener: An uninitialized memory location where matching listener will be constructed. The matching\n listener's callback will be automatically dropped when the publisher is dropped. callback: A closure that will be\n called every time the matching status of the publisher changes (If last subscriber disconnects or when the first\n subscriber connects).\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_declare_matching_listener(
        publisher: *const z_loaned_publisher_t,
        matching_listener: *mut z_owned_matching_listener_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets publisher matching status - i.e. if there are any subscribers matching its key expression.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_get_matching_status(
        publisher: *const z_loaned_publisher_t,
        matching_status: *mut z_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the matching listener.\n\n Parameters:\n   listener: Moved :c:type:`z_owned_matching_listener_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_matching_listener(listener: *mut z_moved_matching_listener_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_get_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_get_options_t`."]
    pub fn z_get_options_default(options: *mut z_get_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a distributed query for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to send the query through.\n   keyexpr: Pointer to a  :c:type:`z_loaned_keyexpr_t` to send the query for.\n   parameters: Pointer to the parameters as a null-terminated string.\n   callback: Moved :c:type:`z_owned_closure_reply_t` callback.\n   options: Pointer to a :c:type:`z_get_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_get(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        parameters: *const ::std::os::raw::c_char,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sends a distributed query for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to send the query through.\n   keyexpr: Pointer to a  :c:type:`z_loaned_keyexpr_t` to send the query for.\n   parameters: Pointer to the parameters string.\n   parameters_len: Length of the parameters string.\n   callback: Moved :c:type:`z_owned_closure_reply_t` callback.\n   options: Pointer to a :c:type:`z_get_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_get_with_parameters_substr(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        parameters: *const ::std::os::raw::c_char,
        parameters_len: usize,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = "  Constructs the default value for :c:type:`z_querier_get_options_t`."]
    pub fn z_querier_get_options_default(options: *mut z_querier_get_options_t);
}
unsafe extern "C" {
    #[doc = "  Constructs the default value for :c:type:`z_querier_options_t`."]
    pub fn z_querier_options_default(options: *mut z_querier_options_t);
}
unsafe extern "C" {
    #[doc = " Constructs and declares a querier on the given key expression.\n\n The queries can be send with the help of the `z_querier_get()` function.\n\n Parameters:\n   zs: The Zenoh session.\n   querier: An uninitialized location in memory where querier will be constructed.\n   keyexpr: The key expression to send queries on.\n   options: Additional options for the querier.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_querier(
        zs: *const z_loaned_session_t,
        querier: *mut z_owned_querier_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *mut z_querier_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Frees memory and resets querier to its gravestone state."]
    pub fn z_undeclare_querier(querier: *mut z_moved_querier_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Query data from the matching queryables in the system.\n\n Replies are provided through a callback function.\n\n Parameters:\n   querier: The querier to make query from.\n   parameters: The query's parameters null-terminated string, similar to a url's query segment.\n   callback: The callback function that will be called on reception of replies for this query. It will be\n \t\t\t\tautomatically dropped once all replies are processed.\n   options: Additional options for the get. All owned fields will be consumed.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get(
        querier: *const z_loaned_querier_t,
        parameters: *const ::std::os::raw::c_char,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_querier_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Query data from the matching queryables in the system.\n\n Replies are provided through a callback function.\n\n Parameters:\n   querier: The querier to make query from.\n   parameters: The query's parameters string, similar to a url's query segment.\n   parameters_len: Length of the parameters string\n   callback: The callback function that will be called on reception of replies for this query. It will be\n \t\t\t\tautomatically dropped once all replies are processed.\n   options: Additional options for the get. All owned fields will be consumed.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get_with_parameters_substr(
        querier: *const z_loaned_querier_t,
        parameters: *const ::std::os::raw::c_char,
        parameters_len: usize,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_querier_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = "  Returns the key expression of the querier."]
    pub fn z_querier_keyexpr(querier: *const z_loaned_querier_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Declares a matching listener, registering a callback for notifying queryables matching the given querier key\n expression and target. The callback will be run in the background until the corresponding querier is dropped.\n\n Parameters:\n   querier: A querier to associate with matching listener.\n   callback: A closure that will be called every time the matching status of the querier changes (If last\n             queryable disconnects or when the first queryable connects).\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_declare_background_matching_listener(
        querier: *const z_loaned_querier_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs matching listener, registering a callback for notifying queryables matching with a given querier's\n key expression and target.\n\n Parameters:\n   querier: A querier to associate with matching listener.\n   matching_listener: An uninitialized memory location where matching listener will be constructed. The matching\n                      listener's callback will be automatically dropped when the querier is dropped.\n   callback: A closure that will be called every time the matching status of the querier changes (If last\n             queryable disconnects or when the first queryable connects).\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_declare_matching_listener(
        querier: *const z_loaned_querier_t,
        matching_listener: *mut z_owned_matching_listener_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets querier matching status - i.e. if there are any queryables matching its key expression and target.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get_matching_status(
        querier: *const z_loaned_querier_t,
        matching_status: *mut z_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if queryable answered with an OK, which allows this value to be treated as a sample.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to check.\n\n Return:\n   ``true`` if queryable answered with an OK, ``false`` otherwise."]
    pub fn z_reply_is_ok(reply: *const z_loaned_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the content of an OK reply.\n\n You should always make sure that :c:func:`z_reply_is_ok` returns ``true`` before calling this function.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n   The OK reply content wrapped as a :c:type:`z_loaned_sample_t`."]
    pub fn z_reply_ok(reply: *const z_loaned_reply_t) -> *const z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Gets the contents of an error reply.\n\n You should always make sure that :c:func:`z_reply_is_ok` returns ``false`` before calling this function.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n   The error reply content wrapped as a :c:type:`z_loaned_reply_err_t`."]
    pub fn z_reply_err(reply: *const z_loaned_reply_t) -> *const z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_queryable_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_queryable_options_t`."]
    pub fn z_queryable_options_default(options: *mut z_queryable_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a queryable for a given keyexpr.\n Note that dropping queryable drops its callback.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   queryable: Pointer to an uninitialized :c:type:`z_owned_queryable_t` to contain the queryable.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a :c:type:`z_owned_closure_query_t` callback.\n   options: Pointer to a :c:type:`z_queryable_options_t` to configure the declare.\n\n Return:\n   ``0`` if declare operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_queryable(
        zs: *const z_loaned_session_t,
        queryable: *mut z_owned_queryable_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_query_t,
        options: *const z_queryable_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the queryable.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_queryable_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_queryable(pub_: *mut z_moved_queryable_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background queryable for a given keyexpr. The queryable callback will be called\n to proccess incoming queries until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a :c:type:`z_owned_closure_query_t` callback.\n   options: Pointer to a :c:type:`z_queryable_options_t` to configure the declare.\n\n Return:\n   ``0`` if declare operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_background_queryable(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_query_t,
        options: *const z_queryable_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_options_t`."]
    pub fn z_query_reply_options_default(options: *mut z_query_reply_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the reply with.\n   payload: Pointer to the reply data.\n   options: Pointer to a :c:type:`z_query_reply_options_t` to configure the reply.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply(
        query: *const z_loaned_query_t,
        keyexpr: *const z_loaned_keyexpr_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_query_reply_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_del_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_del_options_t`."]
    pub fn z_query_reply_del_options_default(options: *mut z_query_reply_del_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply delete to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the reply with.\n   options: Pointer to a :c:type:`z_query_reply_del_options_t` to configure the reply.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply_del(
        query: *const z_loaned_query_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_query_reply_del_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_err_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_err_options_t`."]
    pub fn z_query_reply_err_options_default(options: *mut z_query_reply_err_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply error to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   payload: Moved reply error data payload.\n   options: Pointer to a :c:type:`z_query_reply_err_options_t` to configure the reply error.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply_err(
        query: *const z_loaned_query_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_query_reply_err_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a queryable.\n\n Parameters:\n   queryable: Pointer to a :c:type:`z_loaned_queryable_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`. Will return NULL if\n   corresponding session is closed or dropped."]
    pub fn z_queryable_keyexpr(queryable: *const z_loaned_queryable_t)
        -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Builds a new keyexpr.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the null-terminated string of the keyexpr.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_str(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a new keyexpr from a substring.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the start of the substring for keyxpr.\n   len: Length of the substring to consider.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_substr(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_keyexpr_t` from a null-terminated string with auto canonization.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_str_autocanonize(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_keyexpr_t` from a substring with auto canonization.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the start of the substring for keyexpr.\n   len: Length of the substring to consider. After the function return it will be equal to the canonized key\n     expression string length.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_substr_autocanonize(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::std::os::raw::c_char,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a keyexpr, so that it is mapped on a numerical id.\n\n This numerical id is used on the network to save bandwidth and ease the retrieval of the concerned resource\n in the routing tables.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the keyexpr through.\n   declared_keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to contain the declared keyexpr.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the keyexpr with.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_keyexpr(
        zs: *const z_loaned_session_t,
        declared_keyexpr: *mut z_owned_keyexpr_t,
        keyexpr: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares a keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to undeclare the data through.\n   keyexpr: Moved :c:type:`z_owned_keyexpr_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_keyexpr(
        zs: *const z_loaned_session_t,
        keyexpr: *mut z_moved_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new empty string array.\n\n Parameters:\n   a: Pointer to an uninitialized :c:type:`z_owned_string_array_t` to store the array of strings."]
    pub fn z_string_array_new(a: *mut z_owned_string_array_t);
}
unsafe extern "C" {
    #[doc = " Appends specified value to the end of the string array by alias.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   value: Pointer to the string to be added.\n\n Return:\n   The new length of the array."]
    pub fn z_string_array_push_by_alias(
        a: *mut z_loaned_string_array_t,
        value: *const z_loaned_string_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Appends specified value to the end of the string array by copying.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   value: Pointer to the string to be added.\n\n Return:\n   The new length of the array."]
    pub fn z_string_array_push_by_copy(
        a: *mut z_loaned_string_array_t,
        value: *const z_loaned_string_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the value at the position of index in the string array.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   k: index value.\n\n Return:\n   `NULL` if the index is out of bounds."]
    pub fn z_string_array_get(
        a: *const z_loaned_string_array_t,
        k: usize,
    ) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements in the array."]
    pub fn z_string_array_len(a: *const z_loaned_string_array_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns ``true`` if the array is empty, ``false`` otherwise."]
    pub fn z_string_array_is_empty(a: *const z_loaned_string_array_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_subscriber_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_subscriber_options_t`."]
    pub fn z_subscriber_options_default(options: *mut z_subscriber_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a subscriber for a given keyexpr.\n Note that dropping subscriber drops its callback.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   sub: Pointer to a :c:type:`z_owned_subscriber_t` to contain the subscriber.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a`z_owned_closure_sample_t` callback.\n   options: Pointer to a :c:type:`z_subscriber_options_t` to configure the operation\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_subscriber(
        zs: *const z_loaned_session_t,
        sub: *mut z_owned_subscriber_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *const z_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the subscriber.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_subscriber_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_subscriber(pub_: *mut z_moved_subscriber_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background subscriber for a given keyexpr. Subscriber callback will be called to process the messages,\n until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a`z_owned_closure_sample_t` callback.\n   options: Pointer to a :c:type:`z_subscriber_options_t` to configure the operation\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_background_subscriber(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *const z_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a subscriber.\n\n Parameters:\n   subscriber: Pointer to a :c:type:`z_loaned_subscriber_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_subscriber_keyexpr(
        subscriber: *const z_loaned_subscriber_t,
    ) -> *const z_loaned_keyexpr_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub _address: u8,
}
